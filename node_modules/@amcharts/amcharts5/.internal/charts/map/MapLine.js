import { __extends } from "tslib";
import * as $type from "../../core/util/Type";
import { Percent } from "../../core/util/Percent";
import { Graphics } from "../../core/render/Graphics";
import { geoLength, geoInterpolate, geoDistance } from "d3-geo";
/**
 * A line object in a [[MapLineSeries]].
 */
var MapLine = /** @class */ (function (_super) {
    __extends(MapLine, _super);
    function MapLine() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        Object.defineProperty(_this, "_projectionDirty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        return _this;
    }
    Object.defineProperty(MapLine.prototype, "_beforeChanged", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var _this = this;
            _super.prototype._beforeChanged.call(this);
            if (this._projectionDirty || this.isDirty("geometry") || this.isDirty("precision")) {
                var geometry_1 = this.get("geometry");
                if (geometry_1) {
                    var series_1 = this.getPrivate("series");
                    if (series_1) {
                        var chart_1 = series_1.chart;
                        if (chart_1) {
                            var projection_1 = chart_1.get("projection");
                            var clipAngle_1 = null;
                            if (projection_1 && projection_1.clipAngle) {
                                clipAngle_1 = projection_1.clipAngle();
                                projection_1.precision(this.get("precision", 0.5));
                            }
                            var dataItem = this.dataItem;
                            var geoPath_1 = chart_1.getPrivate("geoPath");
                            if (geoPath_1 && dataItem) {
                                this._clear = true;
                                if (dataItem.get("lineType", series_1.get("lineType")) == "straight") {
                                    var geometry_2 = this.get("geometry");
                                    if (geometry_2) {
                                        var coordinates = geometry_2.coordinates;
                                        if (coordinates) {
                                            var segments_1;
                                            if (geometry_2.type == "LineString") {
                                                segments_1 = [coordinates];
                                            }
                                            else if (geometry_2.type == "MultiLineString") {
                                                segments_1 = coordinates;
                                            }
                                            this.set("draw", function (display) {
                                                for (var s = 0; s < segments_1.length; s++) {
                                                    var segment = segments_1[s];
                                                    if (segment.length > 0) {
                                                        var gp0 = segment[0];
                                                        var p0 = chart_1.convert({ longitude: gp0[0], latitude: gp0[1] });
                                                        display.lineTo(p0.x, p0.y);
                                                        for (var p = 0; p < segment.length; p++) {
                                                            var gp = segment[p];
                                                            var pn = chart_1.convert({ longitude: gp[0], latitude: gp[1] });
                                                            display.lineTo(pn.x, pn.y);
                                                        }
                                                    }
                                                }
                                            });
                                        }
                                    }
                                }
                                else {
                                    this.set("draw", function (_display) {
                                        if (projection_1 && series_1.get("clipBack") === false) {
                                            projection_1.clipAngle(180);
                                        }
                                        geoPath_1.context(_this._display);
                                        geoPath_1(geometry_1);
                                        geoPath_1.context(null);
                                        if (projection_1 && projection_1.clipAngle) {
                                            projection_1.clipAngle(clipAngle_1);
                                        }
                                    });
                                }
                            }
                        }
                    }
                }
                var type = "linechanged";
                if (this.events.isEnabled(type)) {
                    this.events.dispatch(type, { type: type, target: this });
                }
            }
        }
    });
    /**
     * @ignore
     */
    Object.defineProperty(MapLine.prototype, "markDirtyProjection", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            this.markDirty();
            this._projectionDirty = true;
        }
    });
    Object.defineProperty(MapLine.prototype, "_clearDirty", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            _super.prototype._clearDirty.call(this);
            this._projectionDirty = false;
        }
    });
    Object.defineProperty(MapLine.prototype, "_getTooltipPoint", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function () {
            var tooltipX = this.get("tooltipX");
            var tooltipY = this.get("tooltipY");
            var x = 0;
            var y = 0;
            if ($type.isNumber(tooltipX)) {
                x = tooltipX;
            }
            if ($type.isNumber(tooltipY)) {
                y = tooltipY;
            }
            if (tooltipX instanceof Percent) {
                var geoPoint = this.positionToGeoPoint(tooltipX.value);
                var series = this.getPrivate("series");
                if (series) {
                    var chart = series.chart;
                    if (chart) {
                        var point = chart.convert(geoPoint);
                        x = point.x;
                        y = point.y;
                    }
                }
            }
            return { x: x, y: y };
        }
    });
    /**
     * Converts relative position along the line (0-1) into pixel coordinates.
     *
     * @param position  Position (0-1)
     * @return Coordinates
     */
    Object.defineProperty(MapLine.prototype, "positionToGeoPoint", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function (position) {
            var geometry = this.get("geometry");
            var series = this.getPrivate("series");
            var chart = series.chart;
            var dataItem = this.dataItem;
            if (geometry && series && chart && dataItem) {
                var lineType = dataItem.get("lineType", series.get("lineType"));
                var totalDistance = geoLength(geometry);
                var currentDistance = 0;
                var distanceAB = void 0;
                var positionA = 0;
                var positionB = 0;
                var pointA = void 0;
                var pointB = void 0;
                var coordinates = geometry.coordinates;
                if (coordinates) {
                    var segments = void 0;
                    if (geometry.type == "LineString") {
                        segments = [coordinates];
                    }
                    else if (geometry.type == "MultiLineString") {
                        segments = coordinates;
                    }
                    for (var s = 0; s < segments.length; s++) {
                        var segment = segments[s];
                        if (segment.length > 1) {
                            for (var p = 1; p < segment.length; p++) {
                                pointA = segment[p - 1];
                                pointB = segment[p];
                                positionA = currentDistance / totalDistance;
                                distanceAB = geoDistance(pointA, pointB);
                                currentDistance += distanceAB;
                                positionB = currentDistance / totalDistance;
                                if (positionA <= position && positionB > position) {
                                    s = segments.length;
                                    break;
                                }
                            }
                        }
                        else if (segment.length == 1) {
                            pointA = segment[0];
                            pointB = segment[0];
                            positionA = 0;
                            positionB = 1;
                        }
                    }
                    if (pointA && pointB) {
                        var positionAB = (position - positionA) / (positionB - positionA);
                        var location_1;
                        if (lineType == "straight") {
                            var p0 = chart.convert({ longitude: pointA[0], latitude: pointA[1] });
                            var p1 = chart.convert({ longitude: pointB[0], latitude: pointB[1] });
                            var x = p0.x + (p1.x - p0.x) * positionAB;
                            var y = p0.y + (p1.y - p0.y) * positionAB;
                            return chart.invert({ x: x, y: y });
                        }
                        else {
                            location_1 = geoInterpolate(pointA, pointB)(positionAB);
                            return { longitude: location_1[0], latitude: location_1[1] };
                        }
                    }
                }
            }
            return { longitude: 0, latitude: 0 };
        }
    });
    Object.defineProperty(MapLine, "className", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: "MapLine"
    });
    Object.defineProperty(MapLine, "classNames", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: Graphics.classNames.concat([MapLine.className])
    });
    return MapLine;
}(Graphics));
export { MapLine };
//# sourceMappingURL=MapLine.js.map