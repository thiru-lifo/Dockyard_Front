{"ast":null,"code":"/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Disposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n */\n\nvar EventDispatcher =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   */\n  function EventDispatcher() {\n    Object.defineProperty(this, \"_listeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_killed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_iterating\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_enabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disposed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._listeners = [];\n    this._killed = [];\n    this._disabled = {};\n    this._iterating = 0;\n    this._enabled = true;\n    this._disposed = false;\n  }\n  /**\r\n   * Returns if this object has been already disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n\n\n  Object.defineProperty(EventDispatcher.prototype, \"isDisposed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._disposed;\n    }\n  });\n  /**\r\n   * Dispose (destroy) this object.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._disposed) {\n        this._disposed = true;\n        var a = this._listeners;\n        this._iterating = 1;\n        this._listeners = null;\n        this._disabled = null;\n\n        try {\n          $array.each(a, function (x) {\n            x.disposer.dispose();\n          });\n        } finally {\n          this._killed = null;\n          this._iterating = null;\n        }\n      }\n    }\n  });\n  /**\r\n   * Checks if this particular event dispatcher has any listeners set.\r\n   *\r\n   * @return Has listeners?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"hasListeners\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._listeners.length !== 0;\n    }\n  });\n  /**\r\n   * Checks if this particular event dispatcher has any particular listeners set.\r\n   *\r\n   * @return Has particular event listeners?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"hasListenersByType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      return $array.any(this._listeners, function (x) {\n        return (x.type === null || x.type === type) && !x.killed;\n      });\n    }\n  });\n  /**\r\n   * Enable dispatching of events if they were previously disabled by\r\n   * `disable()`.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"enable\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._enabled = true;\n    }\n  });\n  /**\r\n   * Disable dispatching of events until re-enabled by `enable()`.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"disable\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._enabled = false;\n    }\n  });\n  /**\r\n   * Enable dispatching particular event, if it was disabled before by\r\n   * `disableType()`.\r\n   *\r\n   * @param type Event type\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"enableType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      delete this._disabled[type];\n    }\n  });\n  /**\r\n   * Disable dispatching of events for a certain event type.\r\n   *\r\n   * Optionally, can set how many dispatches to skip before automatically\r\n   * re-enabling the dispatching.\r\n   *\r\n   * @param type    Event type\r\n   * @param amount  Number of event dispatches to skip\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"disableType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, amount) {\n      if (amount === void 0) {\n        amount = Infinity;\n      }\n\n      this._disabled[type] = amount;\n    }\n  });\n  /**\r\n   * Removes listener from dispatcher.\r\n   *\r\n   * Will throw an exception if such listener does not exists.\r\n   *\r\n   * @param listener Listener to remove\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_removeListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (listener) {\n      if (this._iterating === 0) {\n        var index = this._listeners.indexOf(listener);\n\n        if (index === -1) {\n          throw new Error(\"Invalid state: could not remove listener\");\n        }\n\n        this._listeners.splice(index, 1);\n      } else {\n        this._killed.push(listener);\n      }\n    }\n  });\n  /**\r\n   * Removes existing listener by certain parameters.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_removeExistingListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (once, type, callback, context) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._eachListener(function (info) {\n        if (info.once === once && // TODO is this correct ?\n        info.type === type && (callback === undefined || info.callback === callback) && info.context === context) {\n          info.disposer.dispose();\n        }\n      });\n    }\n  });\n  /**\r\n   * Checks if dispatching for particular event type is enabled.\r\n   *\r\n   * @param type  Event type\r\n   * @return Enabled?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"isEnabled\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      } // TODO is this check correct ?\n\n\n      return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n    }\n  });\n  /**\r\n   * Removes all listeners of a particular event type\r\n   *\r\n   * @param type  Listener's type\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"removeType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._eachListener(function (info) {\n        if (info.type === type) {\n          info.disposer.dispose();\n        }\n      });\n    }\n  });\n  /**\r\n   * Checks if there's already a listener with specific parameters.\r\n   *\r\n   * @param type      Listener's type\r\n   * @param callback  Callback function\r\n   * @param context   Callback context\r\n   * @return Has listener?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"has\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context) {\n      var index = $array.findIndex(this._listeners, function (info) {\n        return info.once !== true && // Ignoring \"once\" listeners\n        info.type === type && (callback === undefined || info.callback === callback) && info.context === context;\n      });\n      return index !== -1;\n    }\n  });\n  /**\r\n   * Checks whether event of the particular type should be dispatched.\r\n   *\r\n   * @param type  Event type\r\n   * @return Dispatch?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_shouldDispatch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      var count = this._disabled[type];\n\n      if (!$type.isNumber(count)) {\n        return this._enabled;\n      } else {\n        if (count <= 1) {\n          delete this._disabled[type];\n        } else {\n          --this._disabled[type];\n        }\n\n        return false;\n      }\n    }\n  });\n  /**\r\n   * [_eachListener description]\r\n   *\r\n   * All of this extra code is needed when a listener is removed while iterating\r\n   *\r\n   * @todo Description\r\n   * @param fn [description]\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_eachListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (fn) {\n      var _this = this;\n\n      ++this._iterating;\n\n      try {\n        $array.each(this._listeners, fn);\n      } finally {\n        --this._iterating; // TODO should this be inside or outside the finally ?\n\n        if (this._iterating === 0 && this._killed.length !== 0) {\n          // Remove killed listeners\n          $array.each(this._killed, function (killed) {\n            _this._removeListener(killed);\n          });\n          this._killed.length = 0;\n        }\n      }\n    }\n  });\n  /**\r\n   * Dispatches an event immediately without waiting for next cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"dispatch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, event) {\n      if (this._shouldDispatch(type)) {\n        // TODO check if it's faster to use an object of listeners rather than a single big array\n        // TODO if the function throws, maybe it should keep going ?\n        this._eachListener(function (listener) {\n          if (!listener.killed && (listener.type === null || listener.type === type)) {\n            listener.dispatch(type, event);\n          }\n        });\n      }\n    }\n  });\n  /**\r\n   * Shelves the event to be dispatched within next update cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n      if (this._shouldDispatch(type)) {\r\n          this._eachListener((listener) => {\r\n              // TODO check if it's faster to use an object of listeners rather than a single big array\r\n              if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                  // TODO if the function throws, maybe it should keep going ?\r\n                  // TODO dispatch during the update cycle, rather than using whenIdle\r\n                  $async.whenIdle(() => {\r\n                      if (!listener.killed) {\r\n                          listener.dispatch(type, event);\r\n                      }\r\n                  });\r\n              }\r\n          });\r\n      }\r\n  }*/\n\n  /**\r\n   * Creates, catalogs and returns an [[EventListener]].\r\n   *\r\n   * Event listener can be disposed.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @param dispatch\r\n   * @returns An event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_on\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (once, type, callback, context, shouldClone, dispatch) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._removeExistingListener(once, type, callback, context);\n\n      var info = {\n        type: type,\n        callback: callback,\n        context: context,\n        shouldClone: shouldClone,\n        dispatch: dispatch,\n        killed: false,\n        once: once,\n        disposer: new Disposer(function () {\n          info.killed = true;\n\n          _this._removeListener(info);\n        })\n      };\n\n      this._listeners.push(info);\n\n      return info;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on **any** event.\r\n   *\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"onAll\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      return this._on(false, null, callback, context, shouldClone, function (_type, event) {\n        return callback.call(context, event);\n      }).disposer;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on a specific event type.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler whenever series we put\r\n   * event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"on\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      return this._on(false, type, callback, context, shouldClone, function (_type, event) {\n        return callback.call(context, event);\n      }).disposer;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on a specific event type once.\r\n   *\r\n   * Once the event listener is invoked, it is automatically disposed.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler the first time series we\r\n   * put event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"once\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      var x = this._on(true, type, callback, context, shouldClone, function (_type, event) {\n        x.disposer.dispose();\n        callback.call(context, event);\n      }); // TODO maybe this should return a different Disposer ?\n\n\n      return x.disposer;\n    }\n  });\n  /**\r\n   * Removes the event listener with specific parameters.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"off\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context) {\n      this._removeExistingListener(false, type, callback, context);\n    }\n  });\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"copyFrom\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (source) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      if (source === this) {\n        throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n      }\n\n      var disposers = [];\n      $array.each(source._listeners, function (x) {\n        // TODO is this correct ?\n        if (!x.killed && x.shouldClone) {\n          if (x.type === null) {\n            disposers.push(_this.onAll(x.callback, x.context));\n          } else if (x.once) {\n            disposers.push(_this.once(x.type, x.callback, x.context));\n          } else {\n            disposers.push(_this.on(x.type, x.callback, x.context));\n          }\n        }\n      });\n      return new MultiDisposer(disposers);\n    }\n  });\n  return EventDispatcher;\n}();\n\nexport { EventDispatcher };\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @ignore\r\n */\n\nvar TargetedEventDispatcher =\n/** @class */\nfunction (_super) {\n  __extends(TargetedEventDispatcher, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param target Event dispatcher target\r\n   */\n\n\n  function TargetedEventDispatcher(target) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A target object which is originating events using this dispatcher.\r\n     */\n\n\n    Object.defineProperty(_this, \"target\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    _this.target = target;\n    return _this;\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n\n\n  Object.defineProperty(TargetedEventDispatcher.prototype, \"copyFrom\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (source) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      if (source === this) {\n        throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n      }\n\n      var disposers = [];\n      $array.each(source._listeners, function (x) {\n        // TODO very hacky\n        if (x.context === source.target) {\n          return;\n        } // TODO is this correct ?\n\n\n        if (!x.killed && x.shouldClone) {\n          if (x.type === null) {\n            disposers.push(_this.onAll(x.callback, x.context));\n          } else if (x.once) {\n            disposers.push(_this.once(x.type, x.callback, x.context));\n          } else {\n            disposers.push(_this.on(x.type, x.callback, x.context));\n          }\n        }\n      });\n      return new MultiDisposer(disposers);\n    }\n  });\n  return TargetedEventDispatcher;\n}(EventDispatcher);\n\nexport { TargetedEventDispatcher };","map":{"version":3,"sources":["/home/thiru/Desktop/Thiru/acquistion/Acquisition-Front/node_modules/@amcharts/amcharts5/.internal/core/util/EventDispatcher.js"],"names":["__extends","Disposer","MultiDisposer","$array","$type","EventDispatcher","Object","defineProperty","enumerable","configurable","writable","value","_listeners","_killed","_disabled","_iterating","_enabled","_disposed","prototype","a","each","x","disposer","dispose","length","type","any","killed","amount","Infinity","listener","index","indexOf","Error","splice","push","once","callback","context","_eachListener","info","undefined","hasListenersByType","findIndex","count","isNumber","fn","_this","_removeListener","event","_shouldDispatch","dispatch","shouldClone","_removeExistingListener","_on","_type","call","source","disposers","onAll","on","TargetedEventDispatcher","_super","target"],"mappings":"AAAA;AACA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,OAA1B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASC,QAAT,EAAmBC,aAAnB,QAAwC,YAAxC;AACA,OAAO,KAAKC,MAAZ,MAAwB,SAAxB;AACA,OAAO,KAAKC,KAAZ,MAAuB,QAAvB;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,eAAe;AAAG;AAAe,YAAY;AAC7C;AACJ;AACA;AACI,WAASA,eAAT,GAA2B;AACvBC,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;AACtCC,MAAAA,UAAU,EAAE,IAD0B;AAEtCC,MAAAA,YAAY,EAAE,IAFwB;AAGtCC,MAAAA,QAAQ,EAAE,IAH4B;AAItCC,MAAAA,KAAK,EAAE,KAAK;AAJ0B,KAA1C;AAMAL,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACnCC,MAAAA,UAAU,EAAE,IADuB;AAEnCC,MAAAA,YAAY,EAAE,IAFqB;AAGnCC,MAAAA,QAAQ,EAAE,IAHyB;AAInCC,MAAAA,KAAK,EAAE,KAAK;AAJuB,KAAvC;AAMAL,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;AACrCC,MAAAA,UAAU,EAAE,IADyB;AAErCC,MAAAA,YAAY,EAAE,IAFuB;AAGrCC,MAAAA,QAAQ,EAAE,IAH2B;AAIrCC,MAAAA,KAAK,EAAE,KAAK;AAJyB,KAAzC;AAMAL,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;AACtCC,MAAAA,UAAU,EAAE,IAD0B;AAEtCC,MAAAA,YAAY,EAAE,IAFwB;AAGtCC,MAAAA,QAAQ,EAAE,IAH4B;AAItCC,MAAAA,KAAK,EAAE,KAAK;AAJ0B,KAA1C;AAMAL,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,UAA5B,EAAwC;AACpCC,MAAAA,UAAU,EAAE,IADwB;AAEpCC,MAAAA,YAAY,EAAE,IAFsB;AAGpCC,MAAAA,QAAQ,EAAE,IAH0B;AAIpCC,MAAAA,KAAK,EAAE,KAAK;AAJwB,KAAxC;AAMAL,IAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;AACrCC,MAAAA,UAAU,EAAE,IADyB;AAErCC,MAAAA,YAAY,EAAE,IAFuB;AAGrCC,MAAAA,QAAQ,EAAE,IAH2B;AAIrCC,MAAAA,KAAK,EAAE,KAAK;AAJyB,KAAzC;AAMA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACH;AACD;AACJ;AACA;AACA;AACA;;;AACIX,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,YAAjD,EAA+D;AAC3DV,IAAAA,UAAU,EAAE,KAD+C;AAE3DC,IAAAA,YAAY,EAAE,IAF6C;AAG3DC,IAAAA,QAAQ,EAAE,IAHiD;AAI3DC,IAAAA,KAAK,EAAE,YAAY;AACf,aAAO,KAAKM,SAAZ;AACH;AAN0D,GAA/D;AAQA;AACJ;AACA;;AACIX,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,SAAjD,EAA4D;AACxDV,IAAAA,UAAU,EAAE,KAD4C;AAExDC,IAAAA,YAAY,EAAE,IAF0C;AAGxDC,IAAAA,QAAQ,EAAE,IAH8C;AAIxDC,IAAAA,KAAK,EAAE,YAAY;AACf,UAAI,CAAC,KAAKM,SAAV,EAAqB;AACjB,aAAKA,SAAL,GAAiB,IAAjB;AACA,YAAIE,CAAC,GAAG,KAAKP,UAAb;AACA,aAAKG,UAAL,GAAkB,CAAlB;AACA,aAAKH,UAAL,GAAkB,IAAlB;AACA,aAAKE,SAAL,GAAiB,IAAjB;;AACA,YAAI;AACAX,UAAAA,MAAM,CAACiB,IAAP,CAAYD,CAAZ,EAAe,UAAUE,CAAV,EAAa;AACxBA,YAAAA,CAAC,CAACC,QAAF,CAAWC,OAAX;AACH,WAFD;AAGH,SAJD,SAKQ;AACJ,eAAKV,OAAL,GAAe,IAAf;AACA,eAAKE,UAAL,GAAkB,IAAlB;AACH;AACJ;AACJ;AArBuD,GAA5D;AAuBA;AACJ;AACA;AACA;AACA;;AACIT,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,cAAjD,EAAiE;AAC7DV,IAAAA,UAAU,EAAE,KADiD;AAE7DC,IAAAA,YAAY,EAAE,IAF+C;AAG7DC,IAAAA,QAAQ,EAAE,IAHmD;AAI7DC,IAAAA,KAAK,EAAE,YAAY;AACf,aAAO,KAAKC,UAAL,CAAgBY,MAAhB,KAA2B,CAAlC;AACH;AAN4D,GAAjE;AAQA;AACJ;AACA;AACA;AACA;;AACIlB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,oBAAjD,EAAuE;AACnEV,IAAAA,UAAU,EAAE,KADuD;AAEnEC,IAAAA,YAAY,EAAE,IAFqD;AAGnEC,IAAAA,QAAQ,EAAE,IAHyD;AAInEC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgB;AACnB,aAAOtB,MAAM,CAACuB,GAAP,CAAW,KAAKd,UAAhB,EAA4B,UAAUS,CAAV,EAAa;AAAE,eAAO,CAACA,CAAC,CAACI,IAAF,KAAW,IAAX,IAAmBJ,CAAC,CAACI,IAAF,KAAWA,IAA/B,KAAwC,CAACJ,CAAC,CAACM,MAAlD;AAA2D,OAAtG,CAAP;AACH;AANkE,GAAvE;AAQA;AACJ;AACA;AACA;;AACIrB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,QAAjD,EAA2D;AACvDV,IAAAA,UAAU,EAAE,KAD2C;AAEvDC,IAAAA,YAAY,EAAE,IAFyC;AAGvDC,IAAAA,QAAQ,EAAE,IAH6C;AAIvDC,IAAAA,KAAK,EAAE,YAAY;AACf,WAAKK,QAAL,GAAgB,IAAhB;AACH;AANsD,GAA3D;AAQA;AACJ;AACA;;AACIV,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,SAAjD,EAA4D;AACxDV,IAAAA,UAAU,EAAE,KAD4C;AAExDC,IAAAA,YAAY,EAAE,IAF0C;AAGxDC,IAAAA,QAAQ,EAAE,IAH8C;AAIxDC,IAAAA,KAAK,EAAE,YAAY;AACf,WAAKK,QAAL,GAAgB,KAAhB;AACH;AANuD,GAA5D;AAQA;AACJ;AACA;AACA;AACA;AACA;;AACIV,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,YAAjD,EAA+D;AAC3DV,IAAAA,UAAU,EAAE,KAD+C;AAE3DC,IAAAA,YAAY,EAAE,IAF6C;AAG3DC,IAAAA,QAAQ,EAAE,IAHiD;AAI3DC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgB;AACnB,aAAO,KAAKX,SAAL,CAAeW,IAAf,CAAP;AACH;AAN0D,GAA/D;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACInB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,aAAjD,EAAgE;AAC5DV,IAAAA,UAAU,EAAE,KADgD;AAE5DC,IAAAA,YAAY,EAAE,IAF8C;AAG5DC,IAAAA,QAAQ,EAAE,IAHkD;AAI5DC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgBG,MAAhB,EAAwB;AAC3B,UAAIA,MAAM,KAAK,KAAK,CAApB,EAAuB;AAAEA,QAAAA,MAAM,GAAGC,QAAT;AAAoB;;AAC7C,WAAKf,SAAL,CAAeW,IAAf,IAAuBG,MAAvB;AACH;AAP2D,GAAhE;AASA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACItB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,iBAAjD,EAAoE;AAChEV,IAAAA,UAAU,EAAE,KADoD;AAEhEC,IAAAA,YAAY,EAAE,IAFkD;AAGhEC,IAAAA,QAAQ,EAAE,IAHsD;AAIhEC,IAAAA,KAAK,EAAE,UAAUmB,QAAV,EAAoB;AACvB,UAAI,KAAKf,UAAL,KAAoB,CAAxB,EAA2B;AACvB,YAAIgB,KAAK,GAAG,KAAKnB,UAAL,CAAgBoB,OAAhB,CAAwBF,QAAxB,CAAZ;;AACA,YAAIC,KAAK,KAAK,CAAC,CAAf,EAAkB;AACd,gBAAM,IAAIE,KAAJ,CAAU,0CAAV,CAAN;AACH;;AACD,aAAKrB,UAAL,CAAgBsB,MAAhB,CAAuBH,KAAvB,EAA8B,CAA9B;AACH,OAND,MAOK;AACD,aAAKlB,OAAL,CAAasB,IAAb,CAAkBL,QAAlB;AACH;AACJ;AAf+D,GAApE;AAiBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIxB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,yBAAjD,EAA4E;AACxEV,IAAAA,UAAU,EAAE,KAD4D;AAExEC,IAAAA,YAAY,EAAE,IAF0D;AAGxEC,IAAAA,QAAQ,EAAE,IAH8D;AAIxEC,IAAAA,KAAK,EAAE,UAAUyB,IAAV,EAAgBX,IAAhB,EAAsBY,QAAtB,EAAgCC,OAAhC,EAAyC;AAC5C,UAAI,KAAKrB,SAAT,EAAoB;AAChB,cAAM,IAAIgB,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACD,WAAKM,aAAL,CAAmB,UAAUC,IAAV,EAAgB;AAC/B,YAAIA,IAAI,CAACJ,IAAL,KAAcA,IAAd,IAAsB;AACtBI,QAAAA,IAAI,CAACf,IAAL,KAAcA,IADd,KAECY,QAAQ,KAAKI,SAAb,IAA0BD,IAAI,CAACH,QAAL,KAAkBA,QAF7C,KAGAG,IAAI,CAACF,OAAL,KAAiBA,OAHrB,EAG8B;AAC1BE,UAAAA,IAAI,CAAClB,QAAL,CAAcC,OAAd;AACH;AACJ,OAPD;AAQH;AAhBuE,GAA5E;AAkBA;AACJ;AACA;AACA;AACA;AACA;;AACIjB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,WAAjD,EAA8D;AAC1DV,IAAAA,UAAU,EAAE,KAD8C;AAE1DC,IAAAA,YAAY,EAAE,IAF4C;AAG1DC,IAAAA,QAAQ,EAAE,IAHgD;AAI1DC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgB;AACnB,UAAI,KAAKR,SAAT,EAAoB;AAChB,cAAM,IAAIgB,KAAJ,CAAU,6BAAV,CAAN;AACH,OAHkB,CAInB;;;AACA,aAAO,KAAKjB,QAAL,IAAiB,KAAKJ,UAAL,CAAgBY,MAAhB,GAAyB,CAA1C,IAA+C,KAAKkB,kBAAL,CAAwBjB,IAAxB,CAA/C,IAAgF,KAAKX,SAAL,CAAeW,IAAf,MAAyBgB,SAAhH;AACH;AAVyD,GAA9D;AAYA;AACJ;AACA;AACA;AACA;;AACInC,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,YAAjD,EAA+D;AAC3DV,IAAAA,UAAU,EAAE,KAD+C;AAE3DC,IAAAA,YAAY,EAAE,IAF6C;AAG3DC,IAAAA,QAAQ,EAAE,IAHiD;AAI3DC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgB;AACnB,UAAI,KAAKR,SAAT,EAAoB;AAChB,cAAM,IAAIgB,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACD,WAAKM,aAAL,CAAmB,UAAUC,IAAV,EAAgB;AAC/B,YAAIA,IAAI,CAACf,IAAL,KAAcA,IAAlB,EAAwB;AACpBe,UAAAA,IAAI,CAAClB,QAAL,CAAcC,OAAd;AACH;AACJ,OAJD;AAKH;AAb0D,GAA/D;AAeA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIjB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,KAAjD,EAAwD;AACpDV,IAAAA,UAAU,EAAE,KADwC;AAEpDC,IAAAA,YAAY,EAAE,IAFsC;AAGpDC,IAAAA,QAAQ,EAAE,IAH0C;AAIpDC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgBY,QAAhB,EAA0BC,OAA1B,EAAmC;AACtC,UAAIP,KAAK,GAAG5B,MAAM,CAACwC,SAAP,CAAiB,KAAK/B,UAAtB,EAAkC,UAAU4B,IAAV,EAAgB;AAC1D,eAAOA,IAAI,CAACJ,IAAL,KAAc,IAAd,IAAsB;AACzBI,QAAAA,IAAI,CAACf,IAAL,KAAcA,IADX,KAEFY,QAAQ,KAAKI,SAAb,IAA0BD,IAAI,CAACH,QAAL,KAAkBA,QAF1C,KAGHG,IAAI,CAACF,OAAL,KAAiBA,OAHrB;AAIH,OALW,CAAZ;AAMA,aAAOP,KAAK,KAAK,CAAC,CAAlB;AACH;AAZmD,GAAxD;AAcA;AACJ;AACA;AACA;AACA;AACA;;AACIzB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,iBAAjD,EAAoE;AAChEV,IAAAA,UAAU,EAAE,KADoD;AAEhEC,IAAAA,YAAY,EAAE,IAFkD;AAGhEC,IAAAA,QAAQ,EAAE,IAHsD;AAIhEC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgB;AACnB,UAAI,KAAKR,SAAT,EAAoB;AAChB,cAAM,IAAIgB,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACD,UAAIW,KAAK,GAAG,KAAK9B,SAAL,CAAeW,IAAf,CAAZ;;AACA,UAAI,CAACrB,KAAK,CAACyC,QAAN,CAAeD,KAAf,CAAL,EAA4B;AACxB,eAAO,KAAK5B,QAAZ;AACH,OAFD,MAGK;AACD,YAAI4B,KAAK,IAAI,CAAb,EAAgB;AACZ,iBAAO,KAAK9B,SAAL,CAAeW,IAAf,CAAP;AACH,SAFD,MAGK;AACD,YAAE,KAAKX,SAAL,CAAeW,IAAf,CAAF;AACH;;AACD,eAAO,KAAP;AACH;AACJ;AArB+D,GAApE;AAuBA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACInB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,eAAjD,EAAkE;AAC9DV,IAAAA,UAAU,EAAE,KADkD;AAE9DC,IAAAA,YAAY,EAAE,IAFgD;AAG9DC,IAAAA,QAAQ,EAAE,IAHoD;AAI9DC,IAAAA,KAAK,EAAE,UAAUmC,EAAV,EAAc;AACjB,UAAIC,KAAK,GAAG,IAAZ;;AACA,QAAE,KAAKhC,UAAP;;AACA,UAAI;AACAZ,QAAAA,MAAM,CAACiB,IAAP,CAAY,KAAKR,UAAjB,EAA6BkC,EAA7B;AACH,OAFD,SAGQ;AACJ,UAAE,KAAK/B,UAAP,CADI,CAEJ;;AACA,YAAI,KAAKA,UAAL,KAAoB,CAApB,IAAyB,KAAKF,OAAL,CAAaW,MAAb,KAAwB,CAArD,EAAwD;AACpD;AACArB,UAAAA,MAAM,CAACiB,IAAP,CAAY,KAAKP,OAAjB,EAA0B,UAAUc,MAAV,EAAkB;AACxCoB,YAAAA,KAAK,CAACC,eAAN,CAAsBrB,MAAtB;AACH,WAFD;AAGA,eAAKd,OAAL,CAAaW,MAAb,GAAsB,CAAtB;AACH;AACJ;AACJ;AArB6D,GAAlE;AAuBA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIlB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,UAAjD,EAA6D;AACzDV,IAAAA,UAAU,EAAE,KAD6C;AAEzDC,IAAAA,YAAY,EAAE,IAF2C;AAGzDC,IAAAA,QAAQ,EAAE,IAH+C;AAIzDC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgBwB,KAAhB,EAAuB;AAC1B,UAAI,KAAKC,eAAL,CAAqBzB,IAArB,CAAJ,EAAgC;AAC5B;AACA;AACA,aAAKc,aAAL,CAAmB,UAAUT,QAAV,EAAoB;AACnC,cAAI,CAACA,QAAQ,CAACH,MAAV,KAAqBG,QAAQ,CAACL,IAAT,KAAkB,IAAlB,IAA0BK,QAAQ,CAACL,IAAT,KAAkBA,IAAjE,CAAJ,EAA4E;AACxEK,YAAAA,QAAQ,CAACqB,QAAT,CAAkB1B,IAAlB,EAAwBwB,KAAxB;AACH;AACJ,SAJD;AAKH;AACJ;AAdwD,GAA7D;AAgBA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI3C,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,KAAjD,EAAwD;AACpDV,IAAAA,UAAU,EAAE,KADwC;AAEpDC,IAAAA,YAAY,EAAE,IAFsC;AAGpDC,IAAAA,QAAQ,EAAE,IAH0C;AAIpDC,IAAAA,KAAK,EAAE,UAAUyB,IAAV,EAAgBX,IAAhB,EAAsBY,QAAtB,EAAgCC,OAAhC,EAAyCc,WAAzC,EAAsDD,QAAtD,EAAgE;AACnE,UAAIJ,KAAK,GAAG,IAAZ;;AACA,UAAI,KAAK9B,SAAT,EAAoB;AAChB,cAAM,IAAIgB,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACD,WAAKoB,uBAAL,CAA6BjB,IAA7B,EAAmCX,IAAnC,EAAyCY,QAAzC,EAAmDC,OAAnD;;AACA,UAAIE,IAAI,GAAG;AACPf,QAAAA,IAAI,EAAEA,IADC;AAEPY,QAAAA,QAAQ,EAAEA,QAFH;AAGPC,QAAAA,OAAO,EAAEA,OAHF;AAIPc,QAAAA,WAAW,EAAEA,WAJN;AAKPD,QAAAA,QAAQ,EAAEA,QALH;AAMPxB,QAAAA,MAAM,EAAE,KAND;AAOPS,QAAAA,IAAI,EAAEA,IAPC;AAQPd,QAAAA,QAAQ,EAAE,IAAIrB,QAAJ,CAAa,YAAY;AAC/BuC,UAAAA,IAAI,CAACb,MAAL,GAAc,IAAd;;AACAoB,UAAAA,KAAK,CAACC,eAAN,CAAsBR,IAAtB;AACH,SAHS;AARH,OAAX;;AAaA,WAAK5B,UAAL,CAAgBuB,IAAhB,CAAqBK,IAArB;;AACA,aAAOA,IAAP;AACH;AAzBmD,GAAxD;AA2BA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AACIlC,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,OAAjD,EAA0D;AACtDV,IAAAA,UAAU,EAAE,KAD0C;AAEtDC,IAAAA,YAAY,EAAE,IAFwC;AAGtDC,IAAAA,QAAQ,EAAE,IAH4C;AAItDC,IAAAA,KAAK,EAAE,UAAU0B,QAAV,EAAoBC,OAApB,EAA6Bc,WAA7B,EAA0C;AAC7C,UAAIA,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAAEA,QAAAA,WAAW,GAAG,IAAd;AAAqB;;AACnD,aAAO,KAAKE,GAAL,CAAS,KAAT,EAAgB,IAAhB,EAAsBjB,QAAtB,EAAgCC,OAAhC,EAAyCc,WAAzC,EAAsD,UAAUG,KAAV,EAAiBN,KAAjB,EAAwB;AAAE,eAAOZ,QAAQ,CAACmB,IAAT,CAAclB,OAAd,EAAuBW,KAAvB,CAAP;AAAuC,OAAvH,EAAyH3B,QAAhI;AACH;AAPqD,GAA1D;AASA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACIhB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,IAAjD,EAAuD;AACnDV,IAAAA,UAAU,EAAE,KADuC;AAEnDC,IAAAA,YAAY,EAAE,IAFqC;AAGnDC,IAAAA,QAAQ,EAAE,IAHyC;AAInDC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgBY,QAAhB,EAA0BC,OAA1B,EAAmCc,WAAnC,EAAgD;AACnD,UAAIA,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAAEA,QAAAA,WAAW,GAAG,IAAd;AAAqB;;AACnD,aAAO,KAAKE,GAAL,CAAS,KAAT,EAAgB7B,IAAhB,EAAsBY,QAAtB,EAAgCC,OAAhC,EAAyCc,WAAzC,EAAsD,UAAUG,KAAV,EAAiBN,KAAjB,EAAwB;AAAE,eAAOZ,QAAQ,CAACmB,IAAT,CAAclB,OAAd,EAAuBW,KAAvB,CAAP;AAAuC,OAAvH,EAAyH3B,QAAhI;AACH;AAPkD,GAAvD;AASA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACIhB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,MAAjD,EAAyD;AACrDV,IAAAA,UAAU,EAAE,KADyC;AAErDC,IAAAA,YAAY,EAAE,IAFuC;AAGrDC,IAAAA,QAAQ,EAAE,IAH2C;AAIrDC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgBY,QAAhB,EAA0BC,OAA1B,EAAmCc,WAAnC,EAAgD;AACnD,UAAIA,WAAW,KAAK,KAAK,CAAzB,EAA4B;AAAEA,QAAAA,WAAW,GAAG,IAAd;AAAqB;;AACnD,UAAI/B,CAAC,GAAG,KAAKiC,GAAL,CAAS,IAAT,EAAe7B,IAAf,EAAqBY,QAArB,EAA+BC,OAA/B,EAAwCc,WAAxC,EAAqD,UAAUG,KAAV,EAAiBN,KAAjB,EAAwB;AACjF5B,QAAAA,CAAC,CAACC,QAAF,CAAWC,OAAX;AACAc,QAAAA,QAAQ,CAACmB,IAAT,CAAclB,OAAd,EAAuBW,KAAvB;AACH,OAHO,CAAR,CAFmD,CAMnD;;;AACA,aAAO5B,CAAC,CAACC,QAAT;AACH;AAZoD,GAAzD;AAcA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIhB,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,KAAjD,EAAwD;AACpDV,IAAAA,UAAU,EAAE,KADwC;AAEpDC,IAAAA,YAAY,EAAE,IAFsC;AAGpDC,IAAAA,QAAQ,EAAE,IAH0C;AAIpDC,IAAAA,KAAK,EAAE,UAAUc,IAAV,EAAgBY,QAAhB,EAA0BC,OAA1B,EAAmC;AACtC,WAAKe,uBAAL,CAA6B,KAA7B,EAAoC5B,IAApC,EAA0CY,QAA1C,EAAoDC,OAApD;AACH;AANmD,GAAxD;AAQA;AACJ;AACA;AACA;AACA;AACA;AACA;;AACIhC,EAAAA,MAAM,CAACC,cAAP,CAAsBF,eAAe,CAACa,SAAtC,EAAiD,UAAjD,EAA6D;AACzDV,IAAAA,UAAU,EAAE,KAD6C;AAEzDC,IAAAA,YAAY,EAAE,IAF2C;AAGzDC,IAAAA,QAAQ,EAAE,IAH+C;AAIzDC,IAAAA,KAAK,EAAE,UAAU8C,MAAV,EAAkB;AACrB,UAAIV,KAAK,GAAG,IAAZ;;AACA,UAAI,KAAK9B,SAAT,EAAoB;AAChB,cAAM,IAAIgB,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACD,UAAIwB,MAAM,KAAK,IAAf,EAAqB;AACjB,cAAM,IAAIxB,KAAJ,CAAU,kDAAV,CAAN;AACH;;AACD,UAAIyB,SAAS,GAAG,EAAhB;AACAvD,MAAAA,MAAM,CAACiB,IAAP,CAAYqC,MAAM,CAAC7C,UAAnB,EAA+B,UAAUS,CAAV,EAAa;AACxC;AACA,YAAI,CAACA,CAAC,CAACM,MAAH,IAAaN,CAAC,CAAC+B,WAAnB,EAAgC;AAC5B,cAAI/B,CAAC,CAACI,IAAF,KAAW,IAAf,EAAqB;AACjBiC,YAAAA,SAAS,CAACvB,IAAV,CAAeY,KAAK,CAACY,KAAN,CAAYtC,CAAC,CAACgB,QAAd,EAAwBhB,CAAC,CAACiB,OAA1B,CAAf;AACH,WAFD,MAGK,IAAIjB,CAAC,CAACe,IAAN,EAAY;AACbsB,YAAAA,SAAS,CAACvB,IAAV,CAAeY,KAAK,CAACX,IAAN,CAAWf,CAAC,CAACI,IAAb,EAAmBJ,CAAC,CAACgB,QAArB,EAA+BhB,CAAC,CAACiB,OAAjC,CAAf;AACH,WAFI,MAGA;AACDoB,YAAAA,SAAS,CAACvB,IAAV,CAAeY,KAAK,CAACa,EAAN,CAASvC,CAAC,CAACI,IAAX,EAAiBJ,CAAC,CAACgB,QAAnB,EAA6BhB,CAAC,CAACiB,OAA/B,CAAf;AACH;AACJ;AACJ,OAbD;AAcA,aAAO,IAAIpC,aAAJ,CAAkBwD,SAAlB,CAAP;AACH;AA5BwD,GAA7D;AA8BA,SAAOrD,eAAP;AACH,CArjBoC,EAArC;;AAsjBA,SAASA,eAAT;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIwD,uBAAuB;AAAG;AAAe,UAAUC,MAAV,EAAkB;AAC3D9D,EAAAA,SAAS,CAAC6D,uBAAD,EAA0BC,MAA1B,CAAT;AACA;AACJ;AACA;AACA;AACA;;;AACI,WAASD,uBAAT,CAAiCE,MAAjC,EAAyC;AACrC,QAAIhB,KAAK,GAAGe,MAAM,CAACN,IAAP,CAAY,IAAZ,KAAqB,IAAjC;AACA;AACR;AACA;;;AACQlD,IAAAA,MAAM,CAACC,cAAP,CAAsBwC,KAAtB,EAA6B,QAA7B,EAAuC;AACnCvC,MAAAA,UAAU,EAAE,IADuB;AAEnCC,MAAAA,YAAY,EAAE,IAFqB;AAGnCC,MAAAA,QAAQ,EAAE,IAHyB;AAInCC,MAAAA,KAAK,EAAE,KAAK;AAJuB,KAAvC;AAMAoC,IAAAA,KAAK,CAACgB,MAAN,GAAeA,MAAf;AACA,WAAOhB,KAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;;;AACIzC,EAAAA,MAAM,CAACC,cAAP,CAAsBsD,uBAAuB,CAAC3C,SAA9C,EAAyD,UAAzD,EAAqE;AACjEV,IAAAA,UAAU,EAAE,KADqD;AAEjEC,IAAAA,YAAY,EAAE,IAFmD;AAGjEC,IAAAA,QAAQ,EAAE,IAHuD;AAIjEC,IAAAA,KAAK,EAAE,UAAU8C,MAAV,EAAkB;AACrB,UAAIV,KAAK,GAAG,IAAZ;;AACA,UAAI,KAAK9B,SAAT,EAAoB;AAChB,cAAM,IAAIgB,KAAJ,CAAU,6BAAV,CAAN;AACH;;AACD,UAAIwB,MAAM,KAAK,IAAf,EAAqB;AACjB,cAAM,IAAIxB,KAAJ,CAAU,kDAAV,CAAN;AACH;;AACD,UAAIyB,SAAS,GAAG,EAAhB;AACAvD,MAAAA,MAAM,CAACiB,IAAP,CAAYqC,MAAM,CAAC7C,UAAnB,EAA+B,UAAUS,CAAV,EAAa;AACxC;AACA,YAAIA,CAAC,CAACiB,OAAF,KAAcmB,MAAM,CAACM,MAAzB,EAAiC;AAC7B;AACH,SAJuC,CAKxC;;;AACA,YAAI,CAAC1C,CAAC,CAACM,MAAH,IAAaN,CAAC,CAAC+B,WAAnB,EAAgC;AAC5B,cAAI/B,CAAC,CAACI,IAAF,KAAW,IAAf,EAAqB;AACjBiC,YAAAA,SAAS,CAACvB,IAAV,CAAeY,KAAK,CAACY,KAAN,CAAYtC,CAAC,CAACgB,QAAd,EAAwBhB,CAAC,CAACiB,OAA1B,CAAf;AACH,WAFD,MAGK,IAAIjB,CAAC,CAACe,IAAN,EAAY;AACbsB,YAAAA,SAAS,CAACvB,IAAV,CAAeY,KAAK,CAACX,IAAN,CAAWf,CAAC,CAACI,IAAb,EAAmBJ,CAAC,CAACgB,QAArB,EAA+BhB,CAAC,CAACiB,OAAjC,CAAf;AACH,WAFI,MAGA;AACDoB,YAAAA,SAAS,CAACvB,IAAV,CAAeY,KAAK,CAACa,EAAN,CAASvC,CAAC,CAACI,IAAX,EAAiBJ,CAAC,CAACgB,QAAnB,EAA6BhB,CAAC,CAACiB,OAA/B,CAAf;AACH;AACJ;AACJ,OAjBD;AAkBA,aAAO,IAAIpC,aAAJ,CAAkBwD,SAAlB,CAAP;AACH;AAhCgE,GAArE;AAkCA,SAAOG,uBAAP;AACH,CA/D4C,CA+D3CxD,eA/D2C,CAA7C;;AAgEA,SAASwD,uBAAT","sourcesContent":["/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\r\nimport { __extends } from \"tslib\";\r\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\r\nimport { Disposer, MultiDisposer } from \"./Disposer\";\r\nimport * as $array from \"./Array\";\r\nimport * as $type from \"./Type\";\r\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n */\r\nvar EventDispatcher = /** @class */ (function () {\r\n    /**\r\n     * Constructor\r\n     */\r\n    function EventDispatcher() {\r\n        Object.defineProperty(this, \"_listeners\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"_killed\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"_disabled\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"_iterating\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"_enabled\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        Object.defineProperty(this, \"_disposed\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        this._listeners = [];\r\n        this._killed = [];\r\n        this._disabled = {};\r\n        this._iterating = 0;\r\n        this._enabled = true;\r\n        this._disposed = false;\r\n    }\r\n    /**\r\n     * Returns if this object has been already disposed.\r\n     *\r\n     * @return Disposed?\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"isDisposed\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            return this._disposed;\r\n        }\r\n    });\r\n    /**\r\n     * Dispose (destroy) this object.\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"dispose\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            if (!this._disposed) {\r\n                this._disposed = true;\r\n                var a = this._listeners;\r\n                this._iterating = 1;\r\n                this._listeners = null;\r\n                this._disabled = null;\r\n                try {\r\n                    $array.each(a, function (x) {\r\n                        x.disposer.dispose();\r\n                    });\r\n                }\r\n                finally {\r\n                    this._killed = null;\r\n                    this._iterating = null;\r\n                }\r\n            }\r\n        }\r\n    });\r\n    /**\r\n     * Checks if this particular event dispatcher has any listeners set.\r\n     *\r\n     * @return Has listeners?\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"hasListeners\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            return this._listeners.length !== 0;\r\n        }\r\n    });\r\n    /**\r\n     * Checks if this particular event dispatcher has any particular listeners set.\r\n     *\r\n     * @return Has particular event listeners?\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"hasListenersByType\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type) {\r\n            return $array.any(this._listeners, function (x) { return (x.type === null || x.type === type) && !x.killed; });\r\n        }\r\n    });\r\n    /**\r\n     * Enable dispatching of events if they were previously disabled by\r\n     * `disable()`.\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"enable\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            this._enabled = true;\r\n        }\r\n    });\r\n    /**\r\n     * Disable dispatching of events until re-enabled by `enable()`.\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"disable\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function () {\r\n            this._enabled = false;\r\n        }\r\n    });\r\n    /**\r\n     * Enable dispatching particular event, if it was disabled before by\r\n     * `disableType()`.\r\n     *\r\n     * @param type Event type\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"enableType\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type) {\r\n            delete this._disabled[type];\r\n        }\r\n    });\r\n    /**\r\n     * Disable dispatching of events for a certain event type.\r\n     *\r\n     * Optionally, can set how many dispatches to skip before automatically\r\n     * re-enabling the dispatching.\r\n     *\r\n     * @param type    Event type\r\n     * @param amount  Number of event dispatches to skip\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"disableType\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type, amount) {\r\n            if (amount === void 0) { amount = Infinity; }\r\n            this._disabled[type] = amount;\r\n        }\r\n    });\r\n    /**\r\n     * Removes listener from dispatcher.\r\n     *\r\n     * Will throw an exception if such listener does not exists.\r\n     *\r\n     * @param listener Listener to remove\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"_removeListener\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (listener) {\r\n            if (this._iterating === 0) {\r\n                var index = this._listeners.indexOf(listener);\r\n                if (index === -1) {\r\n                    throw new Error(\"Invalid state: could not remove listener\");\r\n                }\r\n                this._listeners.splice(index, 1);\r\n            }\r\n            else {\r\n                this._killed.push(listener);\r\n            }\r\n        }\r\n    });\r\n    /**\r\n     * Removes existing listener by certain parameters.\r\n     *\r\n     * @param once         Listener's once setting\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"_removeExistingListener\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (once, type, callback, context) {\r\n            if (this._disposed) {\r\n                throw new Error(\"EventDispatcher is disposed\");\r\n            }\r\n            this._eachListener(function (info) {\r\n                if (info.once === once && // TODO is this correct ?\r\n                    info.type === type &&\r\n                    (callback === undefined || info.callback === callback) &&\r\n                    info.context === context) {\r\n                    info.disposer.dispose();\r\n                }\r\n            });\r\n        }\r\n    });\r\n    /**\r\n     * Checks if dispatching for particular event type is enabled.\r\n     *\r\n     * @param type  Event type\r\n     * @return Enabled?\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"isEnabled\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type) {\r\n            if (this._disposed) {\r\n                throw new Error(\"EventDispatcher is disposed\");\r\n            }\r\n            // TODO is this check correct ?\r\n            return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\r\n        }\r\n    });\r\n    /**\r\n     * Removes all listeners of a particular event type\r\n     *\r\n     * @param type  Listener's type\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"removeType\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type) {\r\n            if (this._disposed) {\r\n                throw new Error(\"EventDispatcher is disposed\");\r\n            }\r\n            this._eachListener(function (info) {\r\n                if (info.type === type) {\r\n                    info.disposer.dispose();\r\n                }\r\n            });\r\n        }\r\n    });\r\n    /**\r\n     * Checks if there's already a listener with specific parameters.\r\n     *\r\n     * @param type      Listener's type\r\n     * @param callback  Callback function\r\n     * @param context   Callback context\r\n     * @return Has listener?\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"has\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type, callback, context) {\r\n            var index = $array.findIndex(this._listeners, function (info) {\r\n                return info.once !== true && // Ignoring \"once\" listeners\r\n                    info.type === type &&\r\n                    (callback === undefined || info.callback === callback) &&\r\n                    info.context === context;\r\n            });\r\n            return index !== -1;\r\n        }\r\n    });\r\n    /**\r\n     * Checks whether event of the particular type should be dispatched.\r\n     *\r\n     * @param type  Event type\r\n     * @return Dispatch?\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"_shouldDispatch\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type) {\r\n            if (this._disposed) {\r\n                throw new Error(\"EventDispatcher is disposed\");\r\n            }\r\n            var count = this._disabled[type];\r\n            if (!$type.isNumber(count)) {\r\n                return this._enabled;\r\n            }\r\n            else {\r\n                if (count <= 1) {\r\n                    delete this._disabled[type];\r\n                }\r\n                else {\r\n                    --this._disabled[type];\r\n                }\r\n                return false;\r\n            }\r\n        }\r\n    });\r\n    /**\r\n     * [_eachListener description]\r\n     *\r\n     * All of this extra code is needed when a listener is removed while iterating\r\n     *\r\n     * @todo Description\r\n     * @param fn [description]\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"_eachListener\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (fn) {\r\n            var _this = this;\r\n            ++this._iterating;\r\n            try {\r\n                $array.each(this._listeners, fn);\r\n            }\r\n            finally {\r\n                --this._iterating;\r\n                // TODO should this be inside or outside the finally ?\r\n                if (this._iterating === 0 && this._killed.length !== 0) {\r\n                    // Remove killed listeners\r\n                    $array.each(this._killed, function (killed) {\r\n                        _this._removeListener(killed);\r\n                    });\r\n                    this._killed.length = 0;\r\n                }\r\n            }\r\n        }\r\n    });\r\n    /**\r\n     * Dispatches an event immediately without waiting for next cycle.\r\n     *\r\n     * @param type   Event type\r\n     * @param event  Event object\r\n     * @todo automatically add in type and target properties if they are missing\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"dispatch\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type, event) {\r\n            if (this._shouldDispatch(type)) {\r\n                // TODO check if it's faster to use an object of listeners rather than a single big array\r\n                // TODO if the function throws, maybe it should keep going ?\r\n                this._eachListener(function (listener) {\r\n                    if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                        listener.dispatch(type, event);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    /**\r\n     * Shelves the event to be dispatched within next update cycle.\r\n     *\r\n     * @param type   Event type\r\n     * @param event  Event object\r\n     * @todo automatically add in type and target properties if they are missing\r\n     */\r\n    /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n        if (this._shouldDispatch(type)) {\r\n            this._eachListener((listener) => {\r\n                // TODO check if it's faster to use an object of listeners rather than a single big array\r\n                if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                    // TODO if the function throws, maybe it should keep going ?\r\n                    // TODO dispatch during the update cycle, rather than using whenIdle\r\n                    $async.whenIdle(() => {\r\n                        if (!listener.killed) {\r\n                            listener.dispatch(type, event);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        }\r\n    }*/\r\n    /**\r\n     * Creates, catalogs and returns an [[EventListener]].\r\n     *\r\n     * Event listener can be disposed.\r\n     *\r\n     * @param once         Listener's once setting\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n     * @param dispatch\r\n     * @returns An event listener\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"_on\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (once, type, callback, context, shouldClone, dispatch) {\r\n            var _this = this;\r\n            if (this._disposed) {\r\n                throw new Error(\"EventDispatcher is disposed\");\r\n            }\r\n            this._removeExistingListener(once, type, callback, context);\r\n            var info = {\r\n                type: type,\r\n                callback: callback,\r\n                context: context,\r\n                shouldClone: shouldClone,\r\n                dispatch: dispatch,\r\n                killed: false,\r\n                once: once,\r\n                disposer: new Disposer(function () {\r\n                    info.killed = true;\r\n                    _this._removeListener(info);\r\n                })\r\n            };\r\n            this._listeners.push(info);\r\n            return info;\r\n        }\r\n    });\r\n    /**\r\n     * Creates an event listener to be invoked on **any** event.\r\n     *\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n     * @returns A disposable event listener\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"onAll\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (callback, context, shouldClone) {\r\n            if (shouldClone === void 0) { shouldClone = true; }\r\n            return this._on(false, null, callback, context, shouldClone, function (_type, event) { return callback.call(context, event); }).disposer;\r\n        }\r\n    });\r\n    /**\r\n     * Creates an event listener to be invoked on a specific event type.\r\n     *\r\n     * ```TypeScript\r\n     * button.events.once(\"click\", (ev) => {\r\n     *   console.log(\"Button clicked\");\r\n     * }, this);\r\n     * ```\r\n     * ```JavaScript\r\n     * button.events.once(\"click\", (ev) => {\r\n     *   console.log(\"Button clicked\");\r\n     * }, this);\r\n     * ```\r\n     *\r\n     * The above will invoke our custom event handler whenever series we put\r\n     * event on is hidden.\r\n     *\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n     * @returns A disposable event listener\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"on\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type, callback, context, shouldClone) {\r\n            if (shouldClone === void 0) { shouldClone = true; }\r\n            return this._on(false, type, callback, context, shouldClone, function (_type, event) { return callback.call(context, event); }).disposer;\r\n        }\r\n    });\r\n    /**\r\n     * Creates an event listener to be invoked on a specific event type once.\r\n     *\r\n     * Once the event listener is invoked, it is automatically disposed.\r\n     *\r\n     * ```TypeScript\r\n     * button.events.once(\"click\", (ev) => {\r\n     *   console.log(\"Button clicked\");\r\n     * }, this);\r\n     * ```\r\n     * ```JavaScript\r\n     * button.events.once(\"click\", (ev) => {\r\n     *   console.log(\"Button clicked\");\r\n     * }, this);\r\n     * ```\r\n     *\r\n     * The above will invoke our custom event handler the first time series we\r\n     * put event on is hidden.\r\n     *\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n     * @returns A disposable event listener\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"once\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type, callback, context, shouldClone) {\r\n            if (shouldClone === void 0) { shouldClone = true; }\r\n            var x = this._on(true, type, callback, context, shouldClone, function (_type, event) {\r\n                x.disposer.dispose();\r\n                callback.call(context, event);\r\n            });\r\n            // TODO maybe this should return a different Disposer ?\r\n            return x.disposer;\r\n        }\r\n    });\r\n    /**\r\n     * Removes the event listener with specific parameters.\r\n     *\r\n     * @param type         Listener's type\r\n     * @param callback     Callback function\r\n     * @param context      Callback context\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"off\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (type, callback, context) {\r\n            this._removeExistingListener(false, type, callback, context);\r\n        }\r\n    });\r\n    /**\r\n     * Copies all dispatcher parameters, including listeners, from another event\r\n     * dispatcher.\r\n     *\r\n     * @param source Source event dispatcher\r\n     * @ignore\r\n     */\r\n    Object.defineProperty(EventDispatcher.prototype, \"copyFrom\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (source) {\r\n            var _this = this;\r\n            if (this._disposed) {\r\n                throw new Error(\"EventDispatcher is disposed\");\r\n            }\r\n            if (source === this) {\r\n                throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n            }\r\n            var disposers = [];\r\n            $array.each(source._listeners, function (x) {\r\n                // TODO is this correct ?\r\n                if (!x.killed && x.shouldClone) {\r\n                    if (x.type === null) {\r\n                        disposers.push(_this.onAll(x.callback, x.context));\r\n                    }\r\n                    else if (x.once) {\r\n                        disposers.push(_this.once(x.type, x.callback, x.context));\r\n                    }\r\n                    else {\r\n                        disposers.push(_this.on(x.type, x.callback, x.context));\r\n                    }\r\n                }\r\n            });\r\n            return new MultiDisposer(disposers);\r\n        }\r\n    });\r\n    return EventDispatcher;\r\n}());\r\nexport { EventDispatcher };\r\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @ignore\r\n */\r\nvar TargetedEventDispatcher = /** @class */ (function (_super) {\r\n    __extends(TargetedEventDispatcher, _super);\r\n    /**\r\n     * Constructor\r\n     *\r\n     * @param target Event dispatcher target\r\n     */\r\n    function TargetedEventDispatcher(target) {\r\n        var _this = _super.call(this) || this;\r\n        /**\r\n         * A target object which is originating events using this dispatcher.\r\n         */\r\n        Object.defineProperty(_this, \"target\", {\r\n            enumerable: true,\r\n            configurable: true,\r\n            writable: true,\r\n            value: void 0\r\n        });\r\n        _this.target = target;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Copies all dispatcher parameters, including listeners, from another event\r\n     * dispatcher.\r\n     *\r\n     * @param source Source event dispatcher\r\n     * @ignore\r\n     */\r\n    Object.defineProperty(TargetedEventDispatcher.prototype, \"copyFrom\", {\r\n        enumerable: false,\r\n        configurable: true,\r\n        writable: true,\r\n        value: function (source) {\r\n            var _this = this;\r\n            if (this._disposed) {\r\n                throw new Error(\"EventDispatcher is disposed\");\r\n            }\r\n            if (source === this) {\r\n                throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\r\n            }\r\n            var disposers = [];\r\n            $array.each(source._listeners, function (x) {\r\n                // TODO very hacky\r\n                if (x.context === source.target) {\r\n                    return;\r\n                }\r\n                // TODO is this correct ?\r\n                if (!x.killed && x.shouldClone) {\r\n                    if (x.type === null) {\r\n                        disposers.push(_this.onAll(x.callback, x.context));\r\n                    }\r\n                    else if (x.once) {\r\n                        disposers.push(_this.once(x.type, x.callback, x.context));\r\n                    }\r\n                    else {\r\n                        disposers.push(_this.on(x.type, x.callback, x.context));\r\n                    }\r\n                }\r\n            });\r\n            return new MultiDisposer(disposers);\r\n        }\r\n    });\r\n    return TargetedEventDispatcher;\r\n}(EventDispatcher));\r\nexport { TargetedEventDispatcher };\r\n"]},"metadata":{},"sourceType":"module"}