{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { CategoryAxis } from \"./CategoryAxis\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * Category-based date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/category-date-axis/} for more info\r\n * @important\r\n */\n\nvar CategoryDateAxis =\n/** @class */\nfunction (_super) {\n  __extends(CategoryDateAxis, _super);\n\n  function CategoryDateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_frequency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_itemMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    return _this;\n  }\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      this.fields.push(\"category\");\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(CategoryDateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this; // temp\n\n\n      this.setPrivateRaw(\"baseInterval\", this.get(\"baseInterval\"));\n      var renderer = this.get(\"renderer\");\n      var len = this.dataItems.length;\n      var startIndex = this.startIndex();\n\n      if (startIndex > 0) {\n        startIndex--;\n      }\n\n      var endIndex = this.endIndex();\n\n      if (endIndex < len) {\n        endIndex++;\n      }\n\n      var maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\n      var frequency = Math.min(len, Math.ceil((endIndex - startIndex) / maxCount));\n      startIndex = Math.floor(startIndex / frequency) * frequency;\n      this._frequency = frequency;\n\n      for (var j = 0; j < len; j++) {\n        this.dataItems[j].hide();\n      }\n\n      var startTime = Number(this.dataItems[startIndex].get(\"category\"));\n      var endTime = Number(this.dataItems[endIndex - 1].get(\"category\"));\n      var realDuration = endTime - startTime;\n\n      if (endIndex - startIndex < maxCount) {\n        realDuration = endTime - startTime - ((endTime - startTime) / this.baseDuration() - (endIndex - startIndex)) * this.baseDuration();\n      } // if all items are on axis\n\n\n      var gridInterval = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\"));\n      var nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n      var baseInterval = this.getPrivate(\"baseInterval\");\n\n      if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n        gridInterval = __assign({}, baseInterval);\n      }\n\n      var formats = this.get(\"dateFormats\");\n      var previousValue = -Infinity;\n      var previousIndex = -Infinity;\n      var previousUnitValue = -Infinity;\n      var format;\n      var selectedItems = [];\n      var changed = false;\n\n      for (var i = startIndex; i < endIndex; i++) {\n        var dataItem = this.dataItems[i];\n        var index = dataItem.get(\"index\");\n        var skip = false;\n        var value = Number(dataItem.get(\"category\"));\n        var date = new Date(value);\n        var unitValue = $time.getUnitValue(date, gridInterval.timeUnit);\n        format = formats[gridInterval.timeUnit];\n        var added = false;\n\n        if (gridInterval.timeUnit != \"year\" && gridInterval.timeUnit != \"week\") {\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc)) {\n              format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n\n              if (index - frequency * 0.5 < previousIndex) {\n                selectedItems.pop();\n              }\n\n              selectedItems.push({\n                format: format,\n                dataItem: dataItem\n              });\n              changed = true;\n              added = true;\n              previousIndex = index;\n              previousUnitValue = unitValue;\n            }\n          }\n        }\n\n        var shouldAdd = false;\n\n        if (gridInterval.timeUnit === \"day\" || gridInterval.timeUnit === \"week\") {\n          if (index - previousIndex >= frequency) {\n            shouldAdd = true;\n          }\n        } else {\n          if (unitValue % gridInterval.count === 0) {\n            if (unitValue != previousUnitValue) {\n              shouldAdd = true;\n            }\n          }\n        }\n\n        if (!added && shouldAdd) {\n          if (index - frequency * 0.7 < previousIndex) {\n            if (changed) {\n              skip = true;\n            }\n          }\n\n          if (!skip) {\n            selectedItems.push({\n              format: format,\n              dataItem: dataItem\n            });\n            previousIndex = index;\n            previousUnitValue = unitValue;\n          }\n\n          changed = false;\n        }\n\n        previousValue = value;\n      }\n\n      if (selectedItems.length > 0) {\n        var f_1 = selectedItems[0].dataItem.get(\"index\", 0);\n        $array.each(selectedItems, function (item) {\n          var dataItem = item.dataItem;\n          var format = item.format;\n\n          _this._createAssets(dataItem, []);\n\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n\n          var value = Number(dataItem.get(\"category\"));\n          var date = new Date(value);\n          var label = dataItem.get(\"label\");\n\n          if (label) {\n            label.set(\"text\", _this._root.dateFormatter.format(date, format));\n          }\n\n          f_1++;\n\n          _this._prepareDataItem(dataItem, f_1, frequency);\n        });\n      }\n    }\n  });\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"baseDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(CategoryDateAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      //@todo number formatter + tag\n      var dataItem = this.dataItems[this.axisPositionToIndex(position)];\n\n      if (dataItem) {\n        var format = this.get(\"dateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n        return this._root.dateFormatter.format(new Date(dataItem.get(\"category\", 0)), this.get(\"tooltipDateFormat\", format));\n      }\n    }\n  });\n  Object.defineProperty(CategoryDateAxis.prototype, \"_updateTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (tooltip, position) {\n      tooltip.label.set(\"text\", this.getTooltipText(position));\n    }\n  });\n  Object.defineProperty(CategoryDateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"CategoryDateAxis\"\n  });\n  Object.defineProperty(CategoryDateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: CategoryAxis.classNames.concat([CategoryDateAxis.className])\n  });\n  return CategoryDateAxis;\n}(CategoryAxis);\n\nexport { CategoryDateAxis }; //# sourceMappingURL=CategoryDateAxis.js.map","map":null,"metadata":{},"sourceType":"module"}