{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"./Entity\";\nimport { Color } from \"./Color\";\n/**\r\n * An object which holds list of colors and can generate new ones.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Color_sets} for more info\r\n */\n\nvar ColorSet =\n/** @class */\nfunction (_super) {\n  __extends(ColorSet, _super);\n\n  function ColorSet() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } //protected _currentPass: number = 0;\n\n\n  Object.defineProperty(ColorSet.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // Applying themes because color set will not have parent\n      _super.prototype._afterNewApplyThemes.call(this);\n\n      this._dirty[\"colors\"] = false;\n    }\n  });\n  Object.defineProperty(ColorSet.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this.isDirty(\"colors\")) {\n        this.reset();\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"generateColors\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivate(\"currentPass\", this.getPrivate(\"currentPass\", 0) + 1);\n      var pass = this.getPrivate(\"currentPass\");\n      var colors = this.get(\"colors\", [this.get(\"baseColor\", Color.fromHex(0xff0000))]);\n\n      if (!this.getPrivate(\"numColors\")) {\n        this.setPrivate(\"numColors\", colors.length);\n      } //const len = colors.length;\n\n\n      var len = this.getPrivate(\"numColors\"); //const start = len - this.getPrivate(\"numColors\")!;\n\n      var start = 0;\n      var passOptions = this.get(\"passOptions\");\n      var reuse = this.get(\"reuse\");\n\n      for (var i = start; i < len; i++) {\n        if (reuse) {\n          colors.push(colors[i]);\n        } else {\n          var hsl = colors[i].toHSL();\n          var h = hsl.h + (passOptions.hue || 0) * pass;\n\n          while (h > 1) h -= 1;\n\n          var s = hsl.s + (passOptions.saturation || 0) * pass; //if (s > 1) s -= Math.floor(s);\n\n          if (s > 1) s = 1;\n          if (s < 0) s = 0;\n          var l = hsl.l + (passOptions.lightness || 0) * pass; //if (l > 1) l -= Math.floor(l);\n\n          while (l > 1) l -= 1;\n\n          colors.push(Color.fromHSL(h, s, l));\n        }\n      }\n    }\n  });\n  /**\r\n   * Returns a [[Color]] at specific index.\r\n   *\r\n   * If there's no color at this index, a new color is generated.\r\n   *\r\n   * @param   index  Index\r\n   * @return         Color\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"getIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index) {\n      var colors = this.get(\"colors\", []);\n      var saturation = this.get(\"saturation\");\n\n      if (index >= colors.length) {\n        this.generateColors();\n        return this.getIndex(index);\n      }\n\n      return saturation != null ? Color.saturate(colors[index], saturation) : colors[index];\n    }\n  });\n  /**\r\n   * Returns next [[Color]] in the list.\r\n   *\r\n   * If the list is out of colors, new ones are generated dynamically.\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"next\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var currentStep = this.getPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n      this.setPrivate(\"currentStep\", currentStep + this.get(\"step\", 1));\n      return this.getIndex(currentStep);\n    }\n  });\n  /**\r\n   * Resets counter to the start of the list, so the next call for `next()` will\r\n   * return the first color.\r\n   */\n\n  Object.defineProperty(ColorSet.prototype, \"reset\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivate(\"currentStep\", this.get(\"startIndex\", 0));\n      this.setPrivate(\"currentPass\", 0);\n    }\n  });\n  Object.defineProperty(ColorSet, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"ColorSet\"\n  });\n  Object.defineProperty(ColorSet, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Entity.classNames.concat([ColorSet.className])\n  });\n  return ColorSet;\n}(Entity);\n\nexport { ColorSet }; //# sourceMappingURL=ColorSet.js.map","map":null,"metadata":{},"sourceType":"module"}