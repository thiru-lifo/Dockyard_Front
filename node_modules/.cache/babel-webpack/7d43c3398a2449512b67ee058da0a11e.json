{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"./Entity\";\nimport { TextFormatter } from \"./TextFormatter\";\nimport { Timezone } from \"./Timezone\";\nimport * as $type from \"./Type\";\nimport * as $utils from \"./Utils\";\n\nvar DateFormatter =\n/** @class */\nfunction (_super) {\n  __extends(DateFormatter, _super);\n\n  function DateFormatter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(DateFormatter.prototype, \"_setDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // Defaults\n      this._setDefault(\"capitalize\", true);\n\n      this._setDefault(\"dateFormat\", \"yyyy-MM-dd\");\n\n      _super.prototype._setDefaults.call(this);\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"format\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (source, format) {\n      // Locale?\n      // TODO\n      // No format passed in or it's empty\n      if (typeof format === \"undefined\" || format === \"\") {\n        format = this.get(\"dateFormat\", \"yyyy-MM-dd\");\n      } // Init return value\n\n\n      var formatted; // Cast?\n      // TODO: decide if we need to cast\n\n      var date = source; // Is it a built-in format or Intl.DateTimeFormat\n\n      if ($type.isObject(format)) {\n        try {\n          var locales = this.get(\"intlLocales\");\n\n          if (locales) {\n            return new Intl.DateTimeFormat(locales, format).format(date);\n          } else {\n            return new Intl.DateTimeFormat(undefined, format).format(date);\n          }\n        } catch (e) {\n          return \"Invalid\";\n        }\n      } // get format info (it will also deal with parser caching)\n\n\n      var info = this.parseFormat(format); // Should we apply custom time zone?\n\n      var timezone = this._root.timezone;\n\n      if (timezone && !this._root.utc) {\n        date = timezone.convertLocal(date);\n      } // Check if it's a valid date\n\n\n      if (!$type.isNumber(date.getTime())) {\n        // TODO translation\n        //return this._t(\"Invalid date\");\n        return \"Invalid date\";\n      } // Apply format\n\n\n      formatted = this.applyFormat(date, info); // Capitalize\n\n      if (this.get(\"capitalize\")) {\n        formatted = formatted.replace(/^.{1}/, formatted.substr(0, 1).toUpperCase());\n      } // We're done\n\n\n      return formatted;\n    }\n  });\n  /**\r\n   * Applies format to Date.\r\n   *\r\n   * @param date      Date object\r\n   * @param info      Parsed format information\r\n   * @return Formatted date string\r\n   */\n\n  Object.defineProperty(DateFormatter.prototype, \"applyFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (date, info) {\n      // Init return value\n      var res = info.template; // Get values\n\n      var fullYear,\n          month,\n          weekday,\n          day,\n          hours,\n          minutes,\n          seconds,\n          milliseconds,\n          timestamp = date.getTime();\n\n      if (this._root.utc) {\n        fullYear = date.getUTCFullYear();\n        month = date.getUTCMonth();\n        weekday = date.getUTCDay();\n        day = date.getUTCDate();\n        hours = date.getUTCHours();\n        minutes = date.getUTCMinutes();\n        seconds = date.getUTCSeconds();\n        milliseconds = date.getUTCMilliseconds();\n      } else {\n        fullYear = date.getFullYear();\n        month = date.getMonth();\n        weekday = date.getDay();\n        day = date.getDate();\n        hours = date.getHours();\n        minutes = date.getMinutes();\n        seconds = date.getSeconds();\n        milliseconds = date.getMilliseconds();\n      } // Go through each part and format/replace it in template\n\n\n      for (var i = 0, len = info.parts.length; i < len; i++) {\n        var value = \"\";\n\n        switch (info.parts[i]) {\n          case \"G\":\n            value = this._t(fullYear < 0 ? \"_era_bc\" : \"_era_ad\");\n            break;\n\n          case \"yyyy\":\n            value = Math.abs(fullYear).toString();\n\n            if (fullYear < 0) {\n              value += this._t(\"_era_bc\");\n            }\n\n            break;\n\n          case \"yyy\":\n          case \"yy\":\n          case \"y\":\n            value = Math.abs(fullYear).toString().substr(-info.parts[i].length);\n\n            if (fullYear < 0) {\n              value += this._t(\"_era_bc\");\n            }\n\n            break;\n\n          case \"YYYY\":\n          case \"YYY\":\n          case \"YY\":\n          case \"Y\":\n            var week = $utils.getWeek(date);\n            var year = fullYear;\n\n            if (week == 1 && weekday > 4) {\n              year--;\n            }\n\n            if (info.parts[i] == \"YYYY\") {\n              value = Math.abs(year).toString();\n            } else {\n              value = Math.abs(year).toString().substr(-info.parts[i].length);\n            }\n\n            if (year < 0) {\n              value += this._t(\"_era_bc\");\n            }\n\n            break;\n\n          case \"u\":\n            // @todo\n            break;\n\n          case \"q\":\n            value = \"\" + Math.ceil((date.getMonth() + 1) / 3);\n            break;\n\n          case \"MMMMM\":\n            value = this._t(this._getMonth(month)).substr(0, 1);\n            break;\n\n          case \"MMMM\":\n            value = this._t(this._getMonth(month));\n            break;\n\n          case \"MMM\":\n            value = this._t(this._getShortMonth(month));\n            break;\n\n          case \"MM\":\n            value = $utils.padString(month + 1, 2, \"0\");\n            break;\n\n          case \"M\":\n            value = (month + 1).toString();\n            break;\n\n          case \"ww\":\n            value = $utils.padString($utils.getWeek(date, this._root.utc), 2, \"0\");\n            break;\n\n          case \"w\":\n            value = $utils.getWeek(date, this._root.utc).toString();\n            break;\n\n          case \"W\":\n            value = $utils.getMonthWeek(date, this._root.utc).toString();\n            break;\n\n          case \"dd\":\n            value = $utils.padString(day, 2, \"0\");\n            break;\n\n          case \"d\":\n            value = day.toString();\n            break;\n\n          case \"DD\":\n          case \"DDD\":\n            value = $utils.padString($utils.getYearDay(date, this._root.utc).toString(), info.parts[i].length, \"0\");\n            break;\n\n          case \"D\":\n            value = $utils.getYearDay(date, this._root.utc).toString();\n            break;\n\n          case \"F\":\n            // @todo\n            break;\n\n          case \"g\":\n            // @todo\n            break;\n\n          case \"t\":\n            value = this._root.language.translateFunc(\"_dateOrd\").call(this, day);\n            break;\n\n          case \"E\":\n            value = (weekday || 7).toString();\n            break;\n\n          case \"EE\":\n            value = $utils.padString((weekday || 7).toString(), 2, \"0\");\n            break;\n\n          case \"EEE\":\n          case \"eee\":\n            value = this._t(this._getShortWeekday(weekday));\n            break;\n\n          case \"EEEE\":\n          case \"eeee\":\n            value = this._t(this._getWeekday(weekday));\n            break;\n\n          case \"EEEEE\":\n          case \"eeeee\":\n            value = this._t(this._getShortWeekday(weekday)).substr(0, 1);\n            break;\n\n          case \"e\":\n          case \"ee\":\n            value = (weekday - (this._root.locale.firstDayOfWeek || 1) + 1).toString();\n\n            if (info.parts[i] == \"ee\") {\n              value = $utils.padString(value, 2, \"0\");\n            }\n\n            break;\n\n          case \"a\":\n            if (hours >= 12) {\n              value = this._t(\"PM\");\n            } else {\n              value = this._t(\"AM\");\n            }\n\n            break;\n\n          case \"aa\":\n            if (hours >= 12) {\n              value = this._t(\"P.M.\");\n            } else {\n              value = this._t(\"A.M.\");\n            }\n\n            break;\n\n          case \"aaa\":\n            if (hours >= 12) {\n              value = this._t(\"P\");\n            } else {\n              value = this._t(\"A\");\n            }\n\n            break;\n\n          case \"h\":\n            value = $utils.get12Hours(hours).toString();\n            break;\n\n          case \"hh\":\n            value = $utils.padString($utils.get12Hours(hours), 2, \"0\");\n            break;\n\n          case \"H\":\n            value = hours.toString();\n            break;\n\n          case \"HH\":\n            value = $utils.padString(hours, 2, \"0\");\n            break;\n\n          case \"K\":\n            value = $utils.get12Hours(hours, 0).toString();\n            break;\n\n          case \"KK\":\n            value = $utils.padString($utils.get12Hours(hours, 0), 2, \"0\");\n            break;\n\n          case \"k\":\n            value = (hours + 1).toString();\n            break;\n\n          case \"kk\":\n            value = $utils.padString(hours + 1, 2, \"0\");\n            break;\n\n          case \"m\":\n            value = minutes.toString();\n            break;\n\n          case \"mm\":\n            value = $utils.padString(minutes, 2, \"0\");\n            break;\n\n          case \"s\":\n            value = seconds.toString();\n            break;\n\n          case \"ss\":\n            value = $utils.padString(seconds, 2, \"0\");\n            break;\n\n          case \"S\":\n          case \"SS\":\n          case \"SSS\":\n            value = Math.round(milliseconds / 1000 * Math.pow(10, info.parts[i].length)).toString();\n            break;\n\n          case \"x\":\n            value = timestamp.toString();\n            break;\n\n          case \"n\":\n          case \"nn\":\n          case \"nnn\":\n            value = $utils.padString(milliseconds, info.parts[i].length, \"0\");\n            break;\n\n          case \"z\":\n            value = $utils.getTimeZone(date, false, false, this._root.utc);\n            break;\n\n          case \"zz\":\n            value = $utils.getTimeZone(date, true, false, this._root.utc);\n            break;\n\n          case \"zzz\":\n            value = $utils.getTimeZone(date, false, true, this._root.utc);\n            break;\n\n          case \"zzzz\":\n            value = $utils.getTimeZone(date, true, true, this._root.utc);\n            break;\n\n          case \"Z\":\n          case \"ZZ\":\n            var timezone = this._root.utc ? \"UTC\" : this._root.timezone;\n\n            if (timezone instanceof Timezone) {\n              timezone = timezone.name;\n            }\n\n            var offset = timezone ? $utils.getTimezoneOffset(timezone) : date.getTimezoneOffset();\n            var tz = Math.abs(offset) / 60;\n            var tzh = Math.floor(tz);\n            var tzm = tz * 60 - tzh * 60;\n\n            if (this._root.utc) {\n              tzh = 0;\n              tzm = 0;\n            }\n\n            if (info.parts[i] == \"Z\") {\n              value = \"GMT\";\n              value += offset > 0 ? \"-\" : \"+\";\n              value += $utils.padString(tzh, 2) + \":\" + $utils.padString(tzm, 2);\n            } else {\n              value = offset > 0 ? \"-\" : \"+\";\n              value += $utils.padString(tzh, 2) + $utils.padString(tzm, 2);\n            }\n\n            break;\n\n          case \"i\":\n            value = date.toISOString();\n            break;\n\n          case \"I\":\n            value = date.toUTCString();\n            break;\n        }\n\n        res = res.replace($type.PLACEHOLDER, value);\n      }\n\n      return res;\n    }\n  });\n  /**\r\n   * Parses format into structured infromation.\r\n   *\r\n   * @param format Format template\r\n   */\n\n  Object.defineProperty(DateFormatter.prototype, \"parseFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (format) {\n      // Check cache\n      // TODO: implement caching of the parsed format\n      // Init format parse info holder\n      var info = {\n        \"template\": \"\",\n        \"parts\": []\n      }; // Let TextFormatter split into chunks\n\n      var chunks = TextFormatter.chunk(format, true);\n\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i];\n\n        if (chunk.type === \"value\") {\n          // Just \"Date\"?\n          if (chunk.text.match(/^date$/i)) {\n            var dateFormat = this.get(\"dateFormat\", \"yyyy-MM-dd\");\n\n            if (!$type.isString(dateFormat)) {\n              dateFormat = \"yyyy-MM-dd\";\n            }\n\n            chunk.text = dateFormat;\n          } // Find all possible parts\n\n\n          var matches = chunk.text.match(/G|yyyy|yyy|yy|y|YYYY|YYY|YY|Y|u|q|MMMMM|MMMM|MMM|MM|M|ww|w|W|dd|d|DDD|DD|D|F|g|EEEEE|EEEE|EEE|EE|E|eeeee|eeee|eee|ee|e|aaa|aa|a|hh|h|HH|H|KK|K|kk|k|mm|m|ss|s|SSS|SS|S|A|zzzz|zzz|zz|z|ZZ|Z|t|x|nnn|nn|n|i|I/g); // Found?\n\n          if (matches) {\n            // Populate template\n            for (var x = 0; x < matches.length; x++) {\n              info.parts.push(matches[x]);\n              chunk.text = chunk.text.replace(matches[x], $type.PLACEHOLDER);\n            }\n          }\n        } // Apply to template\n\n\n        info.template += chunk.text;\n      } // Save cache\n      // TODO\n\n\n      return info;\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_months\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_getMonth\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index) {\n      return this._months()[index];\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_shortMonths\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May(short)\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"];\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_getShortMonth\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index) {\n      return this._shortMonths()[index];\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_weekdays\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_getWeekday\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index) {\n      return this._weekdays()[index];\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_shortWeekdays\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"_getShortWeekday\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index) {\n      return this._shortWeekdays()[index];\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (source, format) {\n      // Is it already a Date\n      if (source instanceof Date) {\n        return source;\n      } // Is it a numeric timestamp\n\n\n      if ($type.isNumber(source)) {\n        return new Date(source);\n      } // No? Let's check if it's string, and try converting to it if nec\n\n\n      if (!$type.isString(source)) {\n        source = source.toString();\n      } // Init return value\n\n\n      var res; // Init RegEx for parsing\n\n      var reg = \"\"; // Clean format\n\n      format = $utils.cleanFormat(format); // Clip format to length of the source string\n\n      format = format.substr(0, source.length); // Parse format\n\n      var info = this.parseFormat(format); // Init parsed items holder\n\n      var parsedIndexes = {\n        \"year\": -1,\n        \"year3\": -1,\n        \"year2\": -1,\n        \"year1\": -1,\n        \"month\": -1,\n        \"monthShort\": -1,\n        \"monthLong\": -1,\n        \"weekdayShort\": -1,\n        \"weekdayLong\": -1,\n        \"day\": -1,\n        \"yearDay\": -1,\n        \"week\": -1,\n        \"hourBase0\": -1,\n        \"hour12Base0\": -1,\n        \"hourBase1\": -1,\n        \"hour12Base1\": -1,\n        \"minute\": -1,\n        \"second\": -1,\n        \"millisecond\": -1,\n        \"millisecondDigits\": -1,\n        \"am\": -1,\n        \"zone\": -1,\n        \"timestamp\": -1,\n        \"iso\": -1\n      }; // Init values\n\n      var resValues = {\n        \"year\": 1970,\n        \"month\": 0,\n        \"day\": 1,\n        \"hour\": 0,\n        \"minute\": 0,\n        \"second\": 0,\n        \"millisecond\": 0,\n        \"timestamp\": null,\n        \"offset\": 0,\n        \"utc\": this._root.utc\n      }; // Index adjuster\n\n      var indexAdjust = 0;\n      var index = 0; // Iterate through all of the parts\n\n      for (var i = 0; i < info.parts.length; i++) {\n        // Set current match index\n        index = i + indexAdjust + 1;\n\n        switch (info.parts[i]) {\n          case \"yyyy\":\n          case \"YYYY\":\n            reg += \"([0-9]{4})\";\n            parsedIndexes.year = index;\n            break;\n\n          case \"yyy\":\n          case \"YYY\":\n            reg += \"([0-9]{3})\";\n            parsedIndexes.year3 = index;\n            break;\n\n          case \"yy\":\n          case \"YY\":\n            reg += \"([0-9]{2})\";\n            parsedIndexes.year2 = index;\n            break;\n\n          case \"y\":\n          case \"Y\":\n            reg += \"([0-9]{1})\";\n            parsedIndexes.year1 = index;\n            break;\n\n          case \"MMMM\":\n            reg += \"(\" + this.getStringList(this._months()).join(\"|\") + \")\";\n            parsedIndexes.monthLong = index;\n            break;\n\n          case \"MMM\":\n            reg += \"(\" + this.getStringList(this._shortMonths()).join(\"|\") + \")\";\n            parsedIndexes.monthShort = index;\n            break;\n\n          case \"MM\":\n          case \"M\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.month = index;\n            break;\n\n          case \"ww\":\n          case \"w\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.week = index;\n            break;\n\n          case \"dd\":\n          case \"d\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.day = index;\n            break;\n\n          case \"DDD\":\n          case \"DD\":\n          case \"D\":\n            reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n            parsedIndexes.yearDay = index;\n            break;\n\n          case \"dddd\":\n            reg += \"(\" + this.getStringList(this._weekdays()).join(\"|\") + \")\";\n            parsedIndexes.weekdayLong = index;\n            break;\n\n          case \"ddd\":\n            reg += \"(\" + this.getStringList(this._shortWeekdays()).join(\"|\") + \")\";\n            parsedIndexes.weekdayShort = index;\n            break;\n\n          case \"aaa\":\n          case \"aa\":\n          case \"a\":\n            // TODO: fix (escape regex)\n            reg += \"(\" + this.getStringList([\"AM\", \"PM\", \"A\\.M\\.\", \"P\\.M\\.\", \"A\", \"P\"]).join(\"|\") + \")\";\n            parsedIndexes.am = index;\n            break;\n\n          case \"hh\":\n          case \"h\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.hour12Base1 = index;\n            break;\n\n          case \"HH\":\n          case \"H\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.hourBase0 = index;\n            break;\n\n          case \"KK\":\n          case \"K\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.hour12Base0 = index;\n            break;\n\n          case \"kk\":\n          case \"k\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.hourBase1 = index;\n            break;\n\n          case \"mm\":\n          case \"m\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.minute = index;\n            break;\n\n          case \"ss\":\n          case \"s\":\n            reg += \"([0-9]{2}|[0-9]{1})\";\n            parsedIndexes.second = index;\n            break;\n\n          case \"SSS\":\n          case \"SS\":\n          case \"S\":\n            reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n            parsedIndexes.millisecond = index;\n            parsedIndexes.millisecondDigits = info.parts[i].length;\n            break;\n\n          case \"nnn\":\n          case \"nn\":\n          case \"n\":\n            reg += \"([0-9]{3}|[0-9]{2}|[0-9]{1})\";\n            parsedIndexes.millisecond = index;\n            break;\n\n          case \"x\":\n            reg += \"([0-9]{1,})\";\n            parsedIndexes.timestamp = index;\n            break;\n\n          case \"Z\":\n            reg += \"GMT([-+]+[0-9]{2}:[0-9]{2})\";\n            parsedIndexes.zone = index;\n            break;\n\n          case \"ZZ\":\n            reg += \"([\\\\-+]+[0-9]{2}[0-9]{2})\";\n            parsedIndexes.zone = index;\n            break;\n\n          case \"i\":\n            reg += \"([0-9]{4})-?([0-9]{2})-?([0-9]{2})T?([0-9]{2}):?([0-9]{2}):?([0-9]{2})\\\\.?([0-9]{0,3})([zZ]|[+\\\\-][0-9]{2}:?[0-9]{2}|$)\";\n            parsedIndexes.iso = index;\n            indexAdjust += 7;\n            break;\n\n          case \"G\":\n          case \"YYYY\":\n          case \"YYY\":\n          case \"YY\":\n          case \"Y\":\n          case \"MMMMM\":\n          case \"W\":\n          case \"EEEEE\":\n          case \"EEEE\":\n          case \"EEE\":\n          case \"EE\":\n          case \"E\":\n          case \"eeeee\":\n          case \"eeee\":\n          case \"eee\":\n          case \"ee\":\n          case \"e\":\n          case \"zzzz\":\n          case \"zzz\":\n          case \"zz\":\n          case \"z\":\n          case \"t\":\n            // Ignore\n            indexAdjust--;\n            break;\n        }\n\n        reg += \"[^0-9]*\";\n      } // Try matching\n\n\n      var regex = new RegExp(reg);\n      var matches = source.match(regex);\n\n      if (matches) {\n        // Populate the date object\n        // Full year\n        if (parsedIndexes.year > -1) {\n          resValues.year = parseInt(matches[parsedIndexes.year]);\n        } // 3-digit year\n\n\n        if (parsedIndexes.year3 > -1) {\n          var val = parseInt(matches[parsedIndexes.year3]);\n          val += 1000;\n          resValues.year = val;\n        } // 2-digit year\n\n\n        if (parsedIndexes.year2 > -1) {\n          var val = parseInt(matches[parsedIndexes.year2]);\n\n          if (val > 50) {\n            val += 1000;\n          } else {\n            val += 2000;\n          }\n\n          resValues.year = val;\n        } // 1-digit year\n\n\n        if (parsedIndexes.year1 > -1) {\n          var val = parseInt(matches[parsedIndexes.year1]);\n          val = Math.floor(new Date().getFullYear() / 10) * 10 + val;\n          resValues.year = val;\n        } // Full month\n\n\n        if (parsedIndexes.monthLong > -1) {\n          resValues.month = this.resolveMonth(matches[parsedIndexes.monthLong]);\n        } // Short month\n\n\n        if (parsedIndexes.monthShort > -1) {\n          resValues.month = this.resolveShortMonth(matches[parsedIndexes.monthShort]);\n        } // Numeric month\n\n\n        if (parsedIndexes.month > -1) {\n          resValues.month = parseInt(matches[parsedIndexes.month]) - 1;\n        } // Weekday\n        // @todo\n        // Week\n\n\n        if (parsedIndexes.week > -1 && parsedIndexes.day === -1) {\n          // We parse weeks ONLY if day is not explicitly set\n          // TODO: this needs work\n          // (but maybe later - I can hardly imagine anyone passing their dates in weeks)\n          resValues.month = 0;\n          resValues.day = $utils.getDayFromWeek(parseInt(matches[parsedIndexes.week]), resValues.year, 1, this._root.utc);\n        } // Day\n\n\n        if (parsedIndexes.day > -1) {\n          resValues.day = parseInt(matches[parsedIndexes.day]);\n        } // Year day\n\n\n        if (parsedIndexes.yearDay > -1) {\n          resValues.month = 0;\n          resValues.day = parseInt(matches[parsedIndexes.yearDay]);\n        } // 24 Hour (0-23)\n\n\n        if (parsedIndexes.hourBase0 > -1) {\n          resValues.hour = parseInt(matches[parsedIndexes.hourBase0]);\n        } // 24 Hour (1-24)\n\n\n        if (parsedIndexes.hourBase1 > -1) {\n          resValues.hour = parseInt(matches[parsedIndexes.hourBase1]) - 1;\n        } // 12 Hour (0-11)\n\n\n        if (parsedIndexes.hour12Base0 > -1) {\n          var val = parseInt(matches[parsedIndexes.hour12Base0]);\n\n          if (val == 11) {\n            val = 0;\n          }\n\n          if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {\n            val += 12;\n          }\n\n          resValues.hour = val;\n        } // 12 Hour (1-12)\n\n\n        if (parsedIndexes.hour12Base1 > -1) {\n          var val = parseInt(matches[parsedIndexes.hour12Base1]);\n\n          if (val == 12) {\n            val = 0;\n          }\n\n          if (parsedIndexes.am > -1 && !this.isAm(matches[parsedIndexes.am])) {\n            val += 12;\n          }\n\n          resValues.hour = val;\n        } // Minute\n\n\n        if (parsedIndexes.minute > -1) {\n          resValues.minute = parseInt(matches[parsedIndexes.minute]);\n        } // Second\n\n\n        if (parsedIndexes.second > -1) {\n          resValues.second = parseInt(matches[parsedIndexes.second]);\n        } // Millisecond\n\n\n        if (parsedIndexes.millisecond > -1) {\n          var val = parseInt(matches[parsedIndexes.millisecond]);\n\n          if (parsedIndexes.millisecondDigits == 2) {\n            val *= 10;\n          } else if (parsedIndexes.millisecondDigits == 1) {\n            val *= 100;\n          }\n\n          resValues.millisecond = val;\n        } // Timestamp\n\n\n        if (parsedIndexes.timestamp > -1) {\n          resValues.timestamp = parseInt(matches[parsedIndexes.timestamp]);\n          var ts = new Date(resValues.timestamp);\n          resValues.year = ts.getUTCFullYear();\n          resValues.month = ts.getUTCMonth();\n          resValues.day = ts.getUTCDate();\n          resValues.hour = ts.getUTCHours();\n          resValues.minute = ts.getUTCMinutes();\n          resValues.second = ts.getUTCSeconds();\n          resValues.millisecond = ts.getUTCMilliseconds();\n        } // Adjust time zone\n\n\n        if (parsedIndexes.zone > -1) {\n          resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.zone]);\n        } // ISO\n\n\n        if (parsedIndexes.iso > -1) {\n          resValues.year = $type.toNumber(matches[parsedIndexes.iso + 0]);\n          resValues.month = $type.toNumber(matches[parsedIndexes.iso + 1]) - 1;\n          resValues.day = $type.toNumber(matches[parsedIndexes.iso + 2]);\n          resValues.hour = $type.toNumber(matches[parsedIndexes.iso + 3]);\n          resValues.minute = $type.toNumber(matches[parsedIndexes.iso + 4]);\n          resValues.second = $type.toNumber(matches[parsedIndexes.iso + 5]);\n          resValues.millisecond = $type.toNumber(matches[parsedIndexes.iso + 6]);\n\n          if (matches[parsedIndexes.iso + 7] == \"Z\" || matches[parsedIndexes.iso + 7] == \"z\") {\n            resValues.utc = true;\n          } else if (matches[parsedIndexes.iso + 7] != \"\") {\n            resValues.offset = this.resolveTimezoneOffset(new Date(resValues.year, resValues.month, resValues.day), matches[parsedIndexes.iso + 7]);\n          }\n        } // Create Date object\n\n\n        if (resValues.utc) {\n          res = new Date(Date.UTC(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute, resValues.second, resValues.millisecond));\n        } else {\n          res = new Date(resValues.year, resValues.month, resValues.day, resValues.hour, resValues.minute + resValues.offset, resValues.second, resValues.millisecond);\n        }\n      } else {\n        // Didn't match anything\n        // Let's try dropping it into Date constructor and hope for the best\n        res = new Date(source);\n      }\n\n      return res;\n    }\n  });\n  Object.defineProperty(DateFormatter.prototype, \"resolveTimezoneOffset\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (date, zone) {\n      var value = zone.match(/([+\\-]?)([0-9]{2}):?([0-9]{2})/);\n\n      if (value) {\n        var match = zone.match(/([+\\-]?)([0-9]{2}):?([0-9]{2})/);\n        var dir = match[1];\n        var hour = match[2];\n        var minute = match[3];\n        var offset = parseInt(hour) * 60 + parseInt(minute); // Adjust offset\n        // Making it negative does not seem to make sense, but it's right\n        // because of how JavaScript calculates GMT offsets\n\n        if (dir == \"+\") {\n          offset *= -1;\n        } // Check the difference in offset\n\n\n        var originalOffset = (date || new Date()).getTimezoneOffset();\n        var diff = offset - originalOffset;\n        return diff;\n      }\n\n      return 0;\n    }\n  });\n  /**\r\n   * Resolves month name (i.e. \"December\") into a month number (11).\r\n   *\r\n   * @param value  Month name\r\n   * @return Month number\r\n   */\n\n  Object.defineProperty(DateFormatter.prototype, \"resolveMonth\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      // Let's try English first\n      var month = this._months().indexOf(value);\n\n      if (month > -1) {\n        return month;\n      } // Try the translation\n\n\n      if (!this._root.language.isDefault()) {\n        month = this._root.language.translateAll(this._months()).indexOf(value);\n\n        if (month > -1) {\n          return month;\n        }\n      }\n\n      return 0;\n    }\n  });\n  /**\r\n   * Resolves short month name (i.e. \"Dec\") into a month number.\r\n   *\r\n   * @param value  Short month name\r\n   * @return Month number\r\n   */\n\n  Object.defineProperty(DateFormatter.prototype, \"resolveShortMonth\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      // Let's try English first\n      var month = this._shortMonths().indexOf(value);\n\n      if (month > -1) {\n        return month;\n      } // Maybe long month (workaround for May)\n\n\n      month = this._months().indexOf(value);\n\n      if (month > -1) {\n        return month;\n      } // Try the translation\n\n\n      if (this._root.language && !this._root.language.isDefault()) {\n        month = this._root.language.translateAll(this._shortMonths()).indexOf(value);\n\n        if (month > -1) {\n          return month;\n        }\n      }\n\n      return 0;\n    }\n  });\n  /**\r\n   * Checks if passed in string represents AM/PM notation in many of its\r\n   * versions.\r\n   *\r\n   * @param value  Source string\r\n   * @return Is it AM/PM?\r\n   */\n\n  Object.defineProperty(DateFormatter.prototype, \"isAm\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var list = this.getStringList([\"AM\", \"A.M.\", \"A\"]);\n      return list.indexOf(value.toUpperCase()) > -1;\n    }\n  });\n  /**\r\n   * Translates list of strings.\r\n   *\r\n   * @param list  Source strings\r\n   * @return Translated strings\r\n   */\n\n  Object.defineProperty(DateFormatter.prototype, \"getStringList\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (list) {\n      var res = [];\n\n      for (var i = 0; i < list.length; i++) {\n        // translate?\n        if (this._root.language) {\n          res.push($utils.escapeForRgex(this._t(list[i])));\n        } else {\n          res.push($utils.escapeForRgex(list[i]));\n        }\n      }\n\n      return res;\n    }\n  });\n  return DateFormatter;\n}(Entity);\n\nexport { DateFormatter }; //# sourceMappingURL=DateFormatter.js.map","map":null,"metadata":{},"sourceType":"module"}