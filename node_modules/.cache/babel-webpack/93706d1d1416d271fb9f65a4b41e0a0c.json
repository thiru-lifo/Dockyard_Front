{"ast":null,"code":"/*\n Highcharts JS v10.2.0 (2022-07-05)\n\n (c) 2009-2021 Torstein Honsi\n\n License: www.highcharts.com/license\n*/\n(function (Y, K) {\n  \"object\" === typeof module && module.exports ? (K[\"default\"] = K, module.exports = Y.document ? K(Y) : K) : \"function\" === typeof define && define.amd ? define(\"highcharts/highcharts\", function () {\n    return K(Y);\n  }) : (Y.Highcharts && Y.Highcharts.error(16, !0), Y.Highcharts = K(Y));\n})(\"undefined\" !== typeof window ? window : this, function (Y) {\n  function K(f, e, l, C) {\n    f.hasOwnProperty(e) || (f[e] = C.apply(null, l), \"function\" === typeof CustomEvent && Y.dispatchEvent(new CustomEvent(\"HighchartsModuleLoaded\", {\n      detail: {\n        path: e,\n        module: f[e]\n      }\n    })));\n  }\n\n  var l = {};\n  K(l, \"Core/Globals.js\", [], function () {\n    var f;\n\n    (function (e) {\n      e.SVG_NS = \"http://www.w3.org/2000/svg\";\n      e.product = \"Highcharts\";\n      e.version = \"10.2.0\";\n      e.win = \"undefined\" !== typeof Y ? Y : {};\n      e.doc = e.win.document;\n      e.svg = e.doc && e.doc.createElementNS && !!e.doc.createElementNS(e.SVG_NS, \"svg\").createSVGRect;\n      e.userAgent = e.win.navigator && e.win.navigator.userAgent || \"\";\n      e.isChrome = -1 !== e.userAgent.indexOf(\"Chrome\");\n      e.isFirefox = -1 !== e.userAgent.indexOf(\"Firefox\");\n      e.isMS = /(edge|msie|trident)/i.test(e.userAgent) && !e.win.opera;\n      e.isSafari = !e.isChrome && -1 !== e.userAgent.indexOf(\"Safari\");\n      e.isTouchDevice = /(Mobile|Android|Windows Phone)/.test(e.userAgent);\n      e.isWebKit = -1 !== e.userAgent.indexOf(\"AppleWebKit\");\n      e.deg2rad = 2 * Math.PI / 360;\n      e.hasBidiBug = e.isFirefox && 4 > parseInt(e.userAgent.split(\"Firefox/\")[1], 10);\n      e.hasTouch = !!e.win.TouchEvent;\n      e.marginNames = [\"plotTop\", \"marginRight\", \"marginBottom\", \"plotLeft\"];\n\n      e.noop = function () {};\n\n      e.supportsPassiveEvents = function () {\n        var f = !1;\n\n        if (!e.isMS) {\n          var l = Object.defineProperty({}, \"passive\", {\n            get: function () {\n              f = !0;\n            }\n          });\n          e.win.addEventListener && e.win.removeEventListener && (e.win.addEventListener(\"testPassive\", e.noop, l), e.win.removeEventListener(\"testPassive\", e.noop, l));\n        }\n\n        return f;\n      }();\n\n      e.charts = [];\n      e.dateFormats = {};\n      e.seriesTypes = {};\n      e.symbolSizes = {};\n      e.chartCount = 0;\n    })(f || (f = {}));\n\n    \"\";\n    return f;\n  });\n  K(l, \"Core/Utilities.js\", [l[\"Core/Globals.js\"]], function (f) {\n    function e(c, u, g, k) {\n      var A = u ? \"Highcharts error\" : \"Highcharts warning\";\n      32 === c && (c = \"\" + A + \": Deprecated member\");\n      var m = t(c),\n          n = m ? \"\" + A + \" #\" + c + \": www.highcharts.com/errors/\" + c + \"/\" : c.toString();\n\n      if (\"undefined\" !== typeof k) {\n        var b = \"\";\n        m && (n += \"?\");\n        w(k, function (a, c) {\n          b += \"\\n - \".concat(c, \": \").concat(a);\n          m && (n += encodeURI(c) + \"=\" + encodeURI(a));\n        });\n        n += b;\n      }\n\n      x(f, \"displayError\", {\n        chart: g,\n        code: c,\n        message: n,\n        params: k\n      }, function () {\n        if (u) throw Error(n);\n        a.console && -1 === e.messages.indexOf(n) && console.warn(n);\n      });\n      e.messages.push(n);\n    }\n\n    function l(a, c) {\n      var A = {};\n      w(a, function (u, g) {\n        if (G(a[g], !0) && !a.nodeType && c[g]) u = l(a[g], c[g]), Object.keys(u).length && (A[g] = u);else if (G(a[g]) || a[g] !== c[g] || g in a && !(g in c)) A[g] = a[g];\n      });\n      return A;\n    }\n\n    function C(a, c) {\n      return parseInt(a, c || 10);\n    }\n\n    function v(a) {\n      return \"string\" === typeof a;\n    }\n\n    function E(a) {\n      a = Object.prototype.toString.call(a);\n      return \"[object Array]\" === a || \"[object Array Iterator]\" === a;\n    }\n\n    function G(a, c) {\n      return !!a && \"object\" === typeof a && (!c || !E(a));\n    }\n\n    function B(a) {\n      return G(a) && \"number\" === typeof a.nodeType;\n    }\n\n    function y(a) {\n      var c = a && a.constructor;\n      return !(!G(a, !0) || B(a) || !c || !c.name || \"Object\" === c.name);\n    }\n\n    function t(a) {\n      return \"number\" === typeof a && !isNaN(a) && Infinity > a && -Infinity < a;\n    }\n\n    function h(a) {\n      return \"undefined\" !== typeof a && null !== a;\n    }\n\n    function d(a, c, g) {\n      var A = v(c) && !h(g),\n          u,\n          k = function (c, g) {\n        h(c) ? a.setAttribute(g, c) : A ? (u = a.getAttribute(g)) || \"class\" !== g || (u = a.getAttribute(g + \"Name\")) : a.removeAttribute(g);\n      };\n\n      v(c) ? k(g, c) : w(c, k);\n      return u;\n    }\n\n    function b(a, c) {\n      var A;\n      a || (a = {});\n\n      for (A in c) a[A] = c[A];\n\n      return a;\n    }\n\n    function p() {\n      for (var a = arguments, c = a.length, g = 0; g < c; g++) {\n        var k = a[g];\n        if (\"undefined\" !== typeof k && null !== k) return k;\n      }\n    }\n\n    function q(a, c) {\n      f.isMS && !f.svg && c && h(c.opacity) && (c.filter = \"alpha(opacity=\".concat(100 * c.opacity, \")\"));\n      b(a.style, c);\n    }\n\n    function r(a) {\n      return Math.pow(10, Math.floor(Math.log(a) / Math.LN10));\n    }\n\n    function n(a, c) {\n      return 1E14 < a ? a : parseFloat(a.toPrecision(c || 14));\n    }\n\n    function J(c, u, g) {\n      var A = f.getStyle || J;\n      if (\"width\" === u) return u = Math.min(c.offsetWidth, c.scrollWidth), g = c.getBoundingClientRect && c.getBoundingClientRect().width, g < u && g >= u - 1 && (u = Math.floor(g)), Math.max(0, u - (A(c, \"padding-left\", !0) || 0) - (A(c, \"padding-right\", !0) || 0));\n      if (\"height\" === u) return Math.max(0, Math.min(c.offsetHeight, c.scrollHeight) - (A(c, \"padding-top\", !0) || 0) - (A(c, \"padding-bottom\", !0) || 0));\n      a.getComputedStyle || e(27, !0);\n\n      if (c = a.getComputedStyle(c, void 0)) {\n        var k = c.getPropertyValue(u);\n        p(g, \"opacity\" !== u) && (k = C(k));\n      }\n\n      return k;\n    }\n\n    function w(a, c, g) {\n      for (var A in a) Object.hasOwnProperty.call(a, A) && c.call(g || a[A], a[A], A, a);\n    }\n\n    function z(a, c, g) {\n      function A(c, I) {\n        var A = a.removeEventListener || f.removeEventListenerPolyfill;\n        A && A.call(a, c, I, !1);\n      }\n\n      function u(u) {\n        var I;\n\n        if (a.nodeName) {\n          if (c) {\n            var H = {};\n            H[c] = !0;\n          } else H = u;\n\n          w(H, function (a, c) {\n            if (u[c]) for (I = u[c].length; I--;) A(c, u[c][I].fn);\n          });\n        }\n      }\n\n      var k = \"function\" === typeof a && a.prototype || a;\n\n      if (Object.hasOwnProperty.call(k, \"hcEvents\")) {\n        var m = k.hcEvents;\n        c ? (k = m[c] || [], g ? (m[c] = k.filter(function (a) {\n          return g !== a.fn;\n        }), A(c, g)) : (u(m), m[c] = [])) : (u(m), delete k.hcEvents);\n      }\n    }\n\n    function x(a, c, g, m) {\n      g = g || {};\n\n      if (k.createEvent && (a.dispatchEvent || a.fireEvent && a !== f)) {\n        var A = k.createEvent(\"Events\");\n        A.initEvent(c, !0, !0);\n        g = b(A, g);\n        a.dispatchEvent ? a.dispatchEvent(g) : a.fireEvent(c, g);\n      } else if (a.hcEvents) {\n        g.target || b(g, {\n          preventDefault: function () {\n            g.defaultPrevented = !0;\n          },\n          target: a,\n          type: c\n        });\n        A = [];\n\n        for (var u = a, n = !1; u.hcEvents;) Object.hasOwnProperty.call(u, \"hcEvents\") && u.hcEvents[c] && (A.length && (n = !0), A.unshift.apply(A, u.hcEvents[c])), u = Object.getPrototypeOf(u);\n\n        n && A.sort(function (a, c) {\n          return a.order - c.order;\n        });\n        A.forEach(function (c) {\n          !1 === c.fn.call(a, g) && g.preventDefault();\n        });\n      }\n\n      m && !g.defaultPrevented && m.call(a, g);\n    }\n\n    var m = f.charts,\n        k = f.doc,\n        a = f.win;\n    (e || (e = {})).messages = [];\n\n    Math.easeInOutSine = function (a) {\n      return -.5 * (Math.cos(Math.PI * a) - 1);\n    };\n\n    var g = Array.prototype.find ? function (a, c) {\n      return a.find(c);\n    } : function (a, c) {\n      var A,\n          u = a.length;\n\n      for (A = 0; A < u; A++) if (c(a[A], A)) return a[A];\n    };\n    w({\n      map: \"map\",\n      each: \"forEach\",\n      grep: \"filter\",\n      reduce: \"reduce\",\n      some: \"some\"\n    }, function (a, c) {\n      f[c] = function (A) {\n        var u;\n        e(32, !1, void 0, (u = {}, u[\"Highcharts.\".concat(c)] = \"use Array.\".concat(a), u));\n        return Array.prototype[a].apply(A, [].slice.call(arguments, 1));\n      };\n    });\n\n    var c,\n        D = function () {\n      var a = Math.random().toString(36).substring(2, 9) + \"-\",\n          u = 0;\n      return function () {\n        return \"highcharts-\" + (c ? \"\" : a) + u++;\n      };\n    }();\n\n    a.jQuery && (a.jQuery.fn.highcharts = function () {\n      var a = [].slice.call(arguments);\n      if (this[0]) return a[0] ? (new f[v(a[0]) ? a.shift() : \"Chart\"](this[0], a[0], a[1]), this) : m[d(this[0], \"data-highcharts-chart\")];\n    });\n    g = {\n      addEvent: function (a, c, g, k) {\n        void 0 === k && (k = {});\n        var u = \"function\" === typeof a && a.prototype || a;\n        Object.hasOwnProperty.call(u, \"hcEvents\") || (u.hcEvents = {});\n        u = u.hcEvents;\n        f.Point && a instanceof f.Point && a.series && a.series.chart && (a.series.chart.runTrackerClick = !0);\n        var A = a.addEventListener || f.addEventListenerPolyfill;\n        A && A.call(a, c, g, f.supportsPassiveEvents ? {\n          passive: void 0 === k.passive ? -1 !== c.indexOf(\"touch\") : k.passive,\n          capture: !1\n        } : !1);\n        u[c] || (u[c] = []);\n        u[c].push({\n          fn: g,\n          order: \"number\" === typeof k.order ? k.order : Infinity\n        });\n        u[c].sort(function (a, c) {\n          return a.order - c.order;\n        });\n        return function () {\n          z(a, c, g);\n        };\n      },\n      arrayMax: function (a) {\n        for (var c = a.length, g = a[0]; c--;) a[c] > g && (g = a[c]);\n\n        return g;\n      },\n      arrayMin: function (a) {\n        for (var c = a.length, g = a[0]; c--;) a[c] < g && (g = a[c]);\n\n        return g;\n      },\n      attr: d,\n      clamp: function (a, c, g) {\n        return a > c ? a < g ? a : g : c;\n      },\n      cleanRecursively: l,\n      clearTimeout: function (a) {\n        h(a) && clearTimeout(a);\n      },\n      correctFloat: n,\n      createElement: function (a, c, g, m, n) {\n        a = k.createElement(a);\n        c && b(a, c);\n        n && q(a, {\n          padding: \"0\",\n          border: \"none\",\n          margin: \"0\"\n        });\n        g && q(a, g);\n        m && m.appendChild(a);\n        return a;\n      },\n      css: q,\n      defined: h,\n      destroyObjectProperties: function (a, c) {\n        w(a, function (g, u) {\n          g && g !== c && g.destroy && g.destroy();\n          delete a[u];\n        });\n      },\n      discardElement: function (a) {\n        a && a.parentElement && a.parentElement.removeChild(a);\n      },\n      erase: function (a, c) {\n        for (var g = a.length; g--;) if (a[g] === c) {\n          a.splice(g, 1);\n          break;\n        }\n      },\n      error: e,\n      extend: b,\n      extendClass: function (a, c) {\n        var g = function () {};\n\n        g.prototype = new a();\n        b(g.prototype, c);\n        return g;\n      },\n      find: g,\n      fireEvent: x,\n      getMagnitude: r,\n      getNestedProperty: function (c, g) {\n        for (c = c.split(\".\"); c.length && h(g);) {\n          var u = c.shift();\n          if (\"undefined\" === typeof u || \"__proto__\" === u) return;\n          g = g[u];\n          if (!h(g) || \"function\" === typeof g || \"number\" === typeof g.nodeType || g === a) return;\n        }\n\n        return g;\n      },\n      getStyle: J,\n      inArray: function (a, c, g) {\n        e(32, !1, void 0, {\n          \"Highcharts.inArray\": \"use Array.indexOf\"\n        });\n        return c.indexOf(a, g);\n      },\n      isArray: E,\n      isClass: y,\n      isDOMElement: B,\n      isFunction: function (a) {\n        return \"function\" === typeof a;\n      },\n      isNumber: t,\n      isObject: G,\n      isString: v,\n      keys: function (a) {\n        e(32, !1, void 0, {\n          \"Highcharts.keys\": \"use Object.keys\"\n        });\n        return Object.keys(a);\n      },\n      merge: function () {\n        var a,\n            c = arguments,\n            g = {},\n            k = function (a, c) {\n          \"object\" !== typeof a && (a = {});\n          w(c, function (g, I) {\n            \"__proto__\" !== I && \"constructor\" !== I && (!G(g, !0) || y(g) || B(g) ? a[I] = c[I] : a[I] = k(a[I] || {}, g));\n          });\n          return a;\n        };\n\n        !0 === c[0] && (g = c[1], c = Array.prototype.slice.call(c, 2));\n        var m = c.length;\n\n        for (a = 0; a < m; a++) g = k(g, c[a]);\n\n        return g;\n      },\n      normalizeTickInterval: function (a, c, g, k, m) {\n        var u = a;\n        g = p(g, r(a));\n        var A = a / g;\n        c || (c = m ? [1, 1.2, 1.5, 2, 2.5, 3, 4, 5, 6, 8, 10] : [1, 2, 2.5, 5, 10], !1 === k && (1 === g ? c = c.filter(function (a) {\n          return 0 === a % 1;\n        }) : .1 >= g && (c = [1 / g])));\n\n        for (k = 0; k < c.length && !(u = c[k], m && u * g >= a || !m && A <= (c[k] + (c[k + 1] || c[k])) / 2); k++);\n\n        return u = n(u * g, -Math.round(Math.log(.001) / Math.LN10));\n      },\n      objectEach: w,\n      offset: function (c) {\n        var g = k.documentElement;\n        c = c.parentElement || c.parentNode ? c.getBoundingClientRect() : {\n          top: 0,\n          left: 0,\n          width: 0,\n          height: 0\n        };\n        return {\n          top: c.top + (a.pageYOffset || g.scrollTop) - (g.clientTop || 0),\n          left: c.left + (a.pageXOffset || g.scrollLeft) - (g.clientLeft || 0),\n          width: c.width,\n          height: c.height\n        };\n      },\n      pad: function (a, c, g) {\n        return Array((c || 2) + 1 - String(a).replace(\"-\", \"\").length).join(g || \"0\") + a;\n      },\n      pick: p,\n      pInt: C,\n      relativeLength: function (a, c, g) {\n        return /%$/.test(a) ? c * parseFloat(a) / 100 + (g || 0) : parseFloat(a);\n      },\n      removeEvent: z,\n      splat: function (a) {\n        return E(a) ? a : [a];\n      },\n      stableSort: function (a, c) {\n        var g = a.length,\n            k,\n            u;\n\n        for (u = 0; u < g; u++) a[u].safeI = u;\n\n        a.sort(function (a, g) {\n          k = c(a, g);\n          return 0 === k ? a.safeI - g.safeI : k;\n        });\n\n        for (u = 0; u < g; u++) delete a[u].safeI;\n      },\n      syncTimeout: function (a, c, g) {\n        if (0 < c) return setTimeout(a, c, g);\n        a.call(0, g);\n        return -1;\n      },\n      timeUnits: {\n        millisecond: 1,\n        second: 1E3,\n        minute: 6E4,\n        hour: 36E5,\n        day: 864E5,\n        week: 6048E5,\n        month: 24192E5,\n        year: 314496E5\n      },\n      uniqueKey: D,\n      useSerialIds: function (a) {\n        return c = p(a, c);\n      },\n      wrap: function (a, c, g) {\n        var k = a[c];\n\n        a[c] = function () {\n          var a = Array.prototype.slice.call(arguments),\n              c = arguments,\n              u = this;\n\n          u.proceed = function () {\n            k.apply(u, arguments.length ? arguments : c);\n          };\n\n          a.unshift(k);\n          a = g.apply(this, a);\n          u.proceed = null;\n          return a;\n        };\n      }\n    };\n    \"\";\n    return g;\n  });\n  K(l, \"Core/Chart/ChartDefaults.js\", [], function () {\n    return {\n      alignThresholds: !1,\n      panning: {\n        enabled: !1,\n        type: \"x\"\n      },\n      styledMode: !1,\n      borderRadius: 0,\n      colorCount: 10,\n      allowMutatingData: !0,\n      defaultSeriesType: \"line\",\n      ignoreHiddenSeries: !0,\n      spacing: [10, 10, 15, 10],\n      resetZoomButton: {\n        theme: {\n          zIndex: 6\n        },\n        position: {\n          align: \"right\",\n          x: -10,\n          y: 10\n        }\n      },\n      zoomBySingleTouch: !1,\n      width: null,\n      height: null,\n      borderColor: \"#335cad\",\n      backgroundColor: \"#ffffff\",\n      plotBorderColor: \"#cccccc\"\n    };\n  });\n  K(l, \"Core/Color/Color.js\", [l[\"Core/Globals.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    var l = e.isNumber,\n        C = e.merge,\n        v = e.pInt;\n\n    e = function () {\n      function e(l) {\n        this.rgba = [NaN, NaN, NaN, NaN];\n        this.input = l;\n        var B = f.Color;\n        if (B && B !== e) return new B(l);\n        if (!(this instanceof e)) return new e(l);\n        this.init(l);\n      }\n\n      e.parse = function (f) {\n        return f ? new e(f) : e.None;\n      };\n\n      e.prototype.init = function (f) {\n        var B;\n        if (\"object\" === typeof f && \"undefined\" !== typeof f.stops) this.stops = f.stops.map(function (d) {\n          return new e(d[1]);\n        });else if (\"string\" === typeof f) {\n          this.input = f = e.names[f.toLowerCase()] || f;\n\n          if (\"#\" === f.charAt(0)) {\n            var y = f.length;\n            var t = parseInt(f.substr(1), 16);\n            7 === y ? B = [(t & 16711680) >> 16, (t & 65280) >> 8, t & 255, 1] : 4 === y && (B = [(t & 3840) >> 4 | (t & 3840) >> 8, (t & 240) >> 4 | t & 240, (t & 15) << 4 | t & 15, 1]);\n          }\n\n          if (!B) for (t = e.parsers.length; t-- && !B;) {\n            var h = e.parsers[t];\n            (y = h.regex.exec(f)) && (B = h.parse(y));\n          }\n        }\n        B && (this.rgba = B);\n      };\n\n      e.prototype.get = function (e) {\n        var B = this.input,\n            y = this.rgba;\n\n        if (\"object\" === typeof B && \"undefined\" !== typeof this.stops) {\n          var t = C(B);\n          t.stops = [].slice.call(t.stops);\n          this.stops.forEach(function (h, d) {\n            t.stops[d] = [t.stops[d][0], h.get(e)];\n          });\n          return t;\n        }\n\n        return y && l(y[0]) ? \"rgb\" === e || !e && 1 === y[3] ? \"rgb(\" + y[0] + \",\" + y[1] + \",\" + y[2] + \")\" : \"a\" === e ? \"\".concat(y[3]) : \"rgba(\" + y.join(\",\") + \")\" : B;\n      };\n\n      e.prototype.brighten = function (e) {\n        var B = this.rgba;\n        if (this.stops) this.stops.forEach(function (t) {\n          t.brighten(e);\n        });else if (l(e) && 0 !== e) for (var y = 0; 3 > y; y++) B[y] += v(255 * e), 0 > B[y] && (B[y] = 0), 255 < B[y] && (B[y] = 255);\n        return this;\n      };\n\n      e.prototype.setOpacity = function (e) {\n        this.rgba[3] = e;\n        return this;\n      };\n\n      e.prototype.tweenTo = function (e, B) {\n        var y = this.rgba,\n            t = e.rgba;\n        if (!l(y[0]) || !l(t[0])) return e.input || \"none\";\n        e = 1 !== t[3] || 1 !== y[3];\n        return (e ? \"rgba(\" : \"rgb(\") + Math.round(t[0] + (y[0] - t[0]) * (1 - B)) + \",\" + Math.round(t[1] + (y[1] - t[1]) * (1 - B)) + \",\" + Math.round(t[2] + (y[2] - t[2]) * (1 - B)) + (e ? \",\" + (t[3] + (y[3] - t[3]) * (1 - B)) : \"\") + \")\";\n      };\n\n      e.names = {\n        white: \"#ffffff\",\n        black: \"#000000\"\n      };\n      e.parsers = [{\n        regex: /rgba\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]?(?:\\.[0-9]+)?)\\s*\\)/,\n        parse: function (e) {\n          return [v(e[1]), v(e[2]), v(e[3]), parseFloat(e[4], 10)];\n        }\n      }, {\n        regex: /rgb\\(\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*,\\s*([0-9]{1,3})\\s*\\)/,\n        parse: function (e) {\n          return [v(e[1]), v(e[2]), v(e[3]), 1];\n        }\n      }];\n      e.None = new e(\"\");\n      return e;\n    }();\n\n    \"\";\n    return e;\n  });\n  K(l, \"Core/Color/Palettes.js\", [], function () {\n    return {\n      colors: \"#7cb5ec #434348 #90ed7d #f7a35c #8085e9 #f15c80 #e4d354 #2b908f #f45b5b #91e8e1\".split(\" \")\n    };\n  });\n  K(l, \"Core/Time.js\", [l[\"Core/Globals.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    var l = f.win,\n        C = e.defined,\n        v = e.error,\n        E = e.extend,\n        G = e.isObject,\n        B = e.merge,\n        y = e.objectEach,\n        t = e.pad,\n        h = e.pick,\n        d = e.splat,\n        b = e.timeUnits,\n        p = f.isSafari && l.Intl && l.Intl.DateTimeFormat.prototype.formatRange,\n        q = f.isSafari && l.Intl && !l.Intl.DateTimeFormat.prototype.formatRange;\n\n    e = function () {\n      function r(n) {\n        this.options = {};\n        this.variableTimezone = this.useUTC = !1;\n        this.Date = l.Date;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.update(n);\n      }\n\n      r.prototype.get = function (n, b) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          var d = b.getTime(),\n              r = d - this.getTimezoneOffset(b);\n          b.setTime(r);\n          n = b[\"getUTC\" + n]();\n          b.setTime(d);\n          return n;\n        }\n\n        return this.useUTC ? b[\"getUTC\" + n]() : b[\"get\" + n]();\n      };\n\n      r.prototype.set = function (n, b, d) {\n        if (this.variableTimezone || this.timezoneOffset) {\n          if (\"Milliseconds\" === n || \"Seconds\" === n || \"Minutes\" === n && 0 === this.getTimezoneOffset(b) % 36E5) return b[\"setUTC\" + n](d);\n          var r = this.getTimezoneOffset(b);\n          r = b.getTime() - r;\n          b.setTime(r);\n          b[\"setUTC\" + n](d);\n          n = this.getTimezoneOffset(b);\n          r = b.getTime() + n;\n          return b.setTime(r);\n        }\n\n        return this.useUTC || p && \"FullYear\" === n ? b[\"setUTC\" + n](d) : b[\"set\" + n](d);\n      };\n\n      r.prototype.update = function (b) {\n        var n = h(b && b.useUTC, !0);\n        this.options = b = B(!0, this.options || {}, b);\n        this.Date = b.Date || l.Date || Date;\n        this.timezoneOffset = (this.useUTC = n) && b.timezoneOffset || void 0;\n        this.getTimezoneOffset = this.timezoneOffsetFunction();\n        this.variableTimezone = n && !(!b.getTimezoneOffset && !b.timezone);\n      };\n\n      r.prototype.makeTime = function (b, d, r, p, x, m) {\n        if (this.useUTC) {\n          var k = this.Date.UTC.apply(0, arguments);\n          var a = this.getTimezoneOffset(k);\n          k += a;\n          var g = this.getTimezoneOffset(k);\n          a !== g ? k += g - a : a - 36E5 !== this.getTimezoneOffset(k - 36E5) || q || (k -= 36E5);\n        } else k = new this.Date(b, d, h(r, 1), h(p, 0), h(x, 0), h(m, 0)).getTime();\n\n        return k;\n      };\n\n      r.prototype.timezoneOffsetFunction = function () {\n        var b = this,\n            d = this.options,\n            r = d.getTimezoneOffset,\n            p = d.moment || l.moment;\n        if (!this.useUTC) return function (b) {\n          return 6E4 * new Date(b.toString()).getTimezoneOffset();\n        };\n\n        if (d.timezone) {\n          if (p) return function (b) {\n            return 6E4 * -p.tz(b, d.timezone).utcOffset();\n          };\n          v(25);\n        }\n\n        return this.useUTC && r ? function (b) {\n          return 6E4 * r(b.valueOf());\n        } : function () {\n          return 6E4 * (b.timezoneOffset || 0);\n        };\n      };\n\n      r.prototype.dateFormat = function (b, d, r) {\n        if (!C(d) || isNaN(d)) return f.defaultOptions.lang && f.defaultOptions.lang.invalidDate || \"\";\n        b = h(b, \"%Y-%m-%d %H:%M:%S\");\n        var n = this,\n            p = new this.Date(d),\n            m = this.get(\"Hours\", p),\n            k = this.get(\"Day\", p),\n            a = this.get(\"Date\", p),\n            g = this.get(\"Month\", p),\n            c = this.get(\"FullYear\", p),\n            D = f.defaultOptions.lang,\n            A = D && D.weekdays,\n            u = D && D.shortWeekdays;\n        p = E({\n          a: u ? u[k] : A[k].substr(0, 3),\n          A: A[k],\n          d: t(a),\n          e: t(a, 2, \" \"),\n          w: k,\n          b: D.shortMonths[g],\n          B: D.months[g],\n          m: t(g + 1),\n          o: g + 1,\n          y: c.toString().substr(2, 2),\n          Y: c,\n          H: t(m),\n          k: m,\n          I: t(m % 12 || 12),\n          l: m % 12 || 12,\n          M: t(this.get(\"Minutes\", p)),\n          p: 12 > m ? \"AM\" : \"PM\",\n          P: 12 > m ? \"am\" : \"pm\",\n          S: t(p.getSeconds()),\n          L: t(Math.floor(d % 1E3), 3)\n        }, f.dateFormats);\n        y(p, function (a, c) {\n          for (; -1 !== b.indexOf(\"%\" + c);) b = b.replace(\"%\" + c, \"function\" === typeof a ? a.call(n, d) : a);\n        });\n        return r ? b.substr(0, 1).toUpperCase() + b.substr(1) : b;\n      };\n\n      r.prototype.resolveDTLFormat = function (b) {\n        return G(b, !0) ? b : (b = d(b), {\n          main: b[0],\n          from: b[1],\n          to: b[2]\n        });\n      };\n\n      r.prototype.getTimeTicks = function (d, r, p, q) {\n        var n = this,\n            m = [],\n            k = {},\n            a = new n.Date(r),\n            g = d.unitRange,\n            c = d.count || 1,\n            D;\n        q = h(q, 1);\n\n        if (C(r)) {\n          n.set(\"Milliseconds\", a, g >= b.second ? 0 : c * Math.floor(n.get(\"Milliseconds\", a) / c));\n          g >= b.second && n.set(\"Seconds\", a, g >= b.minute ? 0 : c * Math.floor(n.get(\"Seconds\", a) / c));\n          g >= b.minute && n.set(\"Minutes\", a, g >= b.hour ? 0 : c * Math.floor(n.get(\"Minutes\", a) / c));\n          g >= b.hour && n.set(\"Hours\", a, g >= b.day ? 0 : c * Math.floor(n.get(\"Hours\", a) / c));\n          g >= b.day && n.set(\"Date\", a, g >= b.month ? 1 : Math.max(1, c * Math.floor(n.get(\"Date\", a) / c)));\n\n          if (g >= b.month) {\n            n.set(\"Month\", a, g >= b.year ? 0 : c * Math.floor(n.get(\"Month\", a) / c));\n            var A = n.get(\"FullYear\", a);\n          }\n\n          g >= b.year && n.set(\"FullYear\", a, A - A % c);\n          g === b.week && (A = n.get(\"Day\", a), n.set(\"Date\", a, n.get(\"Date\", a) - A + q + (A < q ? -7 : 0)));\n          A = n.get(\"FullYear\", a);\n          q = n.get(\"Month\", a);\n          var u = n.get(\"Date\", a),\n              z = n.get(\"Hours\", a);\n          r = a.getTime();\n          !n.variableTimezone && n.useUTC || !C(p) || (D = p - r > 4 * b.month || n.getTimezoneOffset(r) !== n.getTimezoneOffset(p));\n          r = a.getTime();\n\n          for (a = 1; r < p;) m.push(r), r = g === b.year ? n.makeTime(A + a * c, 0) : g === b.month ? n.makeTime(A, q + a * c) : !D || g !== b.day && g !== b.week ? D && g === b.hour && 1 < c ? n.makeTime(A, q, u, z + a * c) : r + g * c : n.makeTime(A, q, u + a * c * (g === b.day ? 1 : 7)), a++;\n\n          m.push(r);\n          g <= b.hour && 1E4 > m.length && m.forEach(function (a) {\n            0 === a % 18E5 && \"000000000\" === n.dateFormat(\"%H%M%S%L\", a) && (k[a] = \"day\");\n          });\n        }\n\n        m.info = E(d, {\n          higherRanks: k,\n          totalRange: g * c\n        });\n        return m;\n      };\n\n      r.prototype.getDateFormat = function (n, d, r, p) {\n        var q = this.dateFormat(\"%m-%d %H:%M:%S.%L\", d),\n            m = {\n          millisecond: 15,\n          second: 12,\n          minute: 9,\n          hour: 6,\n          day: 3\n        },\n            k = \"millisecond\";\n\n        for (a in b) {\n          if (n === b.week && +this.dateFormat(\"%w\", d) === r && \"00:00:00.000\" === q.substr(6)) {\n            var a = \"week\";\n            break;\n          }\n\n          if (b[a] > n) {\n            a = k;\n            break;\n          }\n\n          if (m[a] && q.substr(m[a]) !== \"01-01 00:00:00.000\".substr(m[a])) break;\n          \"week\" !== a && (k = a);\n        }\n\n        return this.resolveDTLFormat(p[a]).main;\n      };\n\n      return r;\n    }();\n\n    \"\";\n    return e;\n  });\n  K(l, \"Core/DefaultOptions.js\", [l[\"Core/Chart/ChartDefaults.js\"], l[\"Core/Color/Color.js\"], l[\"Core/Globals.js\"], l[\"Core/Color/Palettes.js\"], l[\"Core/Time.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E) {\n    e = e.parse;\n    var P = E.merge,\n        B = {\n      colors: C.colors,\n      symbols: [\"circle\", \"diamond\", \"square\", \"triangle\", \"triangle-down\"],\n      lang: {\n        loading: \"Loading...\",\n        months: \"January February March April May June July August September October November December\".split(\" \"),\n        shortMonths: \"Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split(\" \"),\n        weekdays: \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"),\n        decimalPoint: \".\",\n        numericSymbols: \"kMGTPE\".split(\"\"),\n        resetZoom: \"Reset zoom\",\n        resetZoomTitle: \"Reset zoom level 1:1\",\n        thousandsSep: \" \"\n      },\n      global: {},\n      time: {\n        Date: void 0,\n        getTimezoneOffset: void 0,\n        timezone: void 0,\n        timezoneOffset: 0,\n        useUTC: !0\n      },\n      chart: f,\n      title: {\n        text: \"Chart title\",\n        align: \"center\",\n        margin: 15,\n        widthAdjust: -44\n      },\n      subtitle: {\n        text: \"\",\n        align: \"center\",\n        widthAdjust: -44\n      },\n      caption: {\n        margin: 15,\n        text: \"\",\n        align: \"left\",\n        verticalAlign: \"bottom\"\n      },\n      plotOptions: {},\n      labels: {\n        style: {\n          position: \"absolute\",\n          color: \"#333333\"\n        }\n      },\n      legend: {\n        enabled: !0,\n        align: \"center\",\n        alignColumns: !0,\n        className: \"highcharts-no-tooltip\",\n        layout: \"horizontal\",\n        labelFormatter: function () {\n          return this.name;\n        },\n        borderColor: \"#999999\",\n        borderRadius: 0,\n        navigation: {\n          activeColor: \"#003399\",\n          inactiveColor: \"#cccccc\"\n        },\n        itemStyle: {\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontSize: \"12px\",\n          fontWeight: \"bold\",\n          textOverflow: \"ellipsis\"\n        },\n        itemHoverStyle: {\n          color: \"#000000\"\n        },\n        itemHiddenStyle: {\n          color: \"#cccccc\"\n        },\n        shadow: !1,\n        itemCheckboxStyle: {\n          position: \"absolute\",\n          width: \"13px\",\n          height: \"13px\"\n        },\n        squareSymbol: !0,\n        symbolPadding: 5,\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0,\n        title: {\n          style: {\n            fontWeight: \"bold\"\n          }\n        }\n      },\n      loading: {\n        labelStyle: {\n          fontWeight: \"bold\",\n          position: \"relative\",\n          top: \"45%\"\n        },\n        style: {\n          position: \"absolute\",\n          backgroundColor: \"#ffffff\",\n          opacity: .5,\n          textAlign: \"center\"\n        }\n      },\n      tooltip: {\n        enabled: !0,\n        animation: l.svg,\n        borderRadius: 3,\n        dateTimeLabelFormats: {\n          millisecond: \"%A, %b %e, %H:%M:%S.%L\",\n          second: \"%A, %b %e, %H:%M:%S\",\n          minute: \"%A, %b %e, %H:%M\",\n          hour: \"%A, %b %e, %H:%M\",\n          day: \"%A, %b %e, %Y\",\n          week: \"Week from %A, %b %e, %Y\",\n          month: \"%B %Y\",\n          year: \"%Y\"\n        },\n        footerFormat: \"\",\n        headerShape: \"callout\",\n        hideDelay: 500,\n        padding: 8,\n        shape: \"callout\",\n        shared: !1,\n        snap: l.isTouchDevice ? 25 : 10,\n        headerFormat: '<span style=\"font-size: 10px\">{point.key}</span><br/>',\n        pointFormat: '<span style=\"color:{point.color}\">\\u25cf</span> {series.name}: <b>{point.y}</b><br/>',\n        backgroundColor: e(\"#f7f7f7\").setOpacity(.85).get(),\n        borderWidth: 1,\n        shadow: !0,\n        stickOnContact: !1,\n        style: {\n          color: \"#333333\",\n          cursor: \"default\",\n          fontSize: \"12px\",\n          whiteSpace: \"nowrap\"\n        },\n        useHTML: !1\n      },\n      credits: {\n        enabled: !0,\n        href: \"https://www.highcharts.com?credits\",\n        position: {\n          align: \"right\",\n          x: -10,\n          verticalAlign: \"bottom\",\n          y: -5\n        },\n        style: {\n          cursor: \"pointer\",\n          color: \"#999999\",\n          fontSize: \"9px\"\n        },\n        text: \"Highcharts.com\"\n      }\n    };\n    B.chart.styledMode = !1;\n    \"\";\n    var y = new v(P(B.global, B.time));\n    f = {\n      defaultOptions: B,\n      defaultTime: y,\n      getOptions: function () {\n        return B;\n      },\n      setOptions: function (t) {\n        P(!0, B, t);\n        if (t.time || t.global) l.time ? l.time.update(P(B.global, B.time, t.global, t.time)) : l.time = y;\n        return B;\n      }\n    };\n    \"\";\n    return f;\n  });\n  K(l, \"Core/Animation/Fx.js\", [l[\"Core/Color/Color.js\"], l[\"Core/Globals.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var P = f.parse,\n        v = e.win,\n        E = l.isNumber,\n        G = l.objectEach;\n    return function () {\n      function e(e, t, h) {\n        this.pos = NaN;\n        this.options = t;\n        this.elem = e;\n        this.prop = h;\n      }\n\n      e.prototype.dSetter = function () {\n        var e = this.paths,\n            t = e && e[0];\n        e = e && e[1];\n        var h = this.now || 0,\n            d = [];\n        if (1 !== h && t && e) {\n          if (t.length === e.length && 1 > h) for (var b = 0; b < e.length; b++) {\n            for (var p = t[b], q = e[b], r = [], n = 0; n < q.length; n++) {\n              var J = p[n],\n                  w = q[n];\n              E(J) && E(w) && (\"A\" !== q[0] || 4 !== n && 5 !== n) ? r[n] = J + h * (w - J) : r[n] = w;\n            }\n\n            d.push(r);\n          } else d = e;\n        } else d = this.toD || [];\n        this.elem.attr(\"d\", d, void 0, !0);\n      };\n\n      e.prototype.update = function () {\n        var e = this.elem,\n            t = this.prop,\n            h = this.now,\n            d = this.options.step;\n        if (this[t + \"Setter\"]) this[t + \"Setter\"]();else e.attr ? e.element && e.attr(t, h, null, !0) : e.style[t] = h + this.unit;\n        d && d.call(e, h, this);\n      };\n\n      e.prototype.run = function (y, t, h) {\n        var d = this,\n            b = d.options,\n            p = function (b) {\n          return p.stopped ? !1 : d.step(b);\n        },\n            q = v.requestAnimationFrame || function (b) {\n          setTimeout(b, 13);\n        },\n            r = function () {\n          for (var b = 0; b < e.timers.length; b++) e.timers[b]() || e.timers.splice(b--, 1);\n\n          e.timers.length && q(r);\n        };\n\n        y !== t || this.elem[\"forceAnimate:\" + this.prop] ? (this.startTime = +new Date(), this.start = y, this.end = t, this.unit = h, this.now = this.start, this.pos = 0, p.elem = this.elem, p.prop = this.prop, p() && 1 === e.timers.push(p) && q(r)) : (delete b.curAnim[this.prop], b.complete && 0 === Object.keys(b.curAnim).length && b.complete.call(this.elem));\n      };\n\n      e.prototype.step = function (e) {\n        var t = +new Date(),\n            h = this.options,\n            d = this.elem,\n            b = h.complete,\n            p = h.duration,\n            q = h.curAnim;\n        if (d.attr && !d.element) e = !1;else if (e || t >= p + this.startTime) {\n          this.now = this.end;\n          this.pos = 1;\n          this.update();\n          var r = q[this.prop] = !0;\n          G(q, function (b) {\n            !0 !== b && (r = !1);\n          });\n          r && b && b.call(d);\n          e = !1;\n        } else this.pos = h.easing((t - this.startTime) / p), this.now = this.start + (this.end - this.start) * this.pos, this.update(), e = !0;\n        return e;\n      };\n\n      e.prototype.initPath = function (e, t, h) {\n        function d(b, m) {\n          for (; b.length < z;) {\n            var k = b[0],\n                a = m[z - b.length];\n            a && \"M\" === k[0] && (b[0] = \"C\" === a[0] ? [\"C\", k[1], k[2], k[1], k[2], k[1], k[2]] : [\"L\", k[1], k[2]]);\n            b.unshift(k);\n            r && (k = b.pop(), b.push(b[b.length - 1], k));\n          }\n        }\n\n        function b(b, m) {\n          for (; b.length < z;) if (m = b[Math.floor(b.length / n) - 1].slice(), \"C\" === m[0] && (m[1] = m[5], m[2] = m[6]), r) {\n            var k = b[Math.floor(b.length / n)].slice();\n            b.splice(b.length / 2, 0, m, k);\n          } else b.push(m);\n        }\n\n        var p = e.startX,\n            q = e.endX;\n        h = h.slice();\n        var r = e.isArea,\n            n = r ? 2 : 1;\n        t = t && t.slice();\n        if (!t) return [h, h];\n\n        if (p && q && q.length) {\n          for (e = 0; e < p.length; e++) if (p[e] === q[0]) {\n            var J = e;\n            break;\n          } else if (p[0] === q[q.length - p.length + e]) {\n            J = e;\n            var w = !0;\n            break;\n          } else if (p[p.length - 1] === q[q.length - p.length + e]) {\n            J = p.length - e;\n            break;\n          }\n\n          \"undefined\" === typeof J && (t = []);\n        }\n\n        if (t.length && E(J)) {\n          var z = h.length + J * n;\n          w ? (d(t, h), b(h, t)) : (d(h, t), b(t, h));\n        }\n\n        return [t, h];\n      };\n\n      e.prototype.fillSetter = function () {\n        e.prototype.strokeSetter.apply(this, arguments);\n      };\n\n      e.prototype.strokeSetter = function () {\n        this.elem.attr(this.prop, P(this.start).tweenTo(P(this.end), this.pos), void 0, !0);\n      };\n\n      e.timers = [];\n      return e;\n    }();\n  });\n  K(l, \"Core/Animation/AnimationUtilities.js\", [l[\"Core/Animation/Fx.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    function l(b) {\n      return y(b) ? t({\n        duration: 500,\n        defer: 0\n      }, b) : {\n        duration: b ? 500 : 0,\n        defer: 0\n      };\n    }\n\n    function C(b, d) {\n      for (var p = f.timers.length; p--;) f.timers[p].elem !== b || d && d !== f.timers[p].prop || (f.timers[p].stopped = !0);\n    }\n\n    var v = e.defined,\n        E = e.getStyle,\n        G = e.isArray,\n        B = e.isNumber,\n        y = e.isObject,\n        t = e.merge,\n        h = e.objectEach,\n        d = e.pick;\n    return {\n      animate: function (b, d, q) {\n        var r,\n            n = \"\",\n            p,\n            w;\n\n        if (!y(q)) {\n          var z = arguments;\n          q = {\n            duration: z[2],\n            easing: z[3],\n            complete: z[4]\n          };\n        }\n\n        B(q.duration) || (q.duration = 400);\n        q.easing = \"function\" === typeof q.easing ? q.easing : Math[q.easing] || Math.easeInOutSine;\n        q.curAnim = t(d);\n        h(d, function (h, m) {\n          C(b, m);\n          w = new f(b, q, m);\n          p = void 0;\n          \"d\" === m && G(d.d) ? (w.paths = w.initPath(b, b.pathArray, d.d), w.toD = d.d, r = 0, p = 1) : b.attr ? r = b.attr(m) : (r = parseFloat(E(b, m)) || 0, \"opacity\" !== m && (n = \"px\"));\n          p || (p = h);\n          \"string\" === typeof p && p.match(\"px\") && (p = p.replace(/px/g, \"\"));\n          w.run(r, p, n);\n        });\n      },\n      animObject: l,\n      getDeferredAnimation: function (b, d, q) {\n        var r = l(d),\n            n = 0,\n            p = 0;\n        (q ? [q] : b.series).forEach(function (b) {\n          b = l(b.options.animation);\n          n = d && v(d.defer) ? r.defer : Math.max(n, b.duration + b.defer);\n          p = Math.min(r.duration, b.duration);\n        });\n        b.renderer.forExport && (n = 0);\n        return {\n          defer: Math.max(0, n - p),\n          duration: Math.min(n, p)\n        };\n      },\n      setAnimation: function (b, p) {\n        p.renderer.globalAnimation = d(b, p.options.chart.animation, !0);\n      },\n      stop: C\n    };\n  });\n  K(l, \"Core/Renderer/HTML/AST.js\", [l[\"Core/Globals.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    var l = f.SVG_NS,\n        C = e.attr,\n        v = e.createElement,\n        E = e.css,\n        G = e.error,\n        B = e.isFunction,\n        y = e.isString,\n        t = e.objectEach,\n        h = e.splat,\n        d = (e = f.win.trustedTypes) && B(e.createPolicy) && e.createPolicy(\"highcharts\", {\n      createHTML: function (b) {\n        return b;\n      }\n    }),\n        b = d ? d.createHTML(\"\") : \"\";\n\n    try {\n      var p = !!new DOMParser().parseFromString(b, \"text/html\");\n    } catch (q) {\n      p = !1;\n    }\n\n    B = function () {\n      function q(b) {\n        this.nodes = \"string\" === typeof b ? this.parseMarkup(b) : b;\n      }\n\n      q.filterUserAttributes = function (b) {\n        t(b, function (d, p) {\n          var n = !0;\n          -1 === q.allowedAttributes.indexOf(p) && (n = !1);\n          -1 !== [\"background\", \"dynsrc\", \"href\", \"lowsrc\", \"src\"].indexOf(p) && (n = y(d) && q.allowedReferences.some(function (b) {\n            return 0 === d.indexOf(b);\n          }));\n          n || (G(33, !1, void 0, {\n            \"Invalid attribute in config\": \"\".concat(p)\n          }), delete b[p]);\n        });\n        return b;\n      };\n\n      q.parseStyle = function (b) {\n        return b.split(\";\").reduce(function (b, d) {\n          d = d.split(\":\").map(function (b) {\n            return b.trim();\n          });\n          var p = d.shift();\n          p && d.length && (b[p.replace(/-([a-z])/g, function (b) {\n            return b[1].toUpperCase();\n          })] = d.join(\":\"));\n          return b;\n        }, {});\n      };\n\n      q.setElementHTML = function (b, d) {\n        b.innerHTML = q.emptyHTML;\n        d && new q(d).addToDOM(b);\n      };\n\n      q.prototype.addToDOM = function (b) {\n        function d(b, p) {\n          var n;\n          h(b).forEach(function (b) {\n            var m = b.tagName,\n                k = b.textContent ? f.doc.createTextNode(b.textContent) : void 0,\n                a = q.bypassHTMLFiltering;\n            if (m) if (\"#text\" === m) var g = k;else if (-1 !== q.allowedTags.indexOf(m) || a) {\n              m = f.doc.createElementNS(\"svg\" === m ? l : p.namespaceURI || l, m);\n              var c = b.attributes || {};\n              t(b, function (a, g) {\n                \"tagName\" !== g && \"attributes\" !== g && \"children\" !== g && \"style\" !== g && \"textContent\" !== g && (c[g] = a);\n              });\n              C(m, a ? c : q.filterUserAttributes(c));\n              b.style && E(m, b.style);\n              k && m.appendChild(k);\n              d(b.children || [], m);\n              g = m;\n            } else G(33, !1, void 0, {\n              \"Invalid tagName in config\": m\n            });\n            g && p.appendChild(g);\n            n = g;\n          });\n          return n;\n        }\n\n        return d(this.nodes, b);\n      };\n\n      q.prototype.parseMarkup = function (b) {\n        var n = [];\n        b = b.trim().replace(/ style=\"/g, ' data-style=\"');\n        if (p) b = new DOMParser().parseFromString(d ? d.createHTML(b) : b, \"text/html\");else {\n          var r = v(\"div\");\n          r.innerHTML = b;\n          b = {\n            body: r\n          };\n        }\n\n        var h = function (b, d) {\n          var m = b.nodeName.toLowerCase(),\n              k = {\n            tagName: m\n          };\n          \"#text\" === m && (k.textContent = b.textContent || \"\");\n\n          if (m = b.attributes) {\n            var a = {};\n            [].forEach.call(m, function (c) {\n              \"data-style\" === c.name ? k.style = q.parseStyle(c.value) : a[c.name] = c.value;\n            });\n            k.attributes = a;\n          }\n\n          if (b.childNodes.length) {\n            var g = [];\n            [].forEach.call(b.childNodes, function (a) {\n              h(a, g);\n            });\n            g.length && (k.children = g);\n          }\n\n          d.push(k);\n        };\n\n        [].forEach.call(b.body.childNodes, function (b) {\n          return h(b, n);\n        });\n        return n;\n      };\n\n      q.allowedAttributes = \"aria-controls aria-describedby aria-expanded aria-haspopup aria-hidden aria-label aria-labelledby aria-live aria-pressed aria-readonly aria-roledescription aria-selected class clip-path color colspan cx cy d dx dy disabled fill height href id in markerHeight markerWidth offset opacity orient padding paddingLeft paddingRight patternUnits r refX refY role scope slope src startOffset stdDeviation stroke stroke-linecap stroke-width style tableValues result rowspan summary target tabindex text-align textAnchor textLength title type valign width x x1 x2 y y1 y2 zIndex\".split(\" \");\n      q.allowedReferences = \"https:// http:// mailto: / ../ ./ #\".split(\" \");\n      q.allowedTags = \"a abbr b br button caption circle clipPath code dd defs div dl dt em feComponentTransfer feFuncA feFuncB feFuncG feFuncR feGaussianBlur feOffset feMerge feMergeNode filter h1 h2 h3 h4 h5 h6 hr i img li linearGradient marker ol p path pattern pre rect small span stop strong style sub sup svg table text thead tbody tspan td th tr u ul #text\".split(\" \");\n      q.emptyHTML = b;\n      q.bypassHTMLFiltering = !1;\n      return q;\n    }();\n\n    \"\";\n    return B;\n  });\n  K(l, \"Core/FormatUtilities.js\", [l[\"Core/DefaultOptions.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    function l(e, h, d, b) {\n      e = +e || 0;\n      h = +h;\n      var p = C.lang,\n          q = (e.toString().split(\".\")[1] || \"\").split(\"e\")[0].length,\n          r = e.toString().split(\"e\"),\n          n = h;\n      if (-1 === h) h = Math.min(q, 20);else if (!G(h)) h = 2;else if (h && r[1] && 0 > r[1]) {\n        var J = h + +r[1];\n        0 <= J ? (r[0] = (+r[0]).toExponential(J).split(\"e\")[0], h = J) : (r[0] = r[0].split(\".\")[0] || 0, e = 20 > h ? (r[0] * Math.pow(10, r[1])).toFixed(h) : 0, r[1] = 0);\n      }\n      J = (Math.abs(r[1] ? r[0] : e) + Math.pow(10, -Math.max(h, q) - 1)).toFixed(h);\n      q = String(y(J));\n      var w = 3 < q.length ? q.length % 3 : 0;\n      d = B(d, p.decimalPoint);\n      b = B(b, p.thousandsSep);\n      e = (0 > e ? \"-\" : \"\") + (w ? q.substr(0, w) + b : \"\");\n      e = 0 > +r[1] && !n ? \"0\" : e + q.substr(w).replace(/(\\d{3})(?=\\d)/g, \"$1\" + b);\n      h && (e += d + J.slice(-h));\n      r[1] && 0 !== +e && (e += \"e\" + r[1]);\n      return e;\n    }\n\n    var C = f.defaultOptions,\n        v = f.defaultTime,\n        E = e.getNestedProperty,\n        G = e.isNumber,\n        B = e.pick,\n        y = e.pInt;\n    return {\n      dateFormat: function (e, h, d) {\n        return v.dateFormat(e, h, d);\n      },\n      format: function (e, h, d) {\n        var b = \"{\",\n            p = !1,\n            q = /f$/,\n            r = /\\.([0-9])/,\n            n = C.lang,\n            J = d && d.time || v;\n        d = d && d.numberFormatter || l;\n\n        for (var w = []; e;) {\n          var z = e.indexOf(b);\n          if (-1 === z) break;\n          var x = e.slice(0, z);\n\n          if (p) {\n            x = x.split(\":\");\n            b = E(x.shift() || \"\", h);\n            if (x.length && \"number\" === typeof b) if (x = x.join(\":\"), q.test(x)) {\n              var m = parseInt((x.match(r) || [\"\", \"-1\"])[1], 10);\n              null !== b && (b = d(b, m, n.decimalPoint, -1 < x.indexOf(\",\") ? n.thousandsSep : \"\"));\n            } else b = J.dateFormat(x, b);\n            w.push(b);\n          } else w.push(x);\n\n          e = e.slice(z + 1);\n          b = (p = !p) ? \"}\" : \"{\";\n        }\n\n        w.push(e);\n        return w.join(\"\");\n      },\n      numberFormat: l\n    };\n  });\n  K(l, \"Core/Renderer/RendererUtilities.js\", [l[\"Core/Utilities.js\"]], function (f) {\n    var e = f.clamp,\n        l = f.pick,\n        C = f.stableSort,\n        v;\n\n    (function (f) {\n      function v(f, y, t) {\n        var h = f,\n            d = h.reducedLen || y,\n            b = function (b, d) {\n          return (d.rank || 0) - (b.rank || 0);\n        },\n            p = function (b, d) {\n          return b.target - d.target;\n        },\n            q,\n            r = !0,\n            n = [],\n            J = 0;\n\n        for (q = f.length; q--;) J += f[q].size;\n\n        if (J > d) {\n          C(f, b);\n\n          for (J = q = 0; J <= d;) J += f[q].size, q++;\n\n          n = f.splice(q - 1, f.length);\n        }\n\n        C(f, p);\n\n        for (f = f.map(function (b) {\n          return {\n            size: b.size,\n            targets: [b.target],\n            align: l(b.align, .5)\n          };\n        }); r;) {\n          for (q = f.length; q--;) d = f[q], b = (Math.min.apply(0, d.targets) + Math.max.apply(0, d.targets)) / 2, d.pos = e(b - d.size * d.align, 0, y - d.size);\n\n          q = f.length;\n\n          for (r = !1; q--;) 0 < q && f[q - 1].pos + f[q - 1].size > f[q].pos && (f[q - 1].size += f[q].size, f[q - 1].targets = f[q - 1].targets.concat(f[q].targets), f[q - 1].align = .5, f[q - 1].pos + f[q - 1].size > y && (f[q - 1].pos = y - f[q - 1].size), f.splice(q, 1), r = !0);\n        }\n\n        h.push.apply(h, n);\n        q = 0;\n        f.some(function (b) {\n          var d = 0;\n          return (b.targets || []).some(function () {\n            h[q].pos = b.pos + d;\n            if (\"undefined\" !== typeof t && Math.abs(h[q].pos - h[q].target) > t) return h.slice(0, q + 1).forEach(function (b) {\n              return delete b.pos;\n            }), h.reducedLen = (h.reducedLen || y) - .1 * y, h.reducedLen > .1 * y && v(h, y, t), !0;\n            d += h[q].size;\n            q++;\n            return !1;\n          });\n        });\n        C(h, p);\n        return h;\n      }\n\n      f.distribute = v;\n    })(v || (v = {}));\n\n    return v;\n  });\n  K(l, \"Core/Renderer/SVG/SVGElement.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/Renderer/HTML/AST.js\"], l[\"Core/Color/Color.js\"], l[\"Core/Globals.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v) {\n    var P = f.animate,\n        G = f.animObject,\n        B = f.stop,\n        y = C.deg2rad,\n        t = C.doc,\n        h = C.noop,\n        d = C.svg,\n        b = C.SVG_NS,\n        p = C.win,\n        q = v.addEvent,\n        r = v.attr,\n        n = v.createElement,\n        J = v.css,\n        w = v.defined,\n        z = v.erase,\n        x = v.extend,\n        m = v.fireEvent,\n        k = v.isArray,\n        a = v.isFunction,\n        g = v.isNumber,\n        c = v.isString,\n        D = v.merge,\n        A = v.objectEach,\n        u = v.pick,\n        L = v.pInt,\n        S = v.syncTimeout,\n        R = v.uniqueKey;\n\n    f = function () {\n      function f() {\n        this.element = void 0;\n        this.onEvents = {};\n        this.opacity = 1;\n        this.renderer = void 0;\n        this.SVG_NS = b;\n        this.symbolCustomAttribs = \"x y width height r start end innerR anchorX anchorY rounded\".split(\" \");\n      }\n\n      f.prototype._defaultGetter = function (a) {\n        a = u(this[a + \"Value\"], this[a], this.element ? this.element.getAttribute(a) : null, 0);\n        /^[\\-0-9\\.]+$/.test(a) && (a = parseFloat(a));\n        return a;\n      };\n\n      f.prototype._defaultSetter = function (a, c, g) {\n        g.setAttribute(c, a);\n      };\n\n      f.prototype.add = function (a) {\n        var c = this.renderer,\n            g = this.element;\n        a && (this.parentGroup = a);\n        this.parentInverted = a && a.inverted;\n        \"undefined\" !== typeof this.textStr && \"text\" === this.element.nodeName && c.buildText(this);\n        this.added = !0;\n        if (!a || a.handleZ || this.zIndex) var b = this.zIndexSetter();\n        b || (a ? a.element : c.box).appendChild(g);\n        if (this.onAdd) this.onAdd();\n        return this;\n      };\n\n      f.prototype.addClass = function (a, c) {\n        var g = c ? \"\" : this.attr(\"class\") || \"\";\n        a = (a || \"\").split(/ /g).reduce(function (a, c) {\n          -1 === g.indexOf(c) && a.push(c);\n          return a;\n        }, g ? [g] : []).join(\" \");\n        a !== g && this.attr(\"class\", a);\n        return this;\n      };\n\n      f.prototype.afterSetters = function () {\n        this.doTransform && (this.updateTransform(), this.doTransform = !1);\n      };\n\n      f.prototype.align = function (a, g, I) {\n        var b = {},\n            k = this.renderer,\n            m = k.alignedObjects,\n            d,\n            p,\n            F;\n\n        if (a) {\n          if (this.alignOptions = a, this.alignByTranslate = g, !I || c(I)) this.alignTo = d = I || \"renderer\", z(m, this), m.push(this), I = void 0;\n        } else a = this.alignOptions, g = this.alignByTranslate, d = this.alignTo;\n\n        I = u(I, k[d], \"scrollablePlotBox\" === d ? k.plotBox : void 0, k);\n        d = a.align;\n        var A = a.verticalAlign;\n        k = (I.x || 0) + (a.x || 0);\n        m = (I.y || 0) + (a.y || 0);\n        \"right\" === d ? p = 1 : \"center\" === d && (p = 2);\n        p && (k += (I.width - (a.width || 0)) / p);\n        b[g ? \"translateX\" : \"x\"] = Math.round(k);\n        \"bottom\" === A ? F = 1 : \"middle\" === A && (F = 2);\n        F && (m += (I.height - (a.height || 0)) / F);\n        b[g ? \"translateY\" : \"y\"] = Math.round(m);\n        this[this.placed ? \"animate\" : \"attr\"](b);\n        this.placed = !0;\n        this.alignAttr = b;\n        return this;\n      };\n\n      f.prototype.alignSetter = function (a) {\n        var c = {\n          left: \"start\",\n          center: \"middle\",\n          right: \"end\"\n        };\n        c[a] && (this.alignValue = a, this.element.setAttribute(\"text-anchor\", c[a]));\n      };\n\n      f.prototype.animate = function (a, c, g) {\n        var I = this,\n            b = G(u(c, this.renderer.globalAnimation, !0));\n        c = b.defer;\n        u(t.hidden, t.msHidden, t.webkitHidden, !1) && (b.duration = 0);\n        0 !== b.duration ? (g && (b.complete = g), S(function () {\n          I.element && P(I, a, b);\n        }, c)) : (this.attr(a, void 0, g || b.complete), A(a, function (a, c) {\n          b.step && b.step.call(this, a, {\n            prop: c,\n            pos: 1,\n            elem: this\n          });\n        }, this));\n        return this;\n      };\n\n      f.prototype.applyTextOutline = function (a) {\n        var c = this.element;\n        -1 !== a.indexOf(\"contrast\") && (a = a.replace(/contrast/g, this.renderer.getContrast(c.style.fill)));\n        var g = a.split(\" \");\n        a = g[g.length - 1];\n\n        if ((g = g[0]) && \"none\" !== g && C.svg) {\n          this.fakeTS = !0;\n          this.ySetter = this.xSetter;\n          g = g.replace(/(^[\\d\\.]+)(.*?)$/g, function (a, c, g) {\n            return 2 * Number(c) + g;\n          });\n          this.removeTextOutline();\n          var k = t.createElementNS(b, \"tspan\");\n          r(k, {\n            \"class\": \"highcharts-text-outline\",\n            fill: a,\n            stroke: a,\n            \"stroke-width\": g,\n            \"stroke-linejoin\": \"round\"\n          });\n          [].forEach.call(c.childNodes, function (a) {\n            var c = a.cloneNode(!0);\n            c.removeAttribute && [\"fill\", \"stroke\", \"stroke-width\", \"stroke\"].forEach(function (a) {\n              return c.removeAttribute(a);\n            });\n            k.appendChild(c);\n          });\n          var u = t.createElementNS(b, \"tspan\");\n          u.textContent = \"\\u200b\";\n          [\"x\", \"y\"].forEach(function (a) {\n            var g = c.getAttribute(a);\n            g && u.setAttribute(a, g);\n          });\n          k.appendChild(u);\n          c.insertBefore(k, c.firstChild);\n        }\n      };\n\n      f.prototype.attr = function (a, c, g, b) {\n        var I = this.element,\n            k = this.symbolCustomAttribs,\n            H,\n            u = this,\n            F,\n            m;\n\n        if (\"string\" === typeof a && \"undefined\" !== typeof c) {\n          var d = a;\n          a = {};\n          a[d] = c;\n        }\n\n        \"string\" === typeof a ? u = (this[a + \"Getter\"] || this._defaultGetter).call(this, a, I) : (A(a, function (c, g) {\n          F = !1;\n          b || B(this, g);\n          this.symbolName && -1 !== k.indexOf(g) && (H || (this.symbolAttr(a), H = !0), F = !0);\n          !this.rotation || \"x\" !== g && \"y\" !== g || (this.doTransform = !0);\n          F || (m = this[g + \"Setter\"] || this._defaultSetter, m.call(this, c, g, I), !this.styledMode && this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(g) && this.updateShadows(g, c, m));\n        }, this), this.afterSetters());\n        g && g.call(this);\n        return u;\n      };\n\n      f.prototype.clip = function (a) {\n        return this.attr(\"clip-path\", a ? \"url(\" + this.renderer.url + \"#\" + a.id + \")\" : \"none\");\n      };\n\n      f.prototype.crisp = function (a, c) {\n        c = c || a.strokeWidth || 0;\n        var g = Math.round(c) % 2 / 2;\n        a.x = Math.floor(a.x || this.x || 0) + g;\n        a.y = Math.floor(a.y || this.y || 0) + g;\n        a.width = Math.floor((a.width || this.width || 0) - 2 * g);\n        a.height = Math.floor((a.height || this.height || 0) - 2 * g);\n        w(a.strokeWidth) && (a.strokeWidth = c);\n        return a;\n      };\n\n      f.prototype.complexColor = function (a, c, g) {\n        var b = this.renderer,\n            I,\n            u,\n            d,\n            p,\n            F,\n            n,\n            r,\n            q,\n            h,\n            z,\n            e = [],\n            x;\n        m(this.renderer, \"complexColor\", {\n          args: arguments\n        }, function () {\n          a.radialGradient ? u = \"radialGradient\" : a.linearGradient && (u = \"linearGradient\");\n\n          if (u) {\n            d = a[u];\n            F = b.gradients;\n            n = a.stops;\n            h = g.radialReference;\n            k(d) && (a[u] = d = {\n              x1: d[0],\n              y1: d[1],\n              x2: d[2],\n              y2: d[3],\n              gradientUnits: \"userSpaceOnUse\"\n            });\n            \"radialGradient\" === u && h && !w(d.gradientUnits) && (p = d, d = D(d, b.getRadialAttr(h, p), {\n              gradientUnits: \"userSpaceOnUse\"\n            }));\n            A(d, function (a, c) {\n              \"id\" !== c && e.push(c, a);\n            });\n            A(n, function (a) {\n              e.push(a);\n            });\n            e = e.join(\",\");\n            if (F[e]) z = F[e].attr(\"id\");else {\n              d.id = z = R();\n              var H = F[e] = b.createElement(u).attr(d).add(b.defs);\n              H.radAttr = p;\n              H.stops = [];\n              n.forEach(function (a) {\n                0 === a[1].indexOf(\"rgba\") ? (I = l.parse(a[1]), r = I.get(\"rgb\"), q = I.get(\"a\")) : (r = a[1], q = 1);\n                a = b.createElement(\"stop\").attr({\n                  offset: a[0],\n                  \"stop-color\": r,\n                  \"stop-opacity\": q\n                }).add(H);\n                H.stops.push(a);\n              });\n            }\n            x = \"url(\" + b.url + \"#\" + z + \")\";\n            g.setAttribute(c, x);\n            g.gradient = e;\n\n            a.toString = function () {\n              return x;\n            };\n          }\n        });\n      };\n\n      f.prototype.css = function (a) {\n        var c = this.styles,\n            g = {},\n            b = this.element,\n            k = !c;\n        a.color && (a.fill = a.color);\n        c && A(a, function (a, b) {\n          c && c[b] !== a && (g[b] = a, k = !0);\n        });\n\n        if (k) {\n          c && (a = x(c, g));\n          if (null === a.width || \"auto\" === a.width) delete this.textWidth;else if (\"text\" === b.nodeName.toLowerCase() && a.width) var u = this.textWidth = L(a.width);\n          this.styles = a;\n          u && !d && this.renderer.forExport && delete a.width;\n          var m = D(a);\n          b.namespaceURI === this.SVG_NS && [\"textOutline\", \"textOverflow\", \"width\"].forEach(function (a) {\n            return m && delete m[a];\n          });\n          J(b, m);\n          this.added && (\"text\" === this.element.nodeName && this.renderer.buildText(this), a.textOutline && this.applyTextOutline(a.textOutline));\n        }\n\n        return this;\n      };\n\n      f.prototype.dashstyleSetter = function (a) {\n        var c = this[\"stroke-width\"];\n        \"inherit\" === c && (c = 1);\n\n        if (a = a && a.toLowerCase()) {\n          var g = a.replace(\"shortdashdotdot\", \"3,1,1,1,1,1,\").replace(\"shortdashdot\", \"3,1,1,1\").replace(\"shortdot\", \"1,1,\").replace(\"shortdash\", \"3,1,\").replace(\"longdash\", \"8,3,\").replace(/dot/g, \"1,3,\").replace(\"dash\", \"4,3,\").replace(/,$/, \"\").split(\",\");\n\n          for (a = g.length; a--;) g[a] = \"\" + L(g[a]) * u(c, NaN);\n\n          a = g.join(\",\").replace(/NaN/g, \"none\");\n          this.element.setAttribute(\"stroke-dasharray\", a);\n        }\n      };\n\n      f.prototype.destroy = function () {\n        var a = this,\n            c = a.element || {},\n            g = a.renderer,\n            b = c.ownerSVGElement,\n            k = g.isSVG && \"SPAN\" === c.nodeName && a.parentGroup || void 0;\n        c.onclick = c.onmouseout = c.onmouseover = c.onmousemove = c.point = null;\n        B(a);\n\n        if (a.clipPath && b) {\n          var u = a.clipPath;\n          [].forEach.call(b.querySelectorAll(\"[clip-path],[CLIP-PATH]\"), function (a) {\n            -1 < a.getAttribute(\"clip-path\").indexOf(u.element.id) && a.removeAttribute(\"clip-path\");\n          });\n          a.clipPath = u.destroy();\n        }\n\n        if (a.stops) {\n          for (b = 0; b < a.stops.length; b++) a.stops[b].destroy();\n\n          a.stops.length = 0;\n          a.stops = void 0;\n        }\n\n        a.safeRemoveChild(c);\n\n        for (g.styledMode || a.destroyShadows(); k && k.div && 0 === k.div.childNodes.length;) c = k.parentGroup, a.safeRemoveChild(k.div), delete k.div, k = c;\n\n        a.alignTo && z(g.alignedObjects, a);\n        A(a, function (c, g) {\n          a[g] && a[g].parentGroup === a && a[g].destroy && a[g].destroy();\n          delete a[g];\n        });\n      };\n\n      f.prototype.destroyShadows = function () {\n        (this.shadows || []).forEach(function (a) {\n          this.safeRemoveChild(a);\n        }, this);\n        this.shadows = void 0;\n      };\n\n      f.prototype.destroyTextPath = function (a, c) {\n        var g = a.getElementsByTagName(\"text\")[0];\n\n        if (g) {\n          if (g.removeAttribute(\"dx\"), g.removeAttribute(\"dy\"), c.element.setAttribute(\"id\", \"\"), this.textPathWrapper && g.getElementsByTagName(\"textPath\").length) {\n            for (a = this.textPathWrapper.element.childNodes; a.length;) g.appendChild(a[0]);\n\n            g.removeChild(this.textPathWrapper.element);\n          }\n        } else if (a.getAttribute(\"dx\") || a.getAttribute(\"dy\")) a.removeAttribute(\"dx\"), a.removeAttribute(\"dy\");\n\n        this.textPathWrapper && (this.textPathWrapper = this.textPathWrapper.destroy());\n      };\n\n      f.prototype.dSetter = function (a, c, g) {\n        k(a) && (\"string\" === typeof a[0] && (a = this.renderer.pathToSegments(a)), this.pathArray = a, a = a.reduce(function (a, c, g) {\n          return c && c.join ? (g ? a + \" \" : \"\") + c.join(\" \") : (c || \"\").toString();\n        }, \"\"));\n        /(NaN| {2}|^$)/.test(a) && (a = \"M 0 0\");\n        this[c] !== a && (g.setAttribute(c, a), this[c] = a);\n      };\n\n      f.prototype.fadeOut = function (a) {\n        var c = this;\n        c.animate({\n          opacity: 0\n        }, {\n          duration: u(a, 150),\n          complete: function () {\n            c.hide();\n          }\n        });\n      };\n\n      f.prototype.fillSetter = function (a, c, g) {\n        \"string\" === typeof a ? g.setAttribute(c, a) : a && this.complexColor(a, c, g);\n      };\n\n      f.prototype.getBBox = function (c, g) {\n        var b = this.alignValue,\n            k = this.element,\n            d = this.renderer,\n            m = this.styles,\n            p = this.textStr,\n            A = d.cache,\n            F = d.cacheKeys,\n            n = k.namespaceURI === this.SVG_NS;\n        g = u(g, this.rotation, 0);\n        var r = d.styledMode ? k && f.prototype.getStyle.call(k, \"font-size\") : m && m.fontSize,\n            D;\n\n        if (w(p)) {\n          var q = p.toString();\n          -1 === q.indexOf(\"<\") && (q = q.replace(/[0-9]/g, \"0\"));\n          q += [\"\", g, r, this.textWidth, b, m && m.textOverflow, m && m.fontWeight].join();\n        }\n\n        q && !c && (D = A[q]);\n\n        if (!D) {\n          if (n || d.forExport) {\n            try {\n              var h = this.fakeTS && function (a) {\n                var c = k.querySelector(\".highcharts-text-outline\");\n                c && J(c, {\n                  display: a\n                });\n              };\n\n              a(h) && h(\"none\");\n              D = k.getBBox ? x({}, k.getBBox()) : {\n                width: k.offsetWidth,\n                height: k.offsetHeight\n              };\n              a(h) && h(\"\");\n            } catch (Z) {\n              \"\";\n            }\n\n            if (!D || 0 > D.width) D = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n          } else D = this.htmlGetBBox();\n\n          if (d.isSVG && (d = D.width, c = D.height, n && (D.height = c = {\n            \"11px,17\": 14,\n            \"13px,20\": 16\n          }[\"\" + (r || \"\") + \",\".concat(Math.round(c))] || c), g)) {\n            n = Number(k.getAttribute(\"y\") || 0) - D.y;\n            b = {\n              right: 1,\n              center: .5\n            }[b || 0] || 0;\n            m = g * y;\n            r = (g - 90) * y;\n            var z = d * Math.cos(m);\n            g = d * Math.sin(m);\n            h = Math.cos(r);\n            m = Math.sin(r);\n            d = D.x + b * (d - z) + n * h;\n            r = d + z;\n            h = r - c * h;\n            z = h - z;\n            n = D.y + n - b * g + n * m;\n            b = n + g;\n            c = b - c * m;\n            g = c - g;\n            D.x = Math.min(d, r, h, z);\n            D.y = Math.min(n, b, c, g);\n            D.width = Math.max(d, r, h, z) - D.x;\n            D.height = Math.max(n, b, c, g) - D.y;\n          }\n\n          if (q && (\"\" === p || 0 < D.height)) {\n            for (; 250 < F.length;) delete A[F.shift()];\n\n            A[q] || F.push(q);\n            A[q] = D;\n          }\n        }\n\n        return D;\n      };\n\n      f.prototype.getStyle = function (a) {\n        return p.getComputedStyle(this.element || this, \"\").getPropertyValue(a);\n      };\n\n      f.prototype.hasClass = function (a) {\n        return -1 !== (\"\" + this.attr(\"class\")).split(\" \").indexOf(a);\n      };\n\n      f.prototype.hide = function () {\n        return this.attr({\n          visibility: \"hidden\"\n        });\n      };\n\n      f.prototype.htmlGetBBox = function () {\n        return {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0\n        };\n      };\n\n      f.prototype.init = function (a, c) {\n        this.element = \"span\" === c ? n(c) : t.createElementNS(this.SVG_NS, c);\n        this.renderer = a;\n        m(this, \"afterInit\");\n      };\n\n      f.prototype.invert = function (a) {\n        this.inverted = a;\n        this.updateTransform();\n        return this;\n      };\n\n      f.prototype.on = function (a, c) {\n        var g = this.onEvents;\n        if (g[a]) g[a]();\n        g[a] = q(this.element, a, c);\n        return this;\n      };\n\n      f.prototype.opacitySetter = function (a, c, g) {\n        this.opacity = a = Number(Number(a).toFixed(3));\n        g.setAttribute(c, a);\n      };\n\n      f.prototype.removeClass = function (a) {\n        return this.attr(\"class\", (\"\" + this.attr(\"class\")).replace(c(a) ? new RegExp(\"(^| )\".concat(a, \"( |$)\")) : a, \" \").replace(/ +/g, \" \").trim());\n      };\n\n      f.prototype.removeTextOutline = function () {\n        var a = this.element.querySelector(\"tspan.highcharts-text-outline\");\n        a && this.safeRemoveChild(a);\n      };\n\n      f.prototype.safeRemoveChild = function (a) {\n        var c = a.parentNode;\n        c && c.removeChild(a);\n      };\n\n      f.prototype.setRadialReference = function (a) {\n        var c = this.element.gradient && this.renderer.gradients[this.element.gradient];\n        this.element.radialReference = a;\n        c && c.radAttr && c.animate(this.renderer.getRadialAttr(a, c.radAttr));\n        return this;\n      };\n\n      f.prototype.setTextPath = function (a, c) {\n        var b = this.element,\n            k = this.text ? this.text.element : b,\n            u = {\n          textAnchor: \"text-anchor\"\n        },\n            d = !1,\n            m = this.textPathWrapper,\n            n = !m;\n        c = D(!0, {\n          enabled: !0,\n          attributes: {\n            dy: -5,\n            startOffset: \"50%\",\n            textAnchor: \"middle\"\n          }\n        }, c);\n        var F = e.filterUserAttributes(c.attributes);\n\n        if (a && c && c.enabled) {\n          m && null === m.element.parentNode ? (n = !0, m = m.destroy()) : m && this.removeTextOutline.call(m.parentGroup);\n          this.options && this.options.padding && (F.dx = -this.options.padding);\n          m || (this.textPathWrapper = m = this.renderer.createElement(\"textPath\"), d = !0);\n          var r = m.element;\n          (c = a.element.getAttribute(\"id\")) || a.element.setAttribute(\"id\", c = R());\n          if (n) for (k.setAttribute(\"y\", 0), g(F.dx) && k.setAttribute(\"x\", -F.dx), a = [].slice.call(k.childNodes), n = 0; n < a.length; n++) {\n            var q = a[n];\n            q.nodeType !== p.Node.TEXT_NODE && \"tspan\" !== q.nodeName || r.appendChild(q);\n          }\n          d && m && m.add({\n            element: k\n          });\n          r.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", this.renderer.url + \"#\" + c);\n          w(F.dy) && (r.parentNode.setAttribute(\"dy\", F.dy), delete F.dy);\n          w(F.dx) && (r.parentNode.setAttribute(\"dx\", F.dx), delete F.dx);\n          A(F, function (a, c) {\n            r.setAttribute(u[c] || c, a);\n          });\n          b.removeAttribute(\"transform\");\n          this.removeTextOutline.call(m);\n          this.text && !this.renderer.styledMode && this.attr({\n            fill: \"none\",\n            \"stroke-width\": 0\n          });\n          this.applyTextOutline = this.updateTransform = h;\n        } else m && (delete this.updateTransform, delete this.applyTextOutline, this.destroyTextPath(b, a), this.updateTransform(), this.options && this.options.rotation && this.applyTextOutline(this.options.style.textOutline));\n\n        return this;\n      };\n\n      f.prototype.shadow = function (a, c, g) {\n        var b = [],\n            k = this.element,\n            I = this.oldShadowOptions,\n            u = {\n          color: \"#000000\",\n          offsetX: this.parentInverted ? -1 : 1,\n          offsetY: this.parentInverted ? -1 : 1,\n          opacity: .15,\n          width: 3\n        },\n            m = !1,\n            F;\n        !0 === a ? F = u : \"object\" === typeof a && (F = x(u, a));\n        F && (F && I && A(F, function (a, c) {\n          a !== I[c] && (m = !0);\n        }), m && this.destroyShadows(), this.oldShadowOptions = F);\n        if (!F) this.destroyShadows();else if (!this.shadows) {\n          var d = F.opacity / F.width;\n          var p = this.parentInverted ? \"translate(\".concat(F.offsetY, \", \").concat(F.offsetX, \")\") : \"translate(\".concat(F.offsetX, \", \").concat(F.offsetY, \")\");\n\n          for (u = 1; u <= F.width; u++) {\n            var n = k.cloneNode(!1);\n            var D = 2 * F.width + 1 - 2 * u;\n            r(n, {\n              stroke: a.color || \"#000000\",\n              \"stroke-opacity\": d * u,\n              \"stroke-width\": D,\n              transform: p,\n              fill: \"none\"\n            });\n            n.setAttribute(\"class\", (n.getAttribute(\"class\") || \"\") + \" highcharts-shadow\");\n            g && (r(n, \"height\", Math.max(r(n, \"height\") - D, 0)), n.cutHeight = D);\n            c ? c.element.appendChild(n) : k.parentNode && k.parentNode.insertBefore(n, k);\n            b.push(n);\n          }\n\n          this.shadows = b;\n        }\n        return this;\n      };\n\n      f.prototype.show = function (a) {\n        void 0 === a && (a = !0);\n        return this.attr({\n          visibility: a ? \"inherit\" : \"visible\"\n        });\n      };\n\n      f.prototype.strokeSetter = function (a, c, g) {\n        this[c] = a;\n        this.stroke && this[\"stroke-width\"] ? (f.prototype.fillSetter.call(this, this.stroke, \"stroke\", g), g.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0) : \"stroke-width\" === c && 0 === a && this.hasStroke ? (g.removeAttribute(\"stroke\"), this.hasStroke = !1) : this.renderer.styledMode && this[\"stroke-width\"] && (g.setAttribute(\"stroke-width\", this[\"stroke-width\"]), this.hasStroke = !0);\n      };\n\n      f.prototype.strokeWidth = function () {\n        if (!this.renderer.styledMode) return this[\"stroke-width\"] || 0;\n        var a = this.getStyle(\"stroke-width\"),\n            c = 0;\n        if (a.indexOf(\"px\") === a.length - 2) c = L(a);else if (\"\" !== a) {\n          var g = t.createElementNS(b, \"rect\");\n          r(g, {\n            width: a,\n            \"stroke-width\": 0\n          });\n          this.element.parentNode.appendChild(g);\n          c = g.getBBox().width;\n          g.parentNode.removeChild(g);\n        }\n        return c;\n      };\n\n      f.prototype.symbolAttr = function (a) {\n        var c = this;\n        \"x y r start end width height innerR anchorX anchorY clockwise\".split(\" \").forEach(function (g) {\n          c[g] = u(a[g], c[g]);\n        });\n        c.attr({\n          d: c.renderer.symbols[c.symbolName](c.x, c.y, c.width, c.height, c)\n        });\n      };\n\n      f.prototype.textSetter = function (a) {\n        a !== this.textStr && (delete this.textPxLength, this.textStr = a, this.added && this.renderer.buildText(this));\n      };\n\n      f.prototype.titleSetter = function (a) {\n        var c = this.element,\n            g = c.getElementsByTagName(\"title\")[0] || t.createElementNS(this.SVG_NS, \"title\");\n        c.insertBefore ? c.insertBefore(g, c.firstChild) : c.appendChild(g);\n        g.textContent = String(u(a, \"\")).replace(/<[^>]*>/g, \"\").replace(/&lt;/g, \"<\").replace(/&gt;/g, \">\");\n      };\n\n      f.prototype.toFront = function () {\n        var a = this.element;\n        a.parentNode.appendChild(a);\n        return this;\n      };\n\n      f.prototype.translate = function (a, c) {\n        return this.attr({\n          translateX: a,\n          translateY: c\n        });\n      };\n\n      f.prototype.updateShadows = function (a, c, g) {\n        var b = this.shadows;\n        if (b) for (var k = b.length; k--;) g.call(b[k], \"height\" === a ? Math.max(c - (b[k].cutHeight || 0), 0) : \"d\" === a ? this.d : c, a, b[k]);\n      };\n\n      f.prototype.updateTransform = function () {\n        var a = this.scaleX,\n            c = this.scaleY,\n            g = this.inverted,\n            b = this.rotation,\n            k = this.matrix,\n            m = this.element,\n            d = this.translateX || 0,\n            n = this.translateY || 0;\n        g && (d += this.width, n += this.height);\n        d = [\"translate(\" + d + \",\" + n + \")\"];\n        w(k) && d.push(\"matrix(\" + k.join(\",\") + \")\");\n        g ? d.push(\"rotate(90) scale(-1,1)\") : b && d.push(\"rotate(\" + b + \" \" + u(this.rotationOriginX, m.getAttribute(\"x\"), 0) + \" \" + u(this.rotationOriginY, m.getAttribute(\"y\") || 0) + \")\");\n        (w(a) || w(c)) && d.push(\"scale(\" + u(a, 1) + \" \" + u(c, 1) + \")\");\n        d.length && m.setAttribute(\"transform\", d.join(\" \"));\n      };\n\n      f.prototype.visibilitySetter = function (a, c, g) {\n        \"inherit\" === a ? g.removeAttribute(c) : this[c] !== a && g.setAttribute(c, a);\n        this[c] = a;\n      };\n\n      f.prototype.xGetter = function (a) {\n        \"circle\" === this.element.nodeName && (\"x\" === a ? a = \"cx\" : \"y\" === a && (a = \"cy\"));\n        return this._defaultGetter(a);\n      };\n\n      f.prototype.zIndexSetter = function (a, c) {\n        var g = this.renderer,\n            b = this.parentGroup,\n            k = (b || g).element || g.box,\n            u = this.element;\n        g = k === g.box;\n        var d = !1;\n        var m = this.added;\n        var F;\n        w(a) ? (u.setAttribute(\"data-z-index\", a), a = +a, this[c] === a && (m = !1)) : w(this[c]) && u.removeAttribute(\"data-z-index\");\n        this[c] = a;\n\n        if (m) {\n          (a = this.zIndex) && b && (b.handleZ = !0);\n          c = k.childNodes;\n\n          for (F = c.length - 1; 0 <= F && !d; F--) {\n            b = c[F];\n            m = b.getAttribute(\"data-z-index\");\n            var n = !w(m);\n            if (b !== u) if (0 > a && n && !g && !F) k.insertBefore(u, c[F]), d = !0;else if (L(m) <= a || n && (!w(a) || 0 <= a)) k.insertBefore(u, c[F + 1] || null), d = !0;\n          }\n\n          d || (k.insertBefore(u, c[g ? 3 : 0] || null), d = !0);\n        }\n\n        return d;\n      };\n\n      return f;\n    }();\n\n    f.prototype[\"stroke-widthSetter\"] = f.prototype.strokeSetter;\n    f.prototype.yGetter = f.prototype.xGetter;\n\n    f.prototype.matrixSetter = f.prototype.rotationOriginXSetter = f.prototype.rotationOriginYSetter = f.prototype.rotationSetter = f.prototype.scaleXSetter = f.prototype.scaleYSetter = f.prototype.translateXSetter = f.prototype.translateYSetter = f.prototype.verticalAlignSetter = function (a, c) {\n      this[c] = a;\n      this.doTransform = !0;\n    };\n\n    \"\";\n    return f;\n  });\n  K(l, \"Core/Renderer/RendererRegistry.js\", [l[\"Core/Globals.js\"]], function (f) {\n    var e;\n\n    (function (e) {\n      e.rendererTypes = {};\n      var l;\n\n      e.getRendererType = function (f) {\n        void 0 === f && (f = l);\n        return e.rendererTypes[f] || e.rendererTypes[l];\n      };\n\n      e.registerRendererType = function (v, P, G) {\n        e.rendererTypes[v] = P;\n        if (!l || G) l = v, f.Renderer = P;\n      };\n    })(e || (e = {}));\n\n    return e;\n  });\n  K(l, \"Core/Renderer/SVG/SVGLabel.js\", [l[\"Core/Renderer/SVG/SVGElement.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    var l = this && this.__extends || function () {\n      var e = function (h, d) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var p in d) d.hasOwnProperty(p) && (b[p] = d[p]);\n        };\n\n        return e(h, d);\n      };\n\n      return function (h, d) {\n        function b() {\n          this.constructor = h;\n        }\n\n        e(h, d);\n        h.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());\n      };\n    }(),\n        C = e.defined,\n        v = e.extend,\n        E = e.isNumber,\n        G = e.merge,\n        B = e.pick,\n        y = e.removeEvent;\n\n    return function (e) {\n      function h(d, b, p, q, r, n, f, w, z, x) {\n        var m = e.call(this) || this;\n        m.paddingLeftSetter = m.paddingSetter;\n        m.paddingRightSetter = m.paddingSetter;\n        m.init(d, \"g\");\n        m.textStr = b;\n        m.x = p;\n        m.y = q;\n        m.anchorX = n;\n        m.anchorY = f;\n        m.baseline = z;\n        m.className = x;\n        m.addClass(\"button\" === x ? \"highcharts-no-tooltip\" : \"highcharts-label\");\n        x && m.addClass(\"highcharts-\" + x);\n        m.text = d.text(void 0, 0, 0, w).attr({\n          zIndex: 1\n        });\n        var k;\n        \"string\" === typeof r && ((k = /^url\\((.*?)\\)$/.test(r)) || m.renderer.symbols[r]) && (m.symbolKey = r);\n        m.bBox = h.emptyBBox;\n        m.padding = 3;\n        m.baselineOffset = 0;\n        m.needsBox = d.styledMode || k;\n        m.deferredAttr = {};\n        m.alignFactor = 0;\n        return m;\n      }\n\n      l(h, e);\n\n      h.prototype.alignSetter = function (d) {\n        d = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[d];\n        d !== this.alignFactor && (this.alignFactor = d, this.bBox && E(this.xSetting) && this.attr({\n          x: this.xSetting\n        }));\n      };\n\n      h.prototype.anchorXSetter = function (d, b) {\n        this.anchorX = d;\n        this.boxAttr(b, Math.round(d) - this.getCrispAdjust() - this.xSetting);\n      };\n\n      h.prototype.anchorYSetter = function (d, b) {\n        this.anchorY = d;\n        this.boxAttr(b, d - this.ySetting);\n      };\n\n      h.prototype.boxAttr = function (d, b) {\n        this.box ? this.box.attr(d, b) : this.deferredAttr[d] = b;\n      };\n\n      h.prototype.css = function (d) {\n        if (d) {\n          var b = {};\n          d = G(d);\n          h.textProps.forEach(function (p) {\n            \"undefined\" !== typeof d[p] && (b[p] = d[p], delete d[p]);\n          });\n          this.text.css(b);\n          var p = (\"width\" in b);\n          \"fontSize\" in b || \"fontWeight\" in b ? this.updateTextPadding() : p && this.updateBoxSize();\n        }\n\n        return f.prototype.css.call(this, d);\n      };\n\n      h.prototype.destroy = function () {\n        y(this.element, \"mouseenter\");\n        y(this.element, \"mouseleave\");\n        this.text && this.text.destroy();\n        this.box && (this.box = this.box.destroy());\n        f.prototype.destroy.call(this);\n      };\n\n      h.prototype.fillSetter = function (d, b) {\n        d && (this.needsBox = !0);\n        this.fill = d;\n        this.boxAttr(b, d);\n      };\n\n      h.prototype.getBBox = function () {\n        this.textStr && 0 === this.bBox.width && 0 === this.bBox.height && this.updateBoxSize();\n        var d = this.padding,\n            b = B(this.paddingLeft, d);\n        return {\n          width: this.width,\n          height: this.height,\n          x: this.bBox.x - b,\n          y: this.bBox.y - d\n        };\n      };\n\n      h.prototype.getCrispAdjust = function () {\n        return this.renderer.styledMode && this.box ? this.box.strokeWidth() % 2 / 2 : (this[\"stroke-width\"] ? parseInt(this[\"stroke-width\"], 10) : 0) % 2 / 2;\n      };\n\n      h.prototype.heightSetter = function (d) {\n        this.heightSetting = d;\n      };\n\n      h.prototype.onAdd = function () {\n        var d = this.textStr;\n        this.text.add(this);\n        this.attr({\n          text: C(d) ? d : \"\",\n          x: this.x,\n          y: this.y\n        });\n        this.box && C(this.anchorX) && this.attr({\n          anchorX: this.anchorX,\n          anchorY: this.anchorY\n        });\n      };\n\n      h.prototype.paddingSetter = function (d, b) {\n        E(d) ? d !== this[b] && (this[b] = d, this.updateTextPadding()) : this[b] = void 0;\n      };\n\n      h.prototype.rSetter = function (d, b) {\n        this.boxAttr(b, d);\n      };\n\n      h.prototype.shadow = function (d) {\n        d && !this.renderer.styledMode && (this.updateBoxSize(), this.box && this.box.shadow(d));\n        return this;\n      };\n\n      h.prototype.strokeSetter = function (d, b) {\n        this.stroke = d;\n        this.boxAttr(b, d);\n      };\n\n      h.prototype[\"stroke-widthSetter\"] = function (d, b) {\n        d && (this.needsBox = !0);\n        this[\"stroke-width\"] = d;\n        this.boxAttr(b, d);\n      };\n\n      h.prototype[\"text-alignSetter\"] = function (d) {\n        this.textAlign = d;\n      };\n\n      h.prototype.textSetter = function (d) {\n        \"undefined\" !== typeof d && this.text.attr({\n          text: d\n        });\n        this.updateTextPadding();\n      };\n\n      h.prototype.updateBoxSize = function () {\n        var d = this.text.element.style,\n            b = {},\n            p = this.padding,\n            q = this.bBox = E(this.widthSetting) && E(this.heightSetting) && !this.textAlign || !C(this.text.textStr) ? h.emptyBBox : this.text.getBBox();\n        this.width = this.getPaddedWidth();\n        this.height = (this.heightSetting || q.height || 0) + 2 * p;\n        d = this.renderer.fontMetrics(d && d.fontSize, this.text);\n        this.baselineOffset = p + Math.min((this.text.firstLineMetrics || d).b, q.height || Infinity);\n        this.heightSetting && (this.baselineOffset += (this.heightSetting - d.h) / 2);\n        this.needsBox && (this.box || (p = this.box = this.symbolKey ? this.renderer.symbol(this.symbolKey) : this.renderer.rect(), p.addClass((\"button\" === this.className ? \"\" : \"highcharts-label-box\") + (this.className ? \" highcharts-\" + this.className + \"-box\" : \"\")), p.add(this)), p = this.getCrispAdjust(), b.x = p, b.y = (this.baseline ? -this.baselineOffset : 0) + p, b.width = Math.round(this.width), b.height = Math.round(this.height), this.box.attr(v(b, this.deferredAttr)), this.deferredAttr = {});\n      };\n\n      h.prototype.updateTextPadding = function () {\n        var d = this.text;\n        this.updateBoxSize();\n        var b = this.baseline ? 0 : this.baselineOffset,\n            p = B(this.paddingLeft, this.padding);\n        C(this.widthSetting) && this.bBox && (\"center\" === this.textAlign || \"right\" === this.textAlign) && (p += {\n          center: .5,\n          right: 1\n        }[this.textAlign] * (this.widthSetting - this.bBox.width));\n        if (p !== d.x || b !== d.y) d.attr(\"x\", p), d.hasBoxWidthChanged && (this.bBox = d.getBBox(!0)), \"undefined\" !== typeof b && d.attr(\"y\", b);\n        d.x = p;\n        d.y = b;\n      };\n\n      h.prototype.widthSetter = function (d) {\n        this.widthSetting = E(d) ? d : void 0;\n      };\n\n      h.prototype.getPaddedWidth = function () {\n        var d = this.padding,\n            b = B(this.paddingLeft, d);\n        d = B(this.paddingRight, d);\n        return (this.widthSetting || this.bBox.width || 0) + b + d;\n      };\n\n      h.prototype.xSetter = function (d) {\n        this.x = d;\n        this.alignFactor && (d -= this.alignFactor * this.getPaddedWidth(), this[\"forceAnimate:x\"] = !0);\n        this.xSetting = Math.round(d);\n        this.attr(\"translateX\", this.xSetting);\n      };\n\n      h.prototype.ySetter = function (d) {\n        this.ySetting = this.y = Math.round(d);\n        this.attr(\"translateY\", this.ySetting);\n      };\n\n      h.emptyBBox = {\n        width: 0,\n        height: 0,\n        x: 0,\n        y: 0\n      };\n      h.textProps = \"color direction fontFamily fontSize fontStyle fontWeight lineHeight textAlign textDecoration textOutline textOverflow width\".split(\" \");\n      return h;\n    }(f);\n  });\n  K(l, \"Core/Renderer/SVG/Symbols.js\", [l[\"Core/Utilities.js\"]], function (f) {\n    function e(e, f, t, h, d) {\n      var b = [];\n\n      if (d) {\n        var p = d.start || 0,\n            q = G(d.r, t);\n        t = G(d.r, h || t);\n        var r = (d.end || 0) - .001;\n        h = d.innerR;\n        var n = G(d.open, .001 > Math.abs((d.end || 0) - p - 2 * Math.PI)),\n            J = Math.cos(p),\n            w = Math.sin(p),\n            z = Math.cos(r),\n            x = Math.sin(r);\n        p = G(d.longArc, .001 > r - p - Math.PI ? 0 : 1);\n        b.push([\"M\", e + q * J, f + t * w], [\"A\", q, t, 0, p, G(d.clockwise, 1), e + q * z, f + t * x]);\n        v(h) && b.push(n ? [\"M\", e + h * z, f + h * x] : [\"L\", e + h * z, f + h * x], [\"A\", h, h, 0, p, v(d.clockwise) ? 1 - d.clockwise : 0, e + h * J, f + h * w]);\n        n || b.push([\"Z\"]);\n      }\n\n      return b;\n    }\n\n    function l(e, f, t, h, d) {\n      return d && d.r ? C(e, f, t, h, d) : [[\"M\", e, f], [\"L\", e + t, f], [\"L\", e + t, f + h], [\"L\", e, f + h], [\"Z\"]];\n    }\n\n    function C(e, f, t, h, d) {\n      d = d && d.r || 0;\n      return [[\"M\", e + d, f], [\"L\", e + t - d, f], [\"C\", e + t, f, e + t, f, e + t, f + d], [\"L\", e + t, f + h - d], [\"C\", e + t, f + h, e + t, f + h, e + t - d, f + h], [\"L\", e + d, f + h], [\"C\", e, f + h, e, f + h, e, f + h - d], [\"L\", e, f + d], [\"C\", e, f, e, f, e + d, f]];\n    }\n\n    var v = f.defined,\n        E = f.isNumber,\n        G = f.pick;\n    return {\n      arc: e,\n      callout: function (e, f, t, h, d) {\n        var b = Math.min(d && d.r || 0, t, h),\n            p = b + 6,\n            q = d && d.anchorX;\n        d = d && d.anchorY || 0;\n        var r = C(e, f, t, h, {\n          r: b\n        });\n        if (!E(q)) return r;\n        e + q >= t ? d > f + p && d < f + h - p ? r.splice(3, 1, [\"L\", e + t, d - 6], [\"L\", e + t + 6, d], [\"L\", e + t, d + 6], [\"L\", e + t, f + h - b]) : r.splice(3, 1, [\"L\", e + t, h / 2], [\"L\", q, d], [\"L\", e + t, h / 2], [\"L\", e + t, f + h - b]) : 0 >= e + q ? d > f + p && d < f + h - p ? r.splice(7, 1, [\"L\", e, d + 6], [\"L\", e - 6, d], [\"L\", e, d - 6], [\"L\", e, f + b]) : r.splice(7, 1, [\"L\", e, h / 2], [\"L\", q, d], [\"L\", e, h / 2], [\"L\", e, f + b]) : d && d > h && q > e + p && q < e + t - p ? r.splice(5, 1, [\"L\", q + 6, f + h], [\"L\", q, f + h + 6], [\"L\", q - 6, f + h], [\"L\", e + b, f + h]) : d && 0 > d && q > e + p && q < e + t - p && r.splice(1, 1, [\"L\", q - 6, f], [\"L\", q, f - 6], [\"L\", q + 6, f], [\"L\", t - b, f]);\n        return r;\n      },\n      circle: function (f, l, t, h) {\n        return e(f + t / 2, l + h / 2, t / 2, h / 2, {\n          start: .5 * Math.PI,\n          end: 2.5 * Math.PI,\n          open: !1\n        });\n      },\n      diamond: function (e, f, t, h) {\n        return [[\"M\", e + t / 2, f], [\"L\", e + t, f + h / 2], [\"L\", e + t / 2, f + h], [\"L\", e, f + h / 2], [\"Z\"]];\n      },\n      rect: l,\n      roundedRect: C,\n      square: l,\n      triangle: function (e, f, t, h) {\n        return [[\"M\", e + t / 2, f], [\"L\", e + t, f + h], [\"L\", e, f + h], [\"Z\"]];\n      },\n      \"triangle-down\": function (e, f, t, h) {\n        return [[\"M\", e, f], [\"L\", e + t, f], [\"L\", e + t / 2, f + h], [\"Z\"]];\n      }\n    };\n  });\n  K(l, \"Core/Renderer/SVG/TextBuilder.js\", [l[\"Core/Renderer/HTML/AST.js\"], l[\"Core/Globals.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var P = e.doc,\n        v = e.SVG_NS,\n        E = e.win,\n        G = l.attr,\n        B = l.extend,\n        y = l.isString,\n        t = l.objectEach,\n        h = l.pick;\n    return function () {\n      function d(b) {\n        var d = b.styles;\n        this.renderer = b.renderer;\n        this.svgElement = b;\n        this.width = b.textWidth;\n        this.textLineHeight = d && d.lineHeight;\n        this.textOutline = d && d.textOutline;\n        this.ellipsis = !(!d || \"ellipsis\" !== d.textOverflow);\n        this.noWrap = !(!d || \"nowrap\" !== d.whiteSpace);\n        this.fontSize = d && d.fontSize;\n      }\n\n      d.prototype.buildSVG = function () {\n        var b = this.svgElement,\n            d = b.element,\n            e = b.renderer,\n            r = h(b.textStr, \"\").toString(),\n            n = -1 !== r.indexOf(\"<\"),\n            J = d.childNodes;\n        e = this.width && !b.added && e.box;\n        var w = /<br.*?>/g,\n            z = [r, this.ellipsis, this.noWrap, this.textLineHeight, this.textOutline, this.fontSize, this.width].join();\n\n        if (z !== b.textCache) {\n          b.textCache = z;\n          delete b.actualWidth;\n\n          for (z = J.length; z--;) d.removeChild(J[z]);\n\n          n || this.ellipsis || this.width || -1 !== r.indexOf(\" \") && (!this.noWrap || w.test(r)) ? \"\" !== r && (e && e.appendChild(d), r = new f(r), this.modifyTree(r.nodes), r.addToDOM(b.element), this.modifyDOM(), this.ellipsis && -1 !== (d.textContent || \"\").indexOf(\"\\u2026\") && b.attr(\"title\", this.unescapeEntities(b.textStr || \"\", [\"&lt;\", \"&gt;\"])), e && e.removeChild(d)) : d.appendChild(P.createTextNode(this.unescapeEntities(r)));\n          y(this.textOutline) && b.applyTextOutline && b.applyTextOutline(this.textOutline);\n        }\n      };\n\n      d.prototype.modifyDOM = function () {\n        var b = this,\n            d = this.svgElement,\n            e = G(d.element, \"x\");\n        d.firstLineMetrics = void 0;\n\n        for (var r; r = d.element.firstChild;) if (/^[\\s\\u200B]*$/.test(r.textContent || \" \")) d.element.removeChild(r);else break;\n\n        [].forEach.call(d.element.querySelectorAll(\"tspan.highcharts-br\"), function (n, r) {\n          n.nextSibling && n.previousSibling && (0 === r && 1 === n.previousSibling.nodeType && (d.firstLineMetrics = d.renderer.fontMetrics(void 0, n.previousSibling)), G(n, {\n            dy: b.getLineHeight(n.nextSibling),\n            x: e\n          }));\n        });\n        var n = this.width || 0;\n\n        if (n) {\n          var h = function (r, p) {\n            var m = r.textContent || \"\",\n                k = m.replace(/([^\\^])-/g, \"$1- \").split(\" \"),\n                a = !b.noWrap && (1 < k.length || 1 < d.element.childNodes.length),\n                g = b.getLineHeight(p),\n                c = 0,\n                D = d.actualWidth;\n            if (b.ellipsis) m && b.truncate(r, m, void 0, 0, Math.max(0, n - parseInt(b.fontSize || 12, 10)), function (a, c) {\n              return a.substring(0, c) + \"\\u2026\";\n            });else if (a) {\n              m = [];\n\n              for (a = []; p.firstChild && p.firstChild !== r;) a.push(p.firstChild), p.removeChild(p.firstChild);\n\n              for (; k.length;) k.length && !b.noWrap && 0 < c && (m.push(r.textContent || \"\"), r.textContent = k.join(\" \").replace(/- /g, \"-\")), b.truncate(r, void 0, k, 0 === c ? D || 0 : 0, n, function (a, c) {\n                return k.slice(0, c).join(\" \").replace(/- /g, \"-\");\n              }), D = d.actualWidth, c++;\n\n              a.forEach(function (a) {\n                p.insertBefore(a, r);\n              });\n              m.forEach(function (a) {\n                p.insertBefore(P.createTextNode(a), r);\n                a = P.createElementNS(v, \"tspan\");\n                a.textContent = \"\\u200b\";\n                G(a, {\n                  dy: g,\n                  x: e\n                });\n                p.insertBefore(a, r);\n              });\n            }\n          },\n              f = function (b) {\n            [].slice.call(b.childNodes).forEach(function (n) {\n              n.nodeType === E.Node.TEXT_NODE ? h(n, b) : (-1 !== n.className.baseVal.indexOf(\"highcharts-br\") && (d.actualWidth = 0), f(n));\n            });\n          };\n\n          f(d.element);\n        }\n      };\n\n      d.prototype.getLineHeight = function (b) {\n        var d;\n        b = b.nodeType === E.Node.TEXT_NODE ? b.parentElement : b;\n        this.renderer.styledMode || (d = b && /(px|em)$/.test(b.style.fontSize) ? b.style.fontSize : this.fontSize || this.renderer.style.fontSize || 12);\n        return this.textLineHeight ? parseInt(this.textLineHeight.toString(), 10) : this.renderer.fontMetrics(d, b || this.svgElement.element).h;\n      };\n\n      d.prototype.modifyTree = function (b) {\n        var d = this,\n            e = function (r, n) {\n          var p = r.attributes;\n          p = void 0 === p ? {} : p;\n          var h = r.children,\n              q = r.style;\n          q = void 0 === q ? {} : q;\n          var f = r.tagName,\n              m = d.renderer.styledMode;\n          if (\"b\" === f || \"strong\" === f) m ? p[\"class\"] = \"highcharts-strong\" : q.fontWeight = \"bold\";else if (\"i\" === f || \"em\" === f) m ? p[\"class\"] = \"highcharts-emphasized\" : q.fontStyle = \"italic\";\n          q && q.color && (q.fill = q.color);\n          \"br\" === f ? (p[\"class\"] = \"highcharts-br\", r.textContent = \"\\u200b\", (n = b[n + 1]) && n.textContent && (n.textContent = n.textContent.replace(/^ +/gm, \"\"))) : \"a\" === f && h && h.some(function (b) {\n            return \"#text\" === b.tagName;\n          }) && (r.children = [{\n            children: h,\n            tagName: \"tspan\"\n          }]);\n          \"#text\" !== f && \"a\" !== f && (r.tagName = \"tspan\");\n          B(r, {\n            attributes: p,\n            style: q\n          });\n          h && h.filter(function (b) {\n            return \"#text\" !== b.tagName;\n          }).forEach(e);\n        };\n\n        b.forEach(e);\n      };\n\n      d.prototype.truncate = function (b, d, e, r, n, h) {\n        var p = this.svgElement,\n            f = p.renderer,\n            q = p.rotation,\n            m = [],\n            k = e ? 1 : 0,\n            a = (d || e || \"\").length,\n            g = a,\n            c,\n            D = function (a, c) {\n          c = c || a;\n          var g = b.parentNode;\n          if (g && \"undefined\" === typeof m[c]) if (g.getSubStringLength) try {\n            m[c] = r + g.getSubStringLength(0, e ? c + 1 : c);\n          } catch (R) {\n            \"\";\n          } else f.getSpanWidth && (b.textContent = h(d || e, a), m[c] = r + f.getSpanWidth(p, b));\n          return m[c];\n        };\n\n        p.rotation = 0;\n        var A = D(b.textContent.length);\n\n        if (r + A > n) {\n          for (; k <= a;) g = Math.ceil((k + a) / 2), e && (c = h(e, g)), A = D(g, c && c.length - 1), k === a ? k = a + 1 : A > n ? a = g - 1 : k = g;\n\n          0 === a ? b.textContent = \"\" : d && a === d.length - 1 || (b.textContent = c || h(d || e, g));\n        }\n\n        e && e.splice(0, g);\n        p.actualWidth = A;\n        p.rotation = q;\n      };\n\n      d.prototype.unescapeEntities = function (b, d) {\n        t(this.renderer.escapes, function (e, r) {\n          d && -1 !== d.indexOf(e) || (b = b.toString().replace(new RegExp(e, \"g\"), r));\n        });\n        return b;\n      };\n\n      return d;\n    }();\n  });\n  K(l, \"Core/Renderer/SVG/SVGRenderer.js\", [l[\"Core/Renderer/HTML/AST.js\"], l[\"Core/Color/Color.js\"], l[\"Core/Globals.js\"], l[\"Core/Renderer/RendererRegistry.js\"], l[\"Core/Renderer/SVG/SVGElement.js\"], l[\"Core/Renderer/SVG/SVGLabel.js\"], l[\"Core/Renderer/SVG/Symbols.js\"], l[\"Core/Renderer/SVG/TextBuilder.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E, G, B, y) {\n    var t = l.charts,\n        h = l.deg2rad,\n        d = l.doc,\n        b = l.isFirefox,\n        p = l.isMS,\n        q = l.isWebKit,\n        r = l.noop,\n        n = l.SVG_NS,\n        J = l.symbolSizes,\n        w = l.win,\n        z = y.addEvent,\n        x = y.attr,\n        m = y.createElement,\n        k = y.css,\n        a = y.defined,\n        g = y.destroyObjectProperties,\n        c = y.extend,\n        D = y.isArray,\n        A = y.isNumber,\n        u = y.isObject,\n        L = y.isString,\n        S = y.merge,\n        R = y.pick,\n        M = y.pInt,\n        U = y.uniqueKey,\n        aa;\n\n    l = function () {\n      function I(a, c, g, b, d, k, m) {\n        this.width = this.url = this.style = this.isSVG = this.imgCount = this.height = this.gradients = this.globalAnimation = this.defs = this.chartIndex = this.cacheKeys = this.cache = this.boxWrapper = this.box = this.alignedObjects = void 0;\n        this.init(a, c, g, b, d, k, m);\n      }\n\n      I.prototype.init = function (a, c, g, m, u, F, I) {\n        var n = this.createElement(\"svg\").attr({\n          version: \"1.1\",\n          \"class\": \"highcharts-root\"\n        }),\n            H = n.element;\n        I || n.css(this.getStyle(m));\n        a.appendChild(H);\n        x(a, \"dir\", \"ltr\");\n        -1 === a.innerHTML.indexOf(\"xmlns\") && x(H, \"xmlns\", this.SVG_NS);\n        this.isSVG = !0;\n        this.box = H;\n        this.boxWrapper = n;\n        this.alignedObjects = [];\n        this.url = this.getReferenceURL();\n        this.createElement(\"desc\").add().element.appendChild(d.createTextNode(\"Created with Highcharts 10.2.0\"));\n        this.defs = this.createElement(\"defs\").add();\n        this.allowHTML = F;\n        this.forExport = u;\n        this.styledMode = I;\n        this.gradients = {};\n        this.cache = {};\n        this.cacheKeys = [];\n        this.imgCount = 0;\n        this.setSize(c, g, !1);\n        var e;\n        b && a.getBoundingClientRect && (c = function () {\n          k(a, {\n            left: 0,\n            top: 0\n          });\n          e = a.getBoundingClientRect();\n          k(a, {\n            left: Math.ceil(e.left) - e.left + \"px\",\n            top: Math.ceil(e.top) - e.top + \"px\"\n          });\n        }, c(), this.unSubPixelFix = z(w, \"resize\", c));\n      };\n\n      I.prototype.definition = function (a) {\n        return new f([a]).addToDOM(this.defs.element);\n      };\n\n      I.prototype.getReferenceURL = function () {\n        if ((b || q) && d.getElementsByTagName(\"base\").length) {\n          if (!a(aa)) {\n            var c = U();\n            c = new f([{\n              tagName: \"svg\",\n              attributes: {\n                width: 8,\n                height: 8\n              },\n              children: [{\n                tagName: \"defs\",\n                children: [{\n                  tagName: \"clipPath\",\n                  attributes: {\n                    id: c\n                  },\n                  children: [{\n                    tagName: \"rect\",\n                    attributes: {\n                      width: 4,\n                      height: 4\n                    }\n                  }]\n                }]\n              }, {\n                tagName: \"rect\",\n                attributes: {\n                  id: \"hitme\",\n                  width: 8,\n                  height: 8,\n                  \"clip-path\": \"url(#\".concat(c, \")\"),\n                  fill: \"rgba(0,0,0,0.001)\"\n                }\n              }]\n            }]).addToDOM(d.body);\n            k(c, {\n              position: \"fixed\",\n              top: 0,\n              left: 0,\n              zIndex: 9E5\n            });\n            var g = d.elementFromPoint(6, 6);\n            aa = \"hitme\" === (g && g.id);\n            d.body.removeChild(c);\n          }\n\n          if (aa) return w.location.href.split(\"#\")[0].replace(/<[^>]*>/g, \"\").replace(/([\\('\\)])/g, \"\\\\$1\").replace(/ /g, \"%20\");\n        }\n\n        return \"\";\n      };\n\n      I.prototype.getStyle = function (a) {\n        return this.style = c({\n          fontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", Arial, Helvetica, sans-serif',\n          fontSize: \"12px\"\n        }, a);\n      };\n\n      I.prototype.setStyle = function (a) {\n        this.boxWrapper.css(this.getStyle(a));\n      };\n\n      I.prototype.isHidden = function () {\n        return !this.boxWrapper.getBBox().width;\n      };\n\n      I.prototype.destroy = function () {\n        var a = this.defs;\n        this.box = null;\n        this.boxWrapper = this.boxWrapper.destroy();\n        g(this.gradients || {});\n        this.gradients = null;\n        a && (this.defs = a.destroy());\n        this.unSubPixelFix && this.unSubPixelFix();\n        return this.alignedObjects = null;\n      };\n\n      I.prototype.createElement = function (a) {\n        var c = new this.Element();\n        c.init(this, a);\n        return c;\n      };\n\n      I.prototype.getRadialAttr = function (a, c) {\n        return {\n          cx: a[0] - a[2] / 2 + (c.cx || 0) * a[2],\n          cy: a[1] - a[2] / 2 + (c.cy || 0) * a[2],\n          r: (c.r || 0) * a[2]\n        };\n      };\n\n      I.prototype.buildText = function (a) {\n        new B(a).buildSVG();\n      };\n\n      I.prototype.getContrast = function (a) {\n        a = e.parse(a).rgba.map(function (a) {\n          a /= 255;\n          return .03928 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4);\n        });\n        a = .2126 * a[0] + .7152 * a[1] + .0722 * a[2];\n        return 1.05 / (a + .05) > (a + .05) / .05 ? \"#FFFFFF\" : \"#000000\";\n      };\n\n      I.prototype.button = function (a, g, b, d, k, m, I, n, e, r) {\n        void 0 === k && (k = {});\n        var F = this.label(a, g, b, e, void 0, void 0, r, void 0, \"button\"),\n            D = this.styledMode;\n        a = k.states || {};\n        var A = 0;\n        k = S(k);\n        delete k.states;\n        var H = S({\n          color: \"#333333\",\n          cursor: \"pointer\",\n          fontWeight: \"normal\"\n        }, k.style);\n        delete k.style;\n        var h = f.filterUserAttributes(k);\n        F.attr(S({\n          padding: 8,\n          r: 2\n        }, h));\n\n        if (!D) {\n          h = S({\n            fill: \"#f7f7f7\",\n            stroke: \"#cccccc\",\n            \"stroke-width\": 1\n          }, h);\n          m = S(h, {\n            fill: \"#e6e6e6\"\n          }, f.filterUserAttributes(m || a.hover || {}));\n          var q = m.style;\n          delete m.style;\n          I = S(h, {\n            fill: \"#e6ebf5\",\n            style: {\n              color: \"#000000\",\n              fontWeight: \"bold\"\n            }\n          }, f.filterUserAttributes(I || a.select || {}));\n          var N = I.style;\n          delete I.style;\n          n = S(h, {\n            style: {\n              color: \"#cccccc\"\n            }\n          }, f.filterUserAttributes(n || a.disabled || {}));\n          var w = n.style;\n          delete n.style;\n        }\n\n        z(F.element, p ? \"mouseover\" : \"mouseenter\", function () {\n          3 !== A && F.setState(1);\n        });\n        z(F.element, p ? \"mouseout\" : \"mouseleave\", function () {\n          3 !== A && F.setState(A);\n        });\n\n        F.setState = function (a) {\n          1 !== a && (F.state = A = a);\n          F.removeClass(/highcharts-button-(normal|hover|pressed|disabled)/).addClass(\"highcharts-button-\" + [\"normal\", \"hover\", \"pressed\", \"disabled\"][a || 0]);\n          D || (F.attr([h, m, I, n][a || 0]), a = [H, q, N, w][a || 0], u(a) && F.css(a));\n        };\n\n        D || F.attr(h).css(c({\n          cursor: \"default\"\n        }, H));\n        return F.on(\"touchstart\", function (a) {\n          return a.stopPropagation();\n        }).on(\"click\", function (a) {\n          3 !== A && d.call(F, a);\n        });\n      };\n\n      I.prototype.crispLine = function (c, g, b) {\n        void 0 === b && (b = \"round\");\n        var d = c[0],\n            k = c[1];\n        a(d[1]) && d[1] === k[1] && (d[1] = k[1] = Math[b](d[1]) - g % 2 / 2);\n        a(d[2]) && d[2] === k[2] && (d[2] = k[2] = Math[b](d[2]) + g % 2 / 2);\n        return c;\n      };\n\n      I.prototype.path = function (a) {\n        var g = this.styledMode ? {} : {\n          fill: \"none\"\n        };\n        D(a) ? g.d = a : u(a) && c(g, a);\n        return this.createElement(\"path\").attr(g);\n      };\n\n      I.prototype.circle = function (a, c, g) {\n        a = u(a) ? a : \"undefined\" === typeof a ? {} : {\n          x: a,\n          y: c,\n          r: g\n        };\n        c = this.createElement(\"circle\");\n\n        c.xSetter = c.ySetter = function (a, c, g) {\n          g.setAttribute(\"c\" + c, a);\n        };\n\n        return c.attr(a);\n      };\n\n      I.prototype.arc = function (a, c, g, b, d, k) {\n        u(a) ? (b = a, c = b.y, g = b.r, a = b.x) : b = {\n          innerR: b,\n          start: d,\n          end: k\n        };\n        a = this.symbol(\"arc\", a, c, g, g, b);\n        a.r = g;\n        return a;\n      };\n\n      I.prototype.rect = function (a, c, g, b, d, k) {\n        d = u(a) ? a.r : d;\n        var m = this.createElement(\"rect\");\n        a = u(a) ? a : \"undefined\" === typeof a ? {} : {\n          x: a,\n          y: c,\n          width: Math.max(g, 0),\n          height: Math.max(b, 0)\n        };\n        this.styledMode || (\"undefined\" !== typeof k && (a[\"stroke-width\"] = k, a = m.crisp(a)), a.fill = \"none\");\n        d && (a.r = d);\n\n        m.rSetter = function (a, c, g) {\n          m.r = a;\n          x(g, {\n            rx: a,\n            ry: a\n          });\n        };\n\n        m.rGetter = function () {\n          return m.r || 0;\n        };\n\n        return m.attr(a);\n      };\n\n      I.prototype.setSize = function (a, c, g) {\n        this.width = a;\n        this.height = c;\n        this.boxWrapper.animate({\n          width: a,\n          height: c\n        }, {\n          step: function () {\n            this.attr({\n              viewBox: \"0 0 \" + this.attr(\"width\") + \" \" + this.attr(\"height\")\n            });\n          },\n          duration: R(g, !0) ? void 0 : 0\n        });\n        this.alignElements();\n      };\n\n      I.prototype.g = function (a) {\n        var c = this.createElement(\"g\");\n        return a ? c.attr({\n          \"class\": \"highcharts-\" + a\n        }) : c;\n      };\n\n      I.prototype.image = function (a, c, g, b, d, k) {\n        var m = {\n          preserveAspectRatio: \"none\"\n        },\n            u = function (a, c) {\n          a.setAttributeNS ? a.setAttributeNS(\"http://www.w3.org/1999/xlink\", \"href\", c) : a.setAttribute(\"hc-svg-href\", c);\n        };\n\n        A(c) && (m.x = c);\n        A(g) && (m.y = g);\n        A(b) && (m.width = b);\n        A(d) && (m.height = d);\n        var F = this.createElement(\"image\").attr(m);\n\n        c = function (c) {\n          u(F.element, a);\n          k.call(F, c);\n        };\n\n        k ? (u(F.element, \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\"), g = new w.Image(), z(g, \"load\", c), g.src = a, g.complete && c({})) : u(F.element, a);\n        return F;\n      };\n\n      I.prototype.symbol = function (g, b, u, I, n, F) {\n        var e = this,\n            r = /^url\\((.*?)\\)$/,\n            D = r.test(g),\n            p = !D && (this.symbols[g] ? g : \"circle\"),\n            A = p && this.symbols[p],\n            h;\n\n        if (A) {\n          \"number\" === typeof b && (h = A.call(this.symbols, Math.round(b || 0), Math.round(u || 0), I || 0, n || 0, F));\n          var f = this.path(h);\n          e.styledMode || f.attr(\"fill\", \"none\");\n          c(f, {\n            symbolName: p || void 0,\n            x: b,\n            y: u,\n            width: I,\n            height: n\n          });\n          F && c(f, F);\n        } else if (D) {\n          var q = g.match(r)[1];\n          var H = f = this.image(q);\n          H.imgwidth = R(J[q] && J[q].width, F && F.width);\n          H.imgheight = R(J[q] && J[q].height, F && F.height);\n\n          var z = function (a) {\n            return a.attr({\n              width: a.width,\n              height: a.height\n            });\n          };\n\n          [\"width\", \"height\"].forEach(function (c) {\n            H[c + \"Setter\"] = function (c, g) {\n              var b = this[\"img\" + g];\n              this[g] = c;\n              a(b) && (F && \"within\" === F.backgroundSize && this.width && this.height && (b = Math.round(b * Math.min(this.width / this.imgwidth, this.height / this.imgheight))), this.element && this.element.setAttribute(g, b), this.alignByTranslate || (c = ((this[g] || 0) - b) / 2, this.attr(\"width\" === g ? {\n                translateX: c\n              } : {\n                translateY: c\n              })));\n            };\n          });\n          a(b) && H.attr({\n            x: b,\n            y: u\n          });\n          H.isImg = !0;\n          a(H.imgwidth) && a(H.imgheight) ? z(H) : (H.attr({\n            width: 0,\n            height: 0\n          }), m(\"img\", {\n            onload: function () {\n              var a = t[e.chartIndex];\n              0 === this.width && (k(this, {\n                position: \"absolute\",\n                top: \"-999em\"\n              }), d.body.appendChild(this));\n              J[q] = {\n                width: this.width,\n                height: this.height\n              };\n              H.imgwidth = this.width;\n              H.imgheight = this.height;\n              H.element && z(H);\n              this.parentNode && this.parentNode.removeChild(this);\n              e.imgCount--;\n              if (!e.imgCount && a && !a.hasLoaded) a.onload();\n            },\n            src: q\n          }), this.imgCount++);\n        }\n\n        return f;\n      };\n\n      I.prototype.clipRect = function (a, c, g, b) {\n        var d = U() + \"-\",\n            k = this.createElement(\"clipPath\").attr({\n          id: d\n        }).add(this.defs);\n        a = this.rect(a, c, g, b, 0).add(k);\n        a.id = d;\n        a.clipPath = k;\n        a.count = 0;\n        return a;\n      };\n\n      I.prototype.text = function (c, g, b, d) {\n        var k = {};\n        if (d && (this.allowHTML || !this.forExport)) return this.html(c, g, b);\n        k.x = Math.round(g || 0);\n        b && (k.y = Math.round(b));\n        a(c) && (k.text = c);\n        c = this.createElement(\"text\").attr(k);\n        if (!d || this.forExport && !this.allowHTML) c.xSetter = function (a, c, g) {\n          for (var b = g.getElementsByTagName(\"tspan\"), d = g.getAttribute(c), k = 0, m; k < b.length; k++) m = b[k], m.getAttribute(c) === d && m.setAttribute(c, a);\n\n          g.setAttribute(c, a);\n        };\n        return c;\n      };\n\n      I.prototype.fontMetrics = function (a, c) {\n        a = !this.styledMode && /px/.test(a) || !w.getComputedStyle ? a || c && c.style && c.style.fontSize || this.style && this.style.fontSize : c && v.prototype.getStyle.call(c, \"font-size\");\n        a = /px/.test(a) ? M(a) : 12;\n        c = 24 > a ? a + 3 : Math.round(1.2 * a);\n        return {\n          h: c,\n          b: Math.round(.8 * c),\n          f: a\n        };\n      };\n\n      I.prototype.rotCorr = function (a, c, g) {\n        var b = a;\n        c && g && (b = Math.max(b * Math.cos(c * h), 4));\n        return {\n          x: -a / 3 * Math.sin(c * h),\n          y: b\n        };\n      };\n\n      I.prototype.pathToSegments = function (a) {\n        for (var c = [], g = [], b = {\n          A: 8,\n          C: 7,\n          H: 2,\n          L: 3,\n          M: 3,\n          Q: 5,\n          S: 5,\n          T: 3,\n          V: 2\n        }, d = 0; d < a.length; d++) L(g[0]) && A(a[d]) && g.length === b[g[0].toUpperCase()] && a.splice(d, 0, g[0].replace(\"M\", \"L\").replace(\"m\", \"l\")), \"string\" === typeof a[d] && (g.length && c.push(g.slice(0)), g.length = 0), g.push(a[d]);\n\n        c.push(g.slice(0));\n        return c;\n      };\n\n      I.prototype.label = function (a, c, g, b, d, k, m, u, I) {\n        return new E(this, a, c, g, b, d, k, m, u, I);\n      };\n\n      I.prototype.alignElements = function () {\n        this.alignedObjects.forEach(function (a) {\n          return a.align();\n        });\n      };\n\n      return I;\n    }();\n\n    c(l.prototype, {\n      Element: v,\n      SVG_NS: n,\n      escapes: {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        \"'\": \"&#39;\",\n        '\"': \"&quot;\"\n      },\n      symbols: G,\n      draw: r\n    });\n    C.registerRendererType(\"svg\", l, !0);\n    \"\";\n    return l;\n  });\n  K(l, \"Core/Renderer/HTML/HTMLElement.js\", [l[\"Core/Globals.js\"], l[\"Core/Renderer/SVG/SVGElement.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = this && this.__extends || function () {\n      var b = function (d, e) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var n in d) d.hasOwnProperty(n) && (b[n] = d[n]);\n        };\n\n        return b(d, e);\n      };\n\n      return function (d, e) {\n        function n() {\n          this.constructor = d;\n        }\n\n        b(d, e);\n        d.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());\n      };\n    }(),\n        v = f.isFirefox,\n        E = f.isMS,\n        G = f.isWebKit,\n        B = f.win,\n        y = l.css,\n        t = l.defined,\n        h = l.extend,\n        d = l.pick,\n        b = l.pInt;\n\n    return function (e) {\n      function p() {\n        return null !== e && e.apply(this, arguments) || this;\n      }\n\n      C(p, e);\n\n      p.compose = function (b) {\n        if (-1 === p.composedClasses.indexOf(b)) {\n          p.composedClasses.push(b);\n          var d = p.prototype,\n              e = b.prototype;\n          e.getSpanCorrection = d.getSpanCorrection;\n          e.htmlCss = d.htmlCss;\n          e.htmlGetBBox = d.htmlGetBBox;\n          e.htmlUpdateTransform = d.htmlUpdateTransform;\n          e.setSpanRotation = d.setSpanRotation;\n        }\n\n        return b;\n      };\n\n      p.prototype.getSpanCorrection = function (b, d, e) {\n        this.xCorr = -b * e;\n        this.yCorr = -d;\n      };\n\n      p.prototype.htmlCss = function (b) {\n        var n = \"SPAN\" === this.element.tagName && b && \"width\" in b,\n            e = d(n && b.width, void 0);\n\n        if (n) {\n          delete b.width;\n          this.textWidth = e;\n          var p = !0;\n        }\n\n        b && \"ellipsis\" === b.textOverflow && (b.whiteSpace = \"nowrap\", b.overflow = \"hidden\");\n        this.styles = h(this.styles, b);\n        y(this.element, b);\n        p && this.htmlUpdateTransform();\n        return this;\n      };\n\n      p.prototype.htmlGetBBox = function () {\n        var b = this.element;\n        return {\n          x: b.offsetLeft,\n          y: b.offsetTop,\n          width: b.offsetWidth,\n          height: b.offsetHeight\n        };\n      };\n\n      p.prototype.htmlUpdateTransform = function () {\n        if (this.added) {\n          var d = this.renderer,\n              n = this.element,\n              e = this.translateX || 0,\n              p = this.translateY || 0,\n              h = this.x || 0,\n              f = this.y || 0,\n              m = this.textAlign || \"left\",\n              k = {\n            left: 0,\n            center: .5,\n            right: 1\n          }[m],\n              a = this.styles;\n          a = a && a.whiteSpace;\n          y(n, {\n            marginLeft: e,\n            marginTop: p\n          });\n          !d.styledMode && this.shadows && this.shadows.forEach(function (a) {\n            y(a, {\n              marginLeft: e + 1,\n              marginTop: p + 1\n            });\n          });\n          this.inverted && [].forEach.call(n.childNodes, function (a) {\n            d.invertChild(a, n);\n          });\n\n          if (\"SPAN\" === n.tagName) {\n            var g = this.rotation,\n                c = this.textWidth && b(this.textWidth),\n                D = [g, m, n.innerHTML, this.textWidth, this.textAlign].join(),\n                A = void 0;\n            A = !1;\n\n            if (c !== this.oldTextWidth) {\n              if (this.textPxLength) var u = this.textPxLength;else y(n, {\n                width: \"\",\n                whiteSpace: a || \"nowrap\"\n              }), u = n.offsetWidth;\n              (c > this.oldTextWidth || u > c) && (/[ \\-]/.test(n.textContent || n.innerText) || \"ellipsis\" === n.style.textOverflow) && (y(n, {\n                width: u > c || g ? c + \"px\" : \"auto\",\n                display: \"block\",\n                whiteSpace: a || \"normal\"\n              }), this.oldTextWidth = c, A = !0);\n            }\n\n            this.hasBoxWidthChanged = A;\n            D !== this.cTT && (A = d.fontMetrics(n.style.fontSize, n).b, !t(g) || g === (this.oldRotation || 0) && m === this.oldAlign || this.setSpanRotation(g, k, A), this.getSpanCorrection(!t(g) && this.textPxLength || n.offsetWidth, A, k, g, m));\n            y(n, {\n              left: h + (this.xCorr || 0) + \"px\",\n              top: f + (this.yCorr || 0) + \"px\"\n            });\n            this.cTT = D;\n            this.oldRotation = g;\n            this.oldAlign = m;\n          }\n        } else this.alignOnAdd = !0;\n      };\n\n      p.prototype.setSpanRotation = function (b, d, e) {\n        var n = {},\n            p = E && !/Edge/.test(B.navigator.userAgent) ? \"-ms-transform\" : G ? \"-webkit-transform\" : v ? \"MozTransform\" : B.opera ? \"-o-transform\" : void 0;\n        p && (n[p] = n.transform = \"rotate(\" + b + \"deg)\", n[p + (v ? \"Origin\" : \"-origin\")] = n.transformOrigin = 100 * d + \"% \" + e + \"px\", y(this.element, n));\n      };\n\n      p.composedClasses = [];\n      return p;\n    }(e);\n  });\n  K(l, \"Core/Renderer/HTML/HTMLRenderer.js\", [l[\"Core/Renderer/HTML/AST.js\"], l[\"Core/Renderer/SVG/SVGElement.js\"], l[\"Core/Renderer/SVG/SVGRenderer.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C) {\n    var v = this && this.__extends || function () {\n      var e = function (h, d) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var e in d) d.hasOwnProperty(e) && (b[e] = d[e]);\n        };\n\n        return e(h, d);\n      };\n\n      return function (h, d) {\n        function b() {\n          this.constructor = h;\n        }\n\n        e(h, d);\n        h.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());\n      };\n    }(),\n        E = C.attr,\n        G = C.createElement,\n        B = C.extend,\n        y = C.pick;\n\n    return function (t) {\n      function h() {\n        return null !== t && t.apply(this, arguments) || this;\n      }\n\n      v(h, t);\n\n      h.compose = function (d) {\n        -1 === h.composedClasses.indexOf(d) && (h.composedClasses.push(d), d.prototype.html = h.prototype.html);\n        return d;\n      };\n\n      h.prototype.html = function (d, b, p) {\n        var h = this.createElement(\"span\"),\n            r = h.element,\n            n = h.renderer,\n            t = n.isSVG,\n            w = function (b, d) {\n          [\"opacity\", \"visibility\"].forEach(function (m) {\n            b[m + \"Setter\"] = function (k, a, g) {\n              var c = b.div ? b.div.style : d;\n              e.prototype[m + \"Setter\"].call(this, k, a, g);\n              c && (c[a] = k);\n            };\n          });\n          b.addedSetters = !0;\n        };\n\n        h.textSetter = function (b) {\n          b !== this.textStr && (delete this.bBox, delete this.oldTextWidth, f.setElementHTML(this.element, y(b, \"\")), this.textStr = b, h.doTransform = !0);\n        };\n\n        t && w(h, h.element.style);\n\n        h.xSetter = h.ySetter = h.alignSetter = h.rotationSetter = function (b, d) {\n          \"align\" === d ? h.alignValue = h.textAlign = b : h[d] = b;\n          h.doTransform = !0;\n        };\n\n        h.afterSetters = function () {\n          this.doTransform && (this.htmlUpdateTransform(), this.doTransform = !1);\n        };\n\n        h.attr({\n          text: d,\n          x: Math.round(b),\n          y: Math.round(p)\n        }).css({\n          position: \"absolute\"\n        });\n        n.styledMode || h.css({\n          fontFamily: this.style.fontFamily,\n          fontSize: this.style.fontSize\n        });\n        r.style.whiteSpace = \"nowrap\";\n        h.css = h.htmlCss;\n        t && (h.add = function (b) {\n          var d = n.box.parentNode,\n              m = [];\n\n          if (this.parentGroup = b) {\n            var k = b.div;\n\n            if (!k) {\n              for (; b;) m.push(b), b = b.parentGroup;\n\n              m.reverse().forEach(function (a) {\n                function g(c, g) {\n                  a[g] = c;\n                  \"translateX\" === g ? e.left = c + \"px\" : e.top = c + \"px\";\n                  a.doTransform = !0;\n                }\n\n                var c = E(a.element, \"class\"),\n                    b = a.styles || {};\n                k = a.div = a.div || G(\"div\", c ? {\n                  className: c\n                } : void 0, {\n                  position: \"absolute\",\n                  left: (a.translateX || 0) + \"px\",\n                  top: (a.translateY || 0) + \"px\",\n                  display: a.display,\n                  opacity: a.opacity,\n                  cursor: b.cursor,\n                  pointerEvents: b.pointerEvents,\n                  visibility: a.visibility\n                }, k || d);\n                var e = k.style;\n                B(a, {\n                  classSetter: function (a) {\n                    return function (c) {\n                      this.element.setAttribute(\"class\", c);\n                      a.className = c;\n                    };\n                  }(k),\n                  on: function () {\n                    m[0].div && h.on.apply({\n                      element: m[0].div,\n                      onEvents: a.onEvents\n                    }, arguments);\n                    return a;\n                  },\n                  translateXSetter: g,\n                  translateYSetter: g\n                });\n                a.addedSetters || w(a);\n              });\n            }\n          } else k = d;\n\n          k.appendChild(r);\n          h.added = !0;\n          h.alignOnAdd && h.htmlUpdateTransform();\n          return h;\n        });\n        return h;\n      };\n\n      h.composedClasses = [];\n      return h;\n    }(l);\n  });\n  K(l, \"Core/Axis/AxisDefaults.js\", [], function () {\n    var f = /*#__PURE__*/(() => {\n      (function (e) {\n        e.defaultXAxisOptions = {\n          alignTicks: !0,\n          allowDecimals: void 0,\n          panningEnabled: !0,\n          zIndex: 2,\n          zoomEnabled: !0,\n          dateTimeLabelFormats: {\n            millisecond: {\n              main: \"%H:%M:%S.%L\",\n              range: !1\n            },\n            second: {\n              main: \"%H:%M:%S\",\n              range: !1\n            },\n            minute: {\n              main: \"%H:%M\",\n              range: !1\n            },\n            hour: {\n              main: \"%H:%M\",\n              range: !1\n            },\n            day: {\n              main: \"%e. %b\"\n            },\n            week: {\n              main: \"%e. %b\"\n            },\n            month: {\n              main: \"%b '%y\"\n            },\n            year: {\n              main: \"%Y\"\n            }\n          },\n          endOnTick: !1,\n          gridLineDashStyle: \"Solid\",\n          gridZIndex: 1,\n          labels: {\n            autoRotation: void 0,\n            autoRotationLimit: 80,\n            distance: void 0,\n            enabled: !0,\n            indentation: 10,\n            overflow: \"justify\",\n            padding: 5,\n            reserveSpace: void 0,\n            rotation: void 0,\n            staggerLines: 0,\n            step: 0,\n            useHTML: !1,\n            x: 0,\n            zIndex: 7,\n            style: {\n              color: \"#666666\",\n              cursor: \"default\",\n              fontSize: \"11px\"\n            }\n          },\n          maxPadding: .01,\n          minorGridLineDashStyle: \"Solid\",\n          minorTickLength: 2,\n          minorTickPosition: \"outside\",\n          minPadding: .01,\n          offset: void 0,\n          opposite: !1,\n          reversed: void 0,\n          reversedStacks: !1,\n          showEmpty: !0,\n          showFirstLabel: !0,\n          showLastLabel: !0,\n          startOfWeek: 1,\n          startOnTick: !1,\n          tickLength: 10,\n          tickPixelInterval: 100,\n          tickmarkPlacement: \"between\",\n          tickPosition: \"outside\",\n          title: {\n            align: \"middle\",\n            rotation: 0,\n            useHTML: !1,\n            x: 0,\n            y: 0,\n            style: {\n              color: \"#666666\"\n            }\n          },\n          type: \"linear\",\n          uniqueNames: !0,\n          visible: !0,\n          minorGridLineColor: \"#f2f2f2\",\n          minorGridLineWidth: 1,\n          minorTickColor: \"#999999\",\n          lineColor: \"#ccd6eb\",\n          lineWidth: 1,\n          gridLineColor: \"#e6e6e6\",\n          gridLineWidth: void 0,\n          tickColor: \"#ccd6eb\"\n        };\n        e.defaultYAxisOptions = {\n          reversedStacks: !0,\n          endOnTick: !0,\n          maxPadding: .05,\n          minPadding: .05,\n          tickPixelInterval: 72,\n          showLastLabel: !0,\n          labels: {\n            x: -8\n          },\n          startOnTick: !0,\n          title: {\n            rotation: 270,\n            text: \"Values\"\n          },\n          stackLabels: {\n            animation: {},\n            allowOverlap: !1,\n            enabled: !1,\n            crop: !0,\n            overflow: \"justify\",\n            formatter: function () {\n              var e = this.axis.chart.numberFormatter;\n              return e(this.total, -1);\n            },\n            style: {\n              color: \"#000000\",\n              fontSize: \"11px\",\n              fontWeight: \"bold\",\n              textOutline: \"1px contrast\"\n            }\n          },\n          gridLineWidth: 1,\n          lineWidth: 0\n        };\n        e.defaultLeftAxisOptions = {\n          labels: {\n            x: -15\n          },\n          title: {\n            rotation: 270\n          }\n        };\n        e.defaultRightAxisOptions = {\n          labels: {\n            x: 15\n          },\n          title: {\n            rotation: 90\n          }\n        };\n        e.defaultBottomAxisOptions = {\n          labels: {\n            autoRotation: [-45],\n            x: 0\n          },\n          margin: 15,\n          title: {\n            rotation: 0\n          }\n        };\n        e.defaultTopAxisOptions = {\n          labels: {\n            autoRotation: [-45],\n            x: 0\n          },\n          margin: 15,\n          title: {\n            rotation: 0\n          }\n        };\n      })(f || (f = {}));\n\n      return f;\n    })();\n    return f;\n  });\n  K(l, \"Core/Foundation.js\", [l[\"Core/Utilities.js\"]], function (f) {\n    var e = f.addEvent,\n        l = f.isFunction,\n        C = f.objectEach,\n        v = f.removeEvent,\n        E;\n\n    (function (f) {\n      f.registerEventOptions = function (f, y) {\n        f.eventOptions = f.eventOptions || {};\n        C(y.events, function (t, h) {\n          f.eventOptions[h] !== t && (f.eventOptions[h] && (v(f, h, f.eventOptions[h]), delete f.eventOptions[h]), l(t) && (f.eventOptions[h] = t, e(f, h, t)));\n        });\n      };\n    })(E || (E = {}));\n\n    return E;\n  });\n  K(l, \"Core/Axis/Tick.js\", [l[\"Core/FormatUtilities.js\"], l[\"Core/Globals.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = e.deg2rad,\n        v = l.clamp,\n        E = l.correctFloat,\n        G = l.defined,\n        B = l.destroyObjectProperties,\n        y = l.extend,\n        t = l.fireEvent,\n        h = l.isNumber,\n        d = l.merge,\n        b = l.objectEach,\n        p = l.pick;\n\n    e = function () {\n      function e(b, d, e, p, h) {\n        this.isNewLabel = this.isNew = !0;\n        this.axis = b;\n        this.pos = d;\n        this.type = e || \"\";\n        this.parameters = h || {};\n        this.tickmarkOffset = this.parameters.tickmarkOffset;\n        this.options = this.parameters.options;\n        t(this, \"init\");\n        e || p || this.addLabel();\n      }\n\n      e.prototype.addLabel = function () {\n        var b = this,\n            d = b.axis,\n            e = d.options,\n            q = d.chart,\n            z = d.categories,\n            x = d.logarithmic,\n            m = d.names,\n            k = b.pos,\n            a = p(b.options && b.options.labels, e.labels),\n            g = d.tickPositions,\n            c = k === g[0],\n            D = k === g[g.length - 1],\n            A = (!a.step || 1 === a.step) && 1 === d.tickInterval;\n        g = g.info;\n        var u = b.label,\n            l;\n        z = this.parameters.category || (z ? p(z[k], m[k], k) : k);\n        x && h(z) && (z = E(x.lin2log(z)));\n        if (d.dateTime) if (g) {\n          var S = q.time.resolveDTLFormat(e.dateTimeLabelFormats[!e.grid && g.higherRanks[k] || g.unitName]);\n          var R = S.main;\n        } else h(z) && (R = d.dateTime.getXDateFormat(z, e.dateTimeLabelFormats || {}));\n        b.isFirst = c;\n        b.isLast = D;\n        var M = {\n          axis: d,\n          chart: q,\n          dateTimeLabelFormat: R,\n          isFirst: c,\n          isLast: D,\n          pos: k,\n          tick: b,\n          tickPositionInfo: g,\n          value: z\n        };\n        t(this, \"labelFormat\", M);\n\n        var B = function (c) {\n          return a.formatter ? a.formatter.call(c, c) : a.format ? (c.text = d.defaultLabelFormatter.call(c), f.format(a.format, c, q)) : d.defaultLabelFormatter.call(c, c);\n        };\n\n        e = B.call(M, M);\n        var aa = S && S.list;\n        b.shortenLabel = aa ? function () {\n          for (l = 0; l < aa.length; l++) if (y(M, {\n            dateTimeLabelFormat: aa[l]\n          }), u.attr({\n            text: B.call(M, M)\n          }), u.getBBox().width < d.getSlotWidth(b) - 2 * a.padding) return;\n\n          u.attr({\n            text: \"\"\n          });\n        } : void 0;\n        A && d._addedPlotLB && b.moveLabel(e, a);\n        G(u) || b.movedLabel ? u && u.textStr !== e && !A && (!u.textWidth || a.style.width || u.styles.width || u.css({\n          width: null\n        }), u.attr({\n          text: e\n        }), u.textPxLength = u.getBBox().width) : (b.label = u = b.createLabel({\n          x: 0,\n          y: 0\n        }, e, a), b.rotation = 0);\n      };\n\n      e.prototype.createLabel = function (b, e, p) {\n        var n = this.axis,\n            h = n.chart;\n        if (b = G(e) && p.enabled ? h.renderer.text(e, b.x, b.y, p.useHTML).add(n.labelGroup) : null) h.styledMode || b.css(d(p.style)), b.textPxLength = b.getBBox().width;\n        return b;\n      };\n\n      e.prototype.destroy = function () {\n        B(this, this.axis);\n      };\n\n      e.prototype.getPosition = function (b, d, e, p) {\n        var n = this.axis,\n            h = n.chart,\n            m = p && h.oldChartHeight || h.chartHeight;\n        b = {\n          x: b ? E(n.translate(d + e, void 0, void 0, p) + n.transB) : n.left + n.offset + (n.opposite ? (p && h.oldChartWidth || h.chartWidth) - n.right - n.left : 0),\n          y: b ? m - n.bottom + n.offset - (n.opposite ? n.height : 0) : E(m - n.translate(d + e, void 0, void 0, p) - n.transB)\n        };\n        b.y = v(b.y, -1E5, 1E5);\n        t(this, \"afterGetPosition\", {\n          pos: b\n        });\n        return b;\n      };\n\n      e.prototype.getLabelPosition = function (b, d, e, p, h, f, m, k) {\n        var a = this.axis,\n            g = a.transA,\n            c = a.isLinked && a.linkedParent ? a.linkedParent.reversed : a.reversed,\n            n = a.staggerLines,\n            A = a.tickRotCorr || {\n          x: 0,\n          y: 0\n        },\n            u = p || a.reserveSpaceDefault ? 0 : -a.labelOffset * (\"center\" === a.labelAlign ? .5 : 1),\n            r = {};\n        e = 0 === a.side ? e.rotation ? -8 : -e.getBBox().height : 2 === a.side ? A.y + 8 : Math.cos(e.rotation * C) * (A.y - e.getBBox(!1, 0).height / 2);\n        G(h.y) && (e = 0 === a.side && a.horiz ? h.y + e : h.y);\n        b = b + h.x + u + A.x - (f && p ? f * g * (c ? -1 : 1) : 0);\n        d = d + e - (f && !p ? f * g * (c ? 1 : -1) : 0);\n        n && (p = m / (k || 1) % n, a.opposite && (p = n - p - 1), d += a.labelOffset / n * p);\n        r.x = b;\n        r.y = Math.round(d);\n        t(this, \"afterGetLabelPosition\", {\n          pos: r,\n          tickmarkOffset: f,\n          index: m\n        });\n        return r;\n      };\n\n      e.prototype.getLabelSize = function () {\n        return this.label ? this.label.getBBox()[this.axis.horiz ? \"height\" : \"width\"] : 0;\n      };\n\n      e.prototype.getMarkPath = function (b, d, e, p, h, f) {\n        return f.crispLine([[\"M\", b, d], [\"L\", b + (h ? 0 : -e), d + (h ? e : 0)]], p);\n      };\n\n      e.prototype.handleOverflow = function (b) {\n        var d = this.axis,\n            e = d.options.labels,\n            h = b.x,\n            f = d.chart.chartWidth,\n            r = d.chart.spacing,\n            m = p(d.labelLeft, Math.min(d.pos, r[3]));\n        r = p(d.labelRight, Math.max(d.isRadial ? 0 : d.pos + d.len, f - r[1]));\n        var k = this.label,\n            a = this.rotation,\n            g = {\n          left: 0,\n          center: .5,\n          right: 1\n        }[d.labelAlign || k.attr(\"align\")],\n            c = k.getBBox().width,\n            D = d.getSlotWidth(this),\n            A = {},\n            u = D,\n            q = 1,\n            l;\n        if (a || \"justify\" !== e.overflow) 0 > a && h - g * c < m ? l = Math.round(h / Math.cos(a * C) - m) : 0 < a && h + g * c > r && (l = Math.round((f - h) / Math.cos(a * C)));else if (f = h + (1 - g) * c, h - g * c < m ? u = b.x + u * (1 - g) - m : f > r && (u = r - b.x + u * g, q = -1), u = Math.min(D, u), u < D && \"center\" === d.labelAlign && (b.x += q * (D - u - g * (D - Math.min(c, u)))), c > u || d.autoRotation && (k.styles || {}).width) l = u;\n        l && (this.shortenLabel ? this.shortenLabel() : (A.width = Math.floor(l) + \"px\", (e.style || {}).textOverflow || (A.textOverflow = \"ellipsis\"), k.css(A)));\n      };\n\n      e.prototype.moveLabel = function (d, e) {\n        var h = this,\n            p = h.label,\n            n = h.axis,\n            f = n.reversed,\n            m = !1;\n        p && p.textStr === d ? (h.movedLabel = p, m = !0, delete h.label) : b(n.ticks, function (a) {\n          m || a.isNew || a === h || !a.label || a.label.textStr !== d || (h.movedLabel = a.label, m = !0, a.labelPos = h.movedLabel.xy, delete a.label);\n        });\n\n        if (!m && (h.labelPos || p)) {\n          var k = h.labelPos || p.xy;\n          p = n.horiz ? f ? 0 : n.width + n.left : k.x;\n          n = n.horiz ? k.y : f ? n.width + n.left : 0;\n          h.movedLabel = h.createLabel({\n            x: p,\n            y: n\n          }, d, e);\n          h.movedLabel && h.movedLabel.attr({\n            opacity: 0\n          });\n        }\n      };\n\n      e.prototype.render = function (b, d, e) {\n        var h = this.axis,\n            n = h.horiz,\n            f = this.pos,\n            m = p(this.tickmarkOffset, h.tickmarkOffset);\n        f = this.getPosition(n, f, m, d);\n        m = f.x;\n        var k = f.y;\n        h = n && m === h.pos + h.len || !n && k === h.pos ? -1 : 1;\n        n = p(e, this.label && this.label.newOpacity, 1);\n        e = p(e, 1);\n        this.isActive = !0;\n        this.renderGridLine(d, e, h);\n        this.renderMark(f, e, h);\n        this.renderLabel(f, d, n, b);\n        this.isNew = !1;\n        t(this, \"afterRender\");\n      };\n\n      e.prototype.renderGridLine = function (b, d, e) {\n        var h = this.axis,\n            n = h.options,\n            f = {},\n            m = this.pos,\n            k = this.type,\n            a = p(this.tickmarkOffset, h.tickmarkOffset),\n            g = h.chart.renderer,\n            c = this.gridLine,\n            D = n.gridLineWidth,\n            A = n.gridLineColor,\n            u = n.gridLineDashStyle;\n        \"minor\" === this.type && (D = n.minorGridLineWidth, A = n.minorGridLineColor, u = n.minorGridLineDashStyle);\n        c || (h.chart.styledMode || (f.stroke = A, f[\"stroke-width\"] = D || 0, f.dashstyle = u), k || (f.zIndex = 1), b && (d = 0), this.gridLine = c = g.path().attr(f).addClass(\"highcharts-\" + (k ? k + \"-\" : \"\") + \"grid-line\").add(h.gridGroup));\n        if (c && (e = h.getPlotLinePath({\n          value: m + a,\n          lineWidth: c.strokeWidth() * e,\n          force: \"pass\",\n          old: b\n        }))) c[b || this.isNew ? \"attr\" : \"animate\"]({\n          d: e,\n          opacity: d\n        });\n      };\n\n      e.prototype.renderMark = function (b, d, e) {\n        var h = this.axis,\n            n = h.options,\n            f = h.chart.renderer,\n            m = this.type,\n            k = h.tickSize(m ? m + \"Tick\" : \"tick\"),\n            a = b.x;\n        b = b.y;\n        var g = p(n[\"minor\" !== m ? \"tickWidth\" : \"minorTickWidth\"], !m && h.isXAxis ? 1 : 0);\n        n = n[\"minor\" !== m ? \"tickColor\" : \"minorTickColor\"];\n        var c = this.mark,\n            D = !c;\n        k && (h.opposite && (k[0] = -k[0]), c || (this.mark = c = f.path().addClass(\"highcharts-\" + (m ? m + \"-\" : \"\") + \"tick\").add(h.axisGroup), h.chart.styledMode || c.attr({\n          stroke: n,\n          \"stroke-width\": g\n        })), c[D ? \"attr\" : \"animate\"]({\n          d: this.getMarkPath(a, b, k[0], c.strokeWidth() * e, h.horiz, f),\n          opacity: d\n        }));\n      };\n\n      e.prototype.renderLabel = function (b, d, e, f) {\n        var n = this.axis,\n            r = n.horiz,\n            m = n.options,\n            k = this.label,\n            a = m.labels,\n            g = a.step;\n        n = p(this.tickmarkOffset, n.tickmarkOffset);\n        var c = b.x;\n        b = b.y;\n        var D = !0;\n        k && h(c) && (k.xy = b = this.getLabelPosition(c, b, k, r, a, n, f, g), this.isFirst && !this.isLast && !m.showFirstLabel || this.isLast && !this.isFirst && !m.showLastLabel ? D = !1 : !r || a.step || a.rotation || d || 0 === e || this.handleOverflow(b), g && f % g && (D = !1), D && h(b.y) ? (b.opacity = e, k[this.isNewLabel ? \"attr\" : \"animate\"](b).show(!0), this.isNewLabel = !1) : (k.hide(), this.isNewLabel = !0));\n      };\n\n      e.prototype.replaceMovedLabel = function () {\n        var b = this.label,\n            d = this.axis,\n            e = d.reversed;\n\n        if (b && !this.isNew) {\n          var h = d.horiz ? e ? d.left : d.width + d.left : b.xy.x;\n          e = d.horiz ? b.xy.y : e ? d.width + d.top : d.top;\n          b.animate({\n            x: h,\n            y: e,\n            opacity: 0\n          }, void 0, b.destroy);\n          delete this.label;\n        }\n\n        d.isDirty = !0;\n        this.label = this.movedLabel;\n        delete this.movedLabel;\n      };\n\n      return e;\n    }();\n\n    \"\";\n    return e;\n  });\n  K(l, \"Core/Axis/Axis.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/Axis/AxisDefaults.js\"], l[\"Core/Color/Color.js\"], l[\"Core/DefaultOptions.js\"], l[\"Core/Foundation.js\"], l[\"Core/Globals.js\"], l[\"Core/Axis/Tick.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E, G, B) {\n    var y = f.animObject,\n        t = C.defaultOptions,\n        h = v.registerEventOptions,\n        d = E.deg2rad,\n        b = B.arrayMax,\n        p = B.arrayMin,\n        q = B.clamp,\n        r = B.correctFloat,\n        n = B.defined,\n        J = B.destroyObjectProperties,\n        w = B.erase,\n        z = B.error,\n        x = B.extend,\n        m = B.fireEvent,\n        k = B.isArray,\n        a = B.isNumber,\n        g = B.isString,\n        c = B.merge,\n        D = B.normalizeTickInterval,\n        A = B.objectEach,\n        u = B.pick,\n        L = B.relativeLength,\n        S = B.removeEvent,\n        R = B.splat,\n        M = B.syncTimeout,\n        U = function (a, c) {\n      return D(c, void 0, void 0, u(a.options.allowDecimals, .5 > c || void 0 !== a.tickAmount), !!a.tickAmount);\n    };\n\n    f = function () {\n      function f(a, c) {\n        this.zoomEnabled = this.width = this.visible = this.userOptions = this.translationSlope = this.transB = this.transA = this.top = this.ticks = this.tickRotCorr = this.tickPositions = this.tickmarkOffset = this.tickInterval = this.tickAmount = this.side = this.series = this.right = this.positiveValuesOnly = this.pos = this.pointRangePadding = this.pointRange = this.plotLinesAndBandsGroups = this.plotLinesAndBands = this.paddedTicks = this.overlap = this.options = this.offset = this.names = this.minPixelPadding = this.minorTicks = this.minorTickInterval = this.min = this.maxLabelLength = this.max = this.len = this.left = this.labelFormatter = this.labelEdge = this.isLinked = this.height = this.hasVisibleSeries = this.hasNames = this.eventOptions = this.coll = this.closestPointRange = this.chart = this.bottom = this.alternateBands = void 0;\n        this.init(a, c);\n      }\n\n      f.prototype.init = function (c, b) {\n        var g = b.isX;\n        this.chart = c;\n        this.horiz = c.inverted && !this.isZAxis ? !g : g;\n        this.isXAxis = g;\n        this.coll = this.coll || (g ? \"xAxis\" : \"yAxis\");\n        m(this, \"init\", {\n          userOptions: b\n        });\n        this.opposite = u(b.opposite, this.opposite);\n        this.side = u(b.side, this.side, this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3);\n        this.setOptions(b);\n        var d = this.options,\n            k = d.labels,\n            e = d.type;\n        this.userOptions = b;\n        this.minPixelPadding = 0;\n        this.reversed = u(d.reversed, this.reversed);\n        this.visible = d.visible;\n        this.zoomEnabled = d.zoomEnabled;\n        this.hasNames = \"category\" === e || !0 === d.categories;\n        this.categories = d.categories || (this.hasNames ? [] : void 0);\n        this.names || (this.names = [], this.names.keys = {});\n        this.plotLinesAndBandsGroups = {};\n        this.positiveValuesOnly = !!this.logarithmic;\n        this.isLinked = n(d.linkedTo);\n        this.ticks = {};\n        this.labelEdge = [];\n        this.minorTicks = {};\n        this.plotLinesAndBands = [];\n        this.alternateBands = {};\n        this.len = 0;\n        this.minRange = this.userMinRange = d.minRange || d.maxZoom;\n        this.range = d.range;\n        this.offset = d.offset || 0;\n        this.min = this.max = null;\n        b = u(d.crosshair, R(c.options.tooltip.crosshairs)[g ? 0 : 1]);\n        this.crosshair = !0 === b ? {} : b;\n        -1 === c.axes.indexOf(this) && (g ? c.axes.splice(c.xAxis.length, 0, this) : c.axes.push(this), c[this.coll].push(this));\n        this.series = this.series || [];\n        c.inverted && !this.isZAxis && g && \"undefined\" === typeof this.reversed && (this.reversed = !0);\n        this.labelRotation = a(k.rotation) ? k.rotation : void 0;\n        h(this, d);\n        m(this, \"afterInit\");\n      };\n\n      f.prototype.setOptions = function (a) {\n        this.options = c(e.defaultXAxisOptions, \"yAxis\" === this.coll && e.defaultYAxisOptions, [e.defaultTopAxisOptions, e.defaultRightAxisOptions, e.defaultBottomAxisOptions, e.defaultLeftAxisOptions][this.side], c(t[this.coll], a));\n        m(this, \"afterSetOptions\", {\n          userOptions: a\n        });\n      };\n\n      f.prototype.defaultLabelFormatter = function (c) {\n        var b = this.axis;\n        c = this.chart.numberFormatter;\n        var g = a(this.value) ? this.value : NaN,\n            d = b.chart.time,\n            k = this.dateTimeLabelFormat,\n            e = t.lang,\n            m = e.numericSymbols;\n        e = e.numericSymbolMagnitude || 1E3;\n        var u = b.logarithmic ? Math.abs(g) : b.tickInterval,\n            h = m && m.length;\n        if (b.categories) var f = \"\".concat(this.value);else if (k) f = d.dateFormat(k, g);else if (h && 1E3 <= u) for (; h-- && \"undefined\" === typeof f;) b = Math.pow(e, h + 1), u >= b && 0 === 10 * g % b && null !== m[h] && 0 !== g && (f = c(g / b, -1) + m[h]);\n        \"undefined\" === typeof f && (f = 1E4 <= Math.abs(g) ? c(g, -1) : c(g, -1, void 0, \"\"));\n        return f;\n      };\n\n      f.prototype.getSeriesExtremes = function () {\n        var c = this,\n            b = c.chart,\n            g;\n        m(this, \"getSeriesExtremes\", null, function () {\n          c.hasVisibleSeries = !1;\n          c.dataMin = c.dataMax = c.threshold = null;\n          c.softThreshold = !c.isXAxis;\n          c.stacking && c.stacking.buildStacks();\n          c.series.forEach(function (d) {\n            if (d.visible || !b.options.chart.ignoreHiddenSeries) {\n              var k = d.options,\n                  e = k.threshold;\n              c.hasVisibleSeries = !0;\n              c.positiveValuesOnly && 0 >= e && (e = null);\n\n              if (c.isXAxis) {\n                if (k = d.xData, k.length) {\n                  k = c.logarithmic ? k.filter(c.validatePositiveValue) : k;\n                  g = d.getXExtremes(k);\n                  var m = g.min;\n                  var h = g.max;\n                  a(m) || m instanceof Date || (k = k.filter(a), g = d.getXExtremes(k), m = g.min, h = g.max);\n                  k.length && (c.dataMin = Math.min(u(c.dataMin, m), m), c.dataMax = Math.max(u(c.dataMax, h), h));\n                }\n              } else if (d = d.applyExtremes(), a(d.dataMin) && (m = d.dataMin, c.dataMin = Math.min(u(c.dataMin, m), m)), a(d.dataMax) && (h = d.dataMax, c.dataMax = Math.max(u(c.dataMax, h), h)), n(e) && (c.threshold = e), !k.softThreshold || c.positiveValuesOnly) c.softThreshold = !1;\n            }\n          });\n        });\n        m(this, \"afterGetSeriesExtremes\");\n      };\n\n      f.prototype.translate = function (c, b, g, d, k, e) {\n        var m = this.linkedParent || this,\n            u = d && m.old ? m.old.min : m.min;\n        if (!a(u)) return NaN;\n        var h = m.minPixelPadding;\n        k = (m.isOrdinal || m.brokenAxis && m.brokenAxis.hasBreaks || m.logarithmic && k) && m.lin2val;\n        var f = 1,\n            p = 0;\n        d = d && m.old ? m.old.transA : m.transA;\n        d || (d = m.transA);\n        g && (f *= -1, p = m.len);\n        m.reversed && (f *= -1, p -= f * (m.sector || m.len));\n        b ? (e = (c * f + p - h) / d + u, k && (e = m.lin2val(e))) : (k && (c = m.val2lin(c)), c = f * (c - u) * d, e = (m.isRadial ? c : r(c)) + p + f * h + (a(e) ? d * e : 0));\n        return e;\n      };\n\n      f.prototype.toPixels = function (a, c) {\n        return this.translate(a, !1, !this.horiz, void 0, !0) + (c ? 0 : this.pos);\n      };\n\n      f.prototype.toValue = function (a, c) {\n        return this.translate(a - (c ? 0 : this.pos), !0, !this.horiz, void 0, !0);\n      };\n\n      f.prototype.getPlotLinePath = function (c) {\n        function b(a, c, g) {\n          if (\"pass\" !== r && a < c || a > g) r ? a = q(a, c, g) : L = !0;\n          return a;\n        }\n\n        var g = this,\n            d = g.chart,\n            k = g.left,\n            e = g.top,\n            h = c.old,\n            f = c.value,\n            p = c.lineWidth,\n            n = h && d.oldChartHeight || d.chartHeight,\n            I = h && d.oldChartWidth || d.chartWidth,\n            D = g.transB,\n            A = c.translatedValue,\n            r = c.force,\n            l,\n            t,\n            x,\n            z,\n            L;\n        c = {\n          value: f,\n          lineWidth: p,\n          old: h,\n          force: r,\n          acrossPanes: c.acrossPanes,\n          translatedValue: A\n        };\n        m(this, \"getPlotLinePath\", c, function (c) {\n          A = u(A, g.translate(f, void 0, void 0, h));\n          A = q(A, -1E5, 1E5);\n          l = x = Math.round(A + D);\n          t = z = Math.round(n - A - D);\n          a(A) ? g.horiz ? (t = e, z = n - g.bottom, l = x = b(l, k, k + g.width)) : (l = k, x = I - g.right, t = z = b(t, e, e + g.height)) : (L = !0, r = !1);\n          c.path = L && !r ? null : d.renderer.crispLine([[\"M\", l, t], [\"L\", x, z]], p || 1);\n        });\n        return c.path;\n      };\n\n      f.prototype.getLinearTickPositions = function (a, c, g) {\n        var b = r(Math.floor(c / a) * a);\n        g = r(Math.ceil(g / a) * a);\n        var d = [],\n            k;\n        r(b + a) === b && (k = 20);\n        if (this.single) return [c];\n\n        for (c = b; c <= g;) {\n          d.push(c);\n          c = r(c + a, k);\n          if (c === m) break;\n          var m = c;\n        }\n\n        return d;\n      };\n\n      f.prototype.getMinorTickInterval = function () {\n        var a = this.options;\n        return !0 === a.minorTicks ? u(a.minorTickInterval, \"auto\") : !1 === a.minorTicks ? null : a.minorTickInterval;\n      };\n\n      f.prototype.getMinorTickPositions = function () {\n        var a = this.options,\n            c = this.tickPositions,\n            g = this.minorTickInterval,\n            b = this.pointRangePadding || 0,\n            d = this.min - b;\n        b = this.max + b;\n        var k = b - d,\n            m = [];\n\n        if (k && k / g < this.len / 3) {\n          var e = this.logarithmic;\n          if (e) this.paddedTicks.forEach(function (a, c, b) {\n            c && m.push.apply(m, e.getLogTickPositions(g, b[c - 1], b[c], !0));\n          });else if (this.dateTime && \"auto\" === this.getMinorTickInterval()) m = m.concat(this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(g), d, b, a.startOfWeek));else for (a = d + (c[0] - d) % g; a <= b && a !== m[0]; a += g) m.push(a);\n        }\n\n        0 !== m.length && this.trimTicks(m);\n        return m;\n      };\n\n      f.prototype.adjustForMinRange = function () {\n        var a = this.options,\n            c = this.logarithmic,\n            g = this.min,\n            d = this.max,\n            k = 0,\n            m,\n            e,\n            h,\n            f;\n        this.isXAxis && \"undefined\" === typeof this.minRange && !c && (n(a.min) || n(a.max) || n(a.floor) || n(a.ceiling) ? this.minRange = null : (this.series.forEach(function (a) {\n          h = a.xData;\n          f = a.xIncrement ? 1 : h.length - 1;\n          if (1 < h.length) for (m = f; 0 < m; m--) if (e = h[m] - h[m - 1], !k || e < k) k = e;\n        }), this.minRange = Math.min(5 * k, this.dataMax - this.dataMin)));\n\n        if (d - g < this.minRange) {\n          var A = this.dataMax - this.dataMin >= this.minRange;\n          var D = this.minRange;\n          var r = (D - d + g) / 2;\n          r = [g - r, u(a.min, g - r)];\n          A && (r[2] = this.logarithmic ? this.logarithmic.log2lin(this.dataMin) : this.dataMin);\n          g = b(r);\n          d = [g + D, u(a.max, g + D)];\n          A && (d[2] = c ? c.log2lin(this.dataMax) : this.dataMax);\n          d = p(d);\n          d - g < D && (r[0] = d - D, r[1] = u(a.min, d - D), g = b(r));\n        }\n\n        this.min = g;\n        this.max = d;\n      };\n\n      f.prototype.getClosest = function () {\n        var a;\n        this.categories ? a = 1 : this.series.forEach(function (c) {\n          var g = c.closestPointRange,\n              b = c.visible || !c.chart.options.chart.ignoreHiddenSeries;\n          !c.noSharedTooltip && n(g) && b && (a = n(a) ? Math.min(a, g) : g);\n        });\n        return a;\n      };\n\n      f.prototype.nameToX = function (a) {\n        var c = k(this.options.categories),\n            g = c ? this.categories : this.names,\n            b = a.options.x;\n        a.series.requireSorting = !1;\n        n(b) || (b = this.options.uniqueNames && g ? c ? g.indexOf(a.name) : u(g.keys[a.name], -1) : a.series.autoIncrement());\n\n        if (-1 === b) {\n          if (!c && g) var d = g.length;\n        } else d = b;\n\n        \"undefined\" !== typeof d && (this.names[d] = a.name, this.names.keys[a.name] = d);\n        return d;\n      };\n\n      f.prototype.updateNames = function () {\n        var a = this,\n            c = this.names;\n        0 < c.length && (Object.keys(c.keys).forEach(function (a) {\n          delete c.keys[a];\n        }), c.length = 0, this.minRange = this.userMinRange, (this.series || []).forEach(function (c) {\n          c.xIncrement = null;\n          if (!c.points || c.isDirtyData) a.max = Math.max(a.max, c.xData.length - 1), c.processData(), c.generatePoints();\n          c.data.forEach(function (g, b) {\n            if (g && g.options && \"undefined\" !== typeof g.name) {\n              var d = a.nameToX(g);\n              \"undefined\" !== typeof d && d !== g.x && (g.x = d, c.xData[b] = d);\n            }\n          });\n        }));\n      };\n\n      f.prototype.setAxisTranslation = function () {\n        var a = this,\n            c = a.max - a.min,\n            b = a.linkedParent,\n            d = !!a.categories,\n            k = a.isXAxis,\n            e = a.axisPointRange || 0,\n            h = 0,\n            f = 0,\n            p = a.transA;\n\n        if (k || d || e) {\n          var n = a.getClosest();\n          b ? (h = b.minPointOffset, f = b.pointRangePadding) : a.series.forEach(function (c) {\n            var b = d ? 1 : k ? u(c.options.pointRange, n, 0) : a.axisPointRange || 0,\n                m = c.options.pointPlacement;\n            e = Math.max(e, b);\n            if (!a.single || d) c = c.is(\"xrange\") ? !k : k, h = Math.max(h, c && g(m) ? 0 : b / 2), f = Math.max(f, c && \"on\" === m ? 0 : b);\n          });\n          b = a.ordinal && a.ordinal.slope && n ? a.ordinal.slope / n : 1;\n          a.minPointOffset = h *= b;\n          a.pointRangePadding = f *= b;\n          a.pointRange = Math.min(e, a.single && d ? 1 : c);\n          k && (a.closestPointRange = n);\n        }\n\n        a.translationSlope = a.transA = p = a.staticScale || a.len / (c + f || 1);\n        a.transB = a.horiz ? a.left : a.bottom;\n        a.minPixelPadding = p * h;\n        m(this, \"afterSetAxisTranslation\");\n      };\n\n      f.prototype.minFromRange = function () {\n        return this.max - this.range;\n      };\n\n      f.prototype.setTickInterval = function (c) {\n        var g = this.chart,\n            b = this.logarithmic,\n            d = this.options,\n            k = this.isXAxis,\n            e = this.isLinked,\n            h = d.tickPixelInterval,\n            f = this.categories,\n            p = this.softThreshold,\n            A = d.maxPadding,\n            D = d.minPadding,\n            I = a(d.tickInterval) && 0 <= d.tickInterval ? d.tickInterval : void 0,\n            q = a(this.threshold) ? this.threshold : null;\n        this.dateTime || f || e || this.getTickAmount();\n        var l = u(this.userMin, d.min);\n        var t = u(this.userMax, d.max);\n\n        if (e) {\n          this.linkedParent = g[this.coll][d.linkedTo];\n          var x = this.linkedParent.getExtremes();\n          this.min = u(x.min, x.dataMin);\n          this.max = u(x.max, x.dataMax);\n          d.type !== this.linkedParent.options.type && z(11, 1, g);\n        } else {\n          if (p && n(q)) if (this.dataMin >= q) x = q, D = 0;else if (this.dataMax <= q) {\n            var L = q;\n            A = 0;\n          }\n          this.min = u(l, x, this.dataMin);\n          this.max = u(t, L, this.dataMax);\n        }\n\n        b && (this.positiveValuesOnly && !c && 0 >= Math.min(this.min, u(this.dataMin, this.min)) && z(10, 1, g), this.min = r(b.log2lin(this.min), 16), this.max = r(b.log2lin(this.max), 16));\n        this.range && n(this.max) && (this.userMin = this.min = l = Math.max(this.dataMin, this.minFromRange()), this.userMax = t = this.max, this.range = null);\n        m(this, \"foundExtremes\");\n        this.beforePadding && this.beforePadding();\n        this.adjustForMinRange();\n        !(f || this.axisPointRange || this.stacking && this.stacking.usePercentage || e) && n(this.min) && n(this.max) && (g = this.max - this.min) && (!n(l) && D && (this.min -= g * D), !n(t) && A && (this.max += g * A));\n        a(this.userMin) || (a(d.softMin) && d.softMin < this.min && (this.min = l = d.softMin), a(d.floor) && (this.min = Math.max(this.min, d.floor)));\n        a(this.userMax) || (a(d.softMax) && d.softMax > this.max && (this.max = t = d.softMax), a(d.ceiling) && (this.max = Math.min(this.max, d.ceiling)));\n        p && n(this.dataMin) && (q = q || 0, !n(l) && this.min < q && this.dataMin >= q ? this.min = this.options.minRange ? Math.min(q, this.max - this.minRange) : q : !n(t) && this.max > q && this.dataMax <= q && (this.max = this.options.minRange ? Math.max(q, this.min + this.minRange) : q));\n        a(this.min) && a(this.max) && !this.chart.polar && this.min > this.max && (n(this.options.min) ? this.max = this.min : n(this.options.max) && (this.min = this.max));\n        this.tickInterval = this.min === this.max || \"undefined\" === typeof this.min || \"undefined\" === typeof this.max ? 1 : e && this.linkedParent && !I && h === this.linkedParent.options.tickPixelInterval ? I = this.linkedParent.tickInterval : u(I, this.tickAmount ? (this.max - this.min) / Math.max(this.tickAmount - 1, 1) : void 0, f ? 1 : (this.max - this.min) * h / Math.max(this.len, h));\n\n        if (k && !c) {\n          var w = this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max);\n          this.series.forEach(function (a) {\n            a.forceCrop = a.forceCropping && a.forceCropping();\n            a.processData(w);\n          });\n          m(this, \"postProcessData\", {\n            hasExtemesChanged: w\n          });\n        }\n\n        this.setAxisTranslation();\n        m(this, \"initialAxisTranslation\");\n        this.pointRange && !I && (this.tickInterval = Math.max(this.pointRange, this.tickInterval));\n        c = u(d.minTickInterval, this.dateTime && !this.series.some(function (a) {\n          return a.noSharedTooltip;\n        }) ? this.closestPointRange : 0);\n        !I && this.tickInterval < c && (this.tickInterval = c);\n        this.dateTime || this.logarithmic || I || (this.tickInterval = U(this, this.tickInterval));\n        this.tickAmount || (this.tickInterval = this.unsquish());\n        this.setTickPositions();\n      };\n\n      f.prototype.setTickPositions = function () {\n        var a = this.options,\n            c = a.tickPositions,\n            g = this.getMinorTickInterval(),\n            b = this.hasVerticalPanning(),\n            d = \"colorAxis\" === this.coll,\n            k = (d || !b) && a.startOnTick;\n        b = (d || !b) && a.endOnTick;\n        d = a.tickPositioner;\n        this.tickmarkOffset = this.categories && \"between\" === a.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0;\n        this.minorTickInterval = \"auto\" === g && this.tickInterval ? this.tickInterval / 5 : g;\n        this.single = this.min === this.max && n(this.min) && !this.tickAmount && (parseInt(this.min, 10) === this.min || !1 !== a.allowDecimals);\n        this.tickPositions = g = c && c.slice();\n\n        if (!g) {\n          if (this.ordinal && this.ordinal.positions || !((this.max - this.min) / this.tickInterval > Math.max(2 * this.len, 200))) {\n            if (this.dateTime) g = this.getTimeTicks(this.dateTime.normalizeTimeTickInterval(this.tickInterval, a.units), this.min, this.max, a.startOfWeek, this.ordinal && this.ordinal.positions, this.closestPointRange, !0);else if (this.logarithmic) g = this.logarithmic.getLogTickPositions(this.tickInterval, this.min, this.max);else for (var e = a = this.tickInterval; e <= 2 * a;) if (g = this.getLinearTickPositions(this.tickInterval, this.min, this.max), this.tickAmount && g.length > this.tickAmount) this.tickInterval = U(this, e *= 1.1);else break;\n          } else g = [this.min, this.max], z(19, !1, this.chart);\n          g.length > this.len && (g = [g[0], g.pop()], g[0] === g[1] && (g.length = 1));\n          this.tickPositions = g;\n          d && (d = d.apply(this, [this.min, this.max])) && (this.tickPositions = g = d);\n        }\n\n        this.paddedTicks = g.slice(0);\n        this.trimTicks(g, k, b);\n        this.isLinked || (this.single && 2 > g.length && !this.categories && !this.series.some(function (a) {\n          return a.is(\"heatmap\") && \"between\" === a.options.pointPlacement;\n        }) && (this.min -= .5, this.max += .5), c || d || this.adjustTickAmount());\n        m(this, \"afterSetTickPositions\");\n      };\n\n      f.prototype.trimTicks = function (a, c, g) {\n        var b = a[0],\n            d = a[a.length - 1],\n            k = !this.isOrdinal && this.minPointOffset || 0;\n        m(this, \"trimTicks\");\n\n        if (!this.isLinked) {\n          if (c && -Infinity !== b) this.min = b;else for (; this.min - k > a[0];) a.shift();\n          if (g) this.max = d;else for (; this.max + k < a[a.length - 1];) a.pop();\n          0 === a.length && n(b) && !this.options.tickPositions && a.push((d + b) / 2);\n        }\n      };\n\n      f.prototype.alignToOthers = function () {\n        var c = this,\n            g = [this],\n            b = c.options,\n            d = \"yAxis\" === this.coll && this.chart.options.chart.alignThresholds,\n            k = [],\n            m;\n        c.thresholdAlignment = void 0;\n\n        if ((!1 !== this.chart.options.chart.alignTicks && b.alignTicks || d) && !1 !== b.startOnTick && !1 !== b.endOnTick && !c.logarithmic) {\n          var e = function (a) {\n            var c = a.options;\n            return [a.horiz ? c.left : c.top, c.width, c.height, c.pane].join();\n          },\n              h = e(this);\n\n          this.chart[this.coll].forEach(function (a) {\n            var b = a.series;\n            b.length && b.some(function (a) {\n              return a.visible;\n            }) && a !== c && e(a) === h && (m = !0, g.push(a));\n          });\n        }\n\n        if (m && d) {\n          g.forEach(function (g) {\n            g = g.getThresholdAlignment(c);\n            a(g) && k.push(g);\n          });\n          var u = 1 < k.length ? k.reduce(function (a, c) {\n            return a + c;\n          }, 0) / k.length : void 0;\n          g.forEach(function (a) {\n            a.thresholdAlignment = u;\n          });\n        }\n\n        return m;\n      };\n\n      f.prototype.getThresholdAlignment = function (c) {\n        (!a(this.dataMin) || this !== c && this.series.some(function (a) {\n          return a.isDirty || a.isDirtyData;\n        })) && this.getSeriesExtremes();\n        if (a(this.threshold)) return c = q((this.threshold - (this.dataMin || 0)) / ((this.dataMax || 0) - (this.dataMin || 0)), 0, 1), this.options.reversed && (c = 1 - c), c;\n      };\n\n      f.prototype.getTickAmount = function () {\n        var a = this.options,\n            c = a.tickPixelInterval,\n            g = a.tickAmount;\n        !n(a.tickInterval) && !g && this.len < c && !this.isRadial && !this.logarithmic && a.startOnTick && a.endOnTick && (g = 2);\n        !g && this.alignToOthers() && (g = Math.ceil(this.len / c) + 1);\n        4 > g && (this.finalTickAmt = g, g = 5);\n        this.tickAmount = g;\n      };\n\n      f.prototype.adjustTickAmount = function () {\n        var c = this,\n            g = c.finalTickAmt,\n            b = c.max,\n            d = c.min,\n            k = c.options,\n            m = c.tickPositions,\n            e = c.tickAmount,\n            h = c.thresholdAlignment,\n            f = m && m.length,\n            p = u(c.threshold, c.softThreshold ? 0 : null);\n        var A = c.tickInterval;\n\n        if (a(h)) {\n          var D = .5 > h ? Math.ceil(h * (e - 1)) : Math.floor(h * (e - 1));\n          k.reversed && (D = e - 1 - D);\n        }\n\n        if (c.hasData() && a(d) && a(b)) {\n          h = function () {\n            c.transA *= (f - 1) / (e - 1);\n            c.min = k.startOnTick ? m[0] : Math.min(d, m[0]);\n            c.max = k.endOnTick ? m[m.length - 1] : Math.max(b, m[m.length - 1]);\n          };\n\n          if (a(D) && a(c.threshold)) {\n            for (; m[D] !== p || m.length !== e || m[0] > d || m[m.length - 1] < b;) {\n              m.length = 0;\n\n              for (m.push(c.threshold); m.length < e;) void 0 === m[D] || m[D] > c.threshold ? m.unshift(r(m[0] - A)) : m.push(r(m[m.length - 1] + A));\n\n              if (A > 8 * c.tickInterval) break;\n              A *= 2;\n            }\n\n            h();\n          } else if (f < e) {\n            for (; m.length < e;) m.length % 2 || d === p ? m.push(r(m[m.length - 1] + A)) : m.unshift(r(m[0] - A));\n\n            h();\n          }\n\n          if (n(g)) {\n            for (A = p = m.length; A--;) (3 === g && 1 === A % 2 || 2 >= g && 0 < A && A < p - 1) && m.splice(A, 1);\n\n            c.finalTickAmt = void 0;\n          }\n        }\n      };\n\n      f.prototype.setScale = function () {\n        var a = !1,\n            c = !1;\n        this.series.forEach(function (g) {\n          a = a || g.isDirtyData || g.isDirty;\n          c = c || g.xAxis && g.xAxis.isDirty || !1;\n        });\n        this.setAxisSize();\n        var g = this.len !== (this.old && this.old.len);\n        g || a || c || this.isLinked || this.forceRedraw || this.userMin !== (this.old && this.old.userMin) || this.userMax !== (this.old && this.old.userMax) || this.alignToOthers() ? (this.stacking && this.stacking.resetStacks(), this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickInterval(), this.isDirty || (this.isDirty = g || this.min !== (this.old && this.old.min) || this.max !== (this.old && this.old.max))) : this.stacking && this.stacking.cleanStacks();\n        a && this.panningState && (this.panningState.isDirty = !0);\n        m(this, \"afterSetScale\");\n      };\n\n      f.prototype.setExtremes = function (a, c, g, b, d) {\n        var k = this,\n            e = k.chart;\n        g = u(g, !0);\n        k.series.forEach(function (a) {\n          delete a.kdTree;\n        });\n        d = x(d, {\n          min: a,\n          max: c\n        });\n        m(k, \"setExtremes\", d, function () {\n          k.userMin = a;\n          k.userMax = c;\n          k.eventArgs = d;\n          g && e.redraw(b);\n        });\n      };\n\n      f.prototype.zoom = function (a, c) {\n        var g = this,\n            b = this.dataMin,\n            d = this.dataMax,\n            k = this.options,\n            e = Math.min(b, u(k.min, b)),\n            h = Math.max(d, u(k.max, d));\n        a = {\n          newMin: a,\n          newMax: c\n        };\n        m(this, \"zoom\", a, function (a) {\n          var c = a.newMin,\n              k = a.newMax;\n          if (c !== g.min || k !== g.max) g.allowZoomOutside || (n(b) && (c < e && (c = e), c > h && (c = h)), n(d) && (k < e && (k = e), k > h && (k = h))), g.displayBtn = \"undefined\" !== typeof c || \"undefined\" !== typeof k, g.setExtremes(c, k, !1, void 0, {\n            trigger: \"zoom\"\n          });\n          a.zoomed = !0;\n        });\n        return a.zoomed;\n      };\n\n      f.prototype.setAxisSize = function () {\n        var a = this.chart,\n            c = this.options,\n            g = c.offsets || [0, 0, 0, 0],\n            b = this.horiz,\n            d = this.width = Math.round(L(u(c.width, a.plotWidth - g[3] + g[1]), a.plotWidth)),\n            k = this.height = Math.round(L(u(c.height, a.plotHeight - g[0] + g[2]), a.plotHeight)),\n            m = this.top = Math.round(L(u(c.top, a.plotTop + g[0]), a.plotHeight, a.plotTop));\n        c = this.left = Math.round(L(u(c.left, a.plotLeft + g[3]), a.plotWidth, a.plotLeft));\n        this.bottom = a.chartHeight - k - m;\n        this.right = a.chartWidth - d - c;\n        this.len = Math.max(b ? d : k, 0);\n        this.pos = b ? c : m;\n      };\n\n      f.prototype.getExtremes = function () {\n        var a = this.logarithmic;\n        return {\n          min: a ? r(a.lin2log(this.min)) : this.min,\n          max: a ? r(a.lin2log(this.max)) : this.max,\n          dataMin: this.dataMin,\n          dataMax: this.dataMax,\n          userMin: this.userMin,\n          userMax: this.userMax\n        };\n      };\n\n      f.prototype.getThreshold = function (a) {\n        var c = this.logarithmic,\n            g = c ? c.lin2log(this.min) : this.min;\n        c = c ? c.lin2log(this.max) : this.max;\n        null === a || -Infinity === a ? a = g : Infinity === a ? a = c : g > a ? a = g : c < a && (a = c);\n        return this.translate(a, 0, 1, 0, 1);\n      };\n\n      f.prototype.autoLabelAlign = function (a) {\n        var c = (u(a, 0) - 90 * this.side + 720) % 360;\n        a = {\n          align: \"center\"\n        };\n        m(this, \"autoLabelAlign\", a, function (a) {\n          15 < c && 165 > c ? a.align = \"right\" : 195 < c && 345 > c && (a.align = \"left\");\n        });\n        return a.align;\n      };\n\n      f.prototype.tickSize = function (a) {\n        var c = this.options,\n            g = u(c[\"tick\" === a ? \"tickWidth\" : \"minorTickWidth\"], \"tick\" === a && this.isXAxis && !this.categories ? 1 : 0),\n            b = c[\"tick\" === a ? \"tickLength\" : \"minorTickLength\"];\n\n        if (g && b) {\n          \"inside\" === c[a + \"Position\"] && (b = -b);\n          var d = [b, g];\n        }\n\n        a = {\n          tickSize: d\n        };\n        m(this, \"afterTickSize\", a);\n        return a.tickSize;\n      };\n\n      f.prototype.labelMetrics = function () {\n        var a = this.tickPositions && this.tickPositions[0] || 0;\n        return this.chart.renderer.fontMetrics(this.options.labels.style.fontSize, this.ticks[a] && this.ticks[a].label);\n      };\n\n      f.prototype.unsquish = function () {\n        var c = this.options.labels,\n            g = this.horiz,\n            b = this.tickInterval,\n            k = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / b),\n            m = c.rotation,\n            e = this.labelMetrics(),\n            h = Math.max(this.max - this.min, 0),\n            f = function (a) {\n          var c = a / (k || 1);\n          c = 1 < c ? Math.ceil(c) : 1;\n          c * b > h && Infinity !== a && Infinity !== k && h && (c = Math.ceil(h / b));\n          return r(c * b);\n        },\n            p = b,\n            n,\n            A,\n            D = Number.MAX_VALUE;\n\n        if (g) {\n          if (!c.staggerLines && !c.step) if (a(m)) var q = [m];else k < c.autoRotationLimit && (q = c.autoRotation);\n          q && q.forEach(function (a) {\n            if (a === m || a && -90 <= a && 90 >= a) {\n              A = f(Math.abs(e.h / Math.sin(d * a)));\n              var c = A + Math.abs(a / 360);\n              c < D && (D = c, n = a, p = A);\n            }\n          });\n        } else c.step || (p = f(e.h));\n\n        this.autoRotation = q;\n        this.labelRotation = u(n, a(m) ? m : 0);\n        return p;\n      };\n\n      f.prototype.getSlotWidth = function (c) {\n        var g = this.chart,\n            b = this.horiz,\n            d = this.options.labels,\n            k = Math.max(this.tickPositions.length - (this.categories ? 0 : 1), 1),\n            m = g.margin[3];\n        if (c && a(c.slotWidth)) return c.slotWidth;\n        if (b && 2 > d.step) return d.rotation ? 0 : (this.staggerLines || 1) * this.len / k;\n\n        if (!b) {\n          c = d.style.width;\n          if (void 0 !== c) return parseInt(String(c), 10);\n          if (m) return m - g.spacing[3];\n        }\n\n        return .33 * g.chartWidth;\n      };\n\n      f.prototype.renderUnsquish = function () {\n        var a = this.chart,\n            c = a.renderer,\n            b = this.tickPositions,\n            d = this.ticks,\n            k = this.options.labels,\n            m = k.style,\n            e = this.horiz,\n            h = this.getSlotWidth(),\n            u = Math.max(1, Math.round(h - 2 * k.padding)),\n            f = {},\n            p = this.labelMetrics(),\n            n = m.textOverflow,\n            A = 0;\n        g(k.rotation) || (f.rotation = k.rotation || 0);\n        b.forEach(function (a) {\n          a = d[a];\n          a.movedLabel && a.replaceMovedLabel();\n          a && a.label && a.label.textPxLength > A && (A = a.label.textPxLength);\n        });\n        this.maxLabelLength = A;\n        if (this.autoRotation) A > u && A > p.h ? f.rotation = this.labelRotation : this.labelRotation = 0;else if (h) {\n          var D = u;\n\n          if (!n) {\n            var r = \"clip\";\n\n            for (u = b.length; !e && u--;) {\n              var q = b[u];\n              if (q = d[q].label) q.styles && \"ellipsis\" === q.styles.textOverflow ? q.css({\n                textOverflow: \"clip\"\n              }) : q.textPxLength > h && q.css({\n                width: h + \"px\"\n              }), q.getBBox().height > this.len / b.length - (p.h - p.f) && (q.specificTextOverflow = \"ellipsis\");\n            }\n          }\n        }\n        f.rotation && (D = A > .5 * a.chartHeight ? .33 * a.chartHeight : A, n || (r = \"ellipsis\"));\n        if (this.labelAlign = k.align || this.autoLabelAlign(this.labelRotation)) f.align = this.labelAlign;\n        b.forEach(function (a) {\n          var c = (a = d[a]) && a.label,\n              g = m.width,\n              b = {};\n          c && (c.attr(f), a.shortenLabel ? a.shortenLabel() : D && !g && \"nowrap\" !== m.whiteSpace && (D < c.textPxLength || \"SPAN\" === c.element.tagName) ? (b.width = D + \"px\", n || (b.textOverflow = c.specificTextOverflow || r), c.css(b)) : c.styles && c.styles.width && !b.width && !g && c.css({\n            width: null\n          }), delete c.specificTextOverflow, a.rotation = f.rotation);\n        }, this);\n        this.tickRotCorr = c.rotCorr(p.b, this.labelRotation || 0, 0 !== this.side);\n      };\n\n      f.prototype.hasData = function () {\n        return this.series.some(function (a) {\n          return a.hasData();\n        }) || this.options.showEmpty && n(this.min) && n(this.max);\n      };\n\n      f.prototype.addTitle = function (a) {\n        var g = this.chart.renderer,\n            b = this.horiz,\n            d = this.opposite,\n            k = this.options.title,\n            m = this.chart.styledMode,\n            e;\n        this.axisTitle || ((e = k.textAlign) || (e = (b ? {\n          low: \"left\",\n          middle: \"center\",\n          high: \"right\"\n        } : {\n          low: d ? \"right\" : \"left\",\n          middle: \"center\",\n          high: d ? \"left\" : \"right\"\n        })[k.align]), this.axisTitle = g.text(k.text || \"\", 0, 0, k.useHTML).attr({\n          zIndex: 7,\n          rotation: k.rotation,\n          align: e\n        }).addClass(\"highcharts-axis-title\"), m || this.axisTitle.css(c(k.style)), this.axisTitle.add(this.axisGroup), this.axisTitle.isNew = !0);\n        m || k.style.width || this.isRadial || this.axisTitle.css({\n          width: this.len + \"px\"\n        });\n        this.axisTitle[a ? \"show\" : \"hide\"](a);\n      };\n\n      f.prototype.generateTick = function (a) {\n        var c = this.ticks;\n        c[a] ? c[a].addLabel() : c[a] = new G(this, a);\n      };\n\n      f.prototype.getOffset = function () {\n        var a = this,\n            c = this,\n            g = c.chart,\n            b = c.horiz,\n            d = c.options,\n            k = c.side,\n            e = c.ticks,\n            h = c.tickPositions,\n            f = c.coll,\n            p = c.axisParent,\n            D = g.renderer,\n            q = g.inverted && !c.isZAxis ? [1, 0, 3, 2][k] : k,\n            r = c.hasData(),\n            l = d.title,\n            t = d.labels,\n            x = g.axisOffset;\n        g = g.clipOffset;\n        var z = [-1, 1, 1, -1][k],\n            L = d.className,\n            w,\n            S = 0,\n            ja = 0,\n            ca = 0;\n        c.showAxis = w = r || d.showEmpty;\n        c.staggerLines = c.horiz && t.staggerLines || void 0;\n\n        if (!c.axisGroup) {\n          var J = function (c, g, b) {\n            return D.g(c).attr({\n              zIndex: b\n            }).addClass(\"highcharts-\".concat(f.toLowerCase()).concat(g, \" \") + (a.isRadial ? \"highcharts-radial-axis\".concat(g, \" \") : \"\") + (L || \"\")).add(p);\n          };\n\n          c.gridGroup = J(\"grid\", \"-grid\", d.gridZIndex);\n          c.axisGroup = J(\"axis\", \"\", d.zIndex);\n          c.labelGroup = J(\"axis-labels\", \"-labels\", t.zIndex);\n        }\n\n        r || c.isLinked ? (h.forEach(function (a) {\n          c.generateTick(a);\n        }), c.renderUnsquish(), c.reserveSpaceDefault = 0 === k || 2 === k || {\n          1: \"left\",\n          3: \"right\"\n        }[k] === c.labelAlign, u(t.reserveSpace, \"center\" === c.labelAlign ? !0 : null, c.reserveSpaceDefault) && h.forEach(function (a) {\n          ca = Math.max(e[a].getLabelSize(), ca);\n        }), c.staggerLines && (ca *= c.staggerLines), c.labelOffset = ca * (c.opposite ? -1 : 1)) : A(e, function (a, c) {\n          a.destroy();\n          delete e[c];\n        });\n\n        if (l && l.text && !1 !== l.enabled && (c.addTitle(w), w && !1 !== l.reserveSpace)) {\n          c.titleOffset = S = c.axisTitle.getBBox()[b ? \"height\" : \"width\"];\n          var M = l.offset;\n          ja = n(M) ? 0 : u(l.margin, b ? 5 : 10);\n        }\n\n        c.renderLine();\n        c.offset = z * u(d.offset, x[k] ? x[k] + (d.margin || 0) : 0);\n        c.tickRotCorr = c.tickRotCorr || {\n          x: 0,\n          y: 0\n        };\n        l = 0 === k ? -c.labelMetrics().h : 2 === k ? c.tickRotCorr.y : 0;\n        r = Math.abs(ca) + ja;\n        ca && (r = r - l + z * (b ? u(t.y, c.tickRotCorr.y + 8 * z) : t.x));\n        c.axisTitleMargin = u(M, r);\n        c.getMaxLabelDimensions && (c.maxLabelDimensions = c.getMaxLabelDimensions(e, h));\n        \"colorAxis\" !== f && (b = this.tickSize(\"tick\"), x[k] = Math.max(x[k], (c.axisTitleMargin || 0) + S + z * c.offset, r, h && h.length && b ? b[0] + z * c.offset : 0), d = !c.axisLine || d.offset ? 0 : 2 * Math.floor(c.axisLine.strokeWidth() / 2), g[q] = Math.max(g[q], d));\n        m(this, \"afterGetOffset\");\n      };\n\n      f.prototype.getLinePath = function (a) {\n        var c = this.chart,\n            g = this.opposite,\n            b = this.offset,\n            d = this.horiz,\n            k = this.left + (g ? this.width : 0) + b;\n        b = c.chartHeight - this.bottom - (g ? this.height : 0) + b;\n        g && (a *= -1);\n        return c.renderer.crispLine([[\"M\", d ? this.left : k, d ? b : this.top], [\"L\", d ? c.chartWidth - this.right : k, d ? b : c.chartHeight - this.bottom]], a);\n      };\n\n      f.prototype.renderLine = function () {\n        this.axisLine || (this.axisLine = this.chart.renderer.path().addClass(\"highcharts-axis-line\").add(this.axisGroup), this.chart.styledMode || this.axisLine.attr({\n          stroke: this.options.lineColor,\n          \"stroke-width\": this.options.lineWidth,\n          zIndex: 7\n        }));\n      };\n\n      f.prototype.getTitlePosition = function () {\n        var a = this.horiz,\n            c = this.left,\n            g = this.top,\n            b = this.len,\n            d = this.options.title,\n            k = a ? c : g,\n            e = this.opposite,\n            h = this.offset,\n            f = d.x,\n            u = d.y,\n            p = this.axisTitle,\n            n = this.chart.renderer.fontMetrics(d.style.fontSize, p);\n        p = p ? Math.max(p.getBBox(!1, 0).height - n.h - 1, 0) : 0;\n        b = {\n          low: k + (a ? 0 : b),\n          middle: k + b / 2,\n          high: k + (a ? b : 0)\n        }[d.align];\n        c = (a ? g + this.height : c) + (a ? 1 : -1) * (e ? -1 : 1) * (this.axisTitleMargin || 0) + [-p, p, n.f, -p][this.side];\n        a = {\n          x: a ? b + f : c + (e ? this.width : 0) + h + f,\n          y: a ? c + u - (e ? this.height : 0) + h : b + u\n        };\n        m(this, \"afterGetTitlePosition\", {\n          titlePosition: a\n        });\n        return a;\n      };\n\n      f.prototype.renderMinorTick = function (a, c) {\n        var g = this.minorTicks;\n        g[a] || (g[a] = new G(this, a, \"minor\"));\n        c && g[a].isNew && g[a].render(null, !0);\n        g[a].render(null, !1, 1);\n      };\n\n      f.prototype.renderTick = function (a, c, g) {\n        var b = this.ticks;\n        if (!this.isLinked || a >= this.min && a <= this.max || this.grid && this.grid.isColumn) b[a] || (b[a] = new G(this, a)), g && b[a].isNew && b[a].render(c, !0, -1), b[a].render(c);\n      };\n\n      f.prototype.render = function () {\n        var c = this,\n            g = c.chart,\n            b = c.logarithmic,\n            d = c.options,\n            k = c.isLinked,\n            e = c.tickPositions,\n            h = c.axisTitle,\n            f = c.ticks,\n            u = c.minorTicks,\n            p = c.alternateBands,\n            n = d.stackLabels,\n            D = d.alternateGridColor,\n            r = c.tickmarkOffset,\n            q = c.axisLine,\n            l = c.showAxis,\n            t = y(g.renderer.globalAnimation),\n            x,\n            z;\n        c.labelEdge.length = 0;\n        c.overlap = !1;\n        [f, u, p].forEach(function (a) {\n          A(a, function (a) {\n            a.isActive = !1;\n          });\n        });\n\n        if (c.hasData() || k) {\n          var L = c.chart.hasRendered && c.old && a(c.old.min);\n          c.minorTickInterval && !c.categories && c.getMinorTickPositions().forEach(function (a) {\n            c.renderMinorTick(a, L);\n          });\n          e.length && (e.forEach(function (a, g) {\n            c.renderTick(a, g, L);\n          }), r && (0 === c.min || c.single) && (f[-1] || (f[-1] = new G(c, -1, null, !0)), f[-1].render(-1)));\n          D && e.forEach(function (a, d) {\n            z = \"undefined\" !== typeof e[d + 1] ? e[d + 1] + r : c.max - r;\n            0 === d % 2 && a < c.max && z <= c.max + (g.polar ? -r : r) && (p[a] || (p[a] = new E.PlotLineOrBand(c)), x = a + r, p[a].options = {\n              from: b ? b.lin2log(x) : x,\n              to: b ? b.lin2log(z) : z,\n              color: D,\n              className: \"highcharts-alternate-grid\"\n            }, p[a].render(), p[a].isActive = !0);\n          });\n          c._addedPlotLB || (c._addedPlotLB = !0, (d.plotLines || []).concat(d.plotBands || []).forEach(function (a) {\n            c.addPlotBandOrLine(a);\n          }));\n        }\n\n        [f, u, p].forEach(function (a) {\n          var c = [],\n              b = t.duration;\n          A(a, function (a, g) {\n            a.isActive || (a.render(g, !1, 0), a.isActive = !1, c.push(g));\n          });\n          M(function () {\n            for (var g = c.length; g--;) a[c[g]] && !a[c[g]].isActive && (a[c[g]].destroy(), delete a[c[g]]);\n          }, a !== p && g.hasRendered && b ? b : 0);\n        });\n        q && (q[q.isPlaced ? \"animate\" : \"attr\"]({\n          d: this.getLinePath(q.strokeWidth())\n        }), q.isPlaced = !0, q[l ? \"show\" : \"hide\"](l));\n        h && l && (d = c.getTitlePosition(), h[h.isNew ? \"attr\" : \"animate\"](d), h.isNew = !1);\n        n && n.enabled && c.stacking && c.stacking.renderStackTotals();\n        c.old = {\n          len: c.len,\n          max: c.max,\n          min: c.min,\n          transA: c.transA,\n          userMax: c.userMax,\n          userMin: c.userMin\n        };\n        c.isDirty = !1;\n        m(this, \"afterRender\");\n      };\n\n      f.prototype.redraw = function () {\n        this.visible && (this.render(), this.plotLinesAndBands.forEach(function (a) {\n          a.render();\n        }));\n        this.series.forEach(function (a) {\n          a.isDirty = !0;\n        });\n      };\n\n      f.prototype.getKeepProps = function () {\n        return this.keepProps || f.keepProps;\n      };\n\n      f.prototype.destroy = function (a) {\n        var c = this,\n            g = c.plotLinesAndBands,\n            b = this.eventOptions;\n        m(this, \"destroy\", {\n          keepEvents: a\n        });\n        a || S(c);\n        [c.ticks, c.minorTicks, c.alternateBands].forEach(function (a) {\n          J(a);\n        });\n        if (g) for (a = g.length; a--;) g[a].destroy();\n        \"axisLine axisTitle axisGroup gridGroup labelGroup cross scrollbar\".split(\" \").forEach(function (a) {\n          c[a] && (c[a] = c[a].destroy());\n        });\n\n        for (var d in c.plotLinesAndBandsGroups) c.plotLinesAndBandsGroups[d] = c.plotLinesAndBandsGroups[d].destroy();\n\n        A(c, function (a, g) {\n          -1 === c.getKeepProps().indexOf(g) && delete c[g];\n        });\n        this.eventOptions = b;\n      };\n\n      f.prototype.drawCrosshair = function (a, c) {\n        var g = this.crosshair,\n            b = u(g && g.snap, !0),\n            d = this.chart,\n            k,\n            e = this.cross;\n        m(this, \"drawCrosshair\", {\n          e: a,\n          point: c\n        });\n        a || (a = this.cross && this.cross.e);\n\n        if (g && !1 !== (n(c) || !b)) {\n          b ? n(c) && (k = u(\"colorAxis\" !== this.coll ? c.crosshairPos : null, this.isXAxis ? c.plotX : this.len - c.plotY)) : k = a && (this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos);\n\n          if (n(k)) {\n            var h = {\n              value: c && (this.isXAxis ? c.x : u(c.stackY, c.y)),\n              translatedValue: k\n            };\n            d.polar && x(h, {\n              isCrosshair: !0,\n              chartX: a && a.chartX,\n              chartY: a && a.chartY,\n              point: c\n            });\n            h = this.getPlotLinePath(h) || null;\n          }\n\n          if (!n(h)) {\n            this.hideCrosshair();\n            return;\n          }\n\n          b = this.categories && !this.isRadial;\n          e || (this.cross = e = d.renderer.path().addClass(\"highcharts-crosshair highcharts-crosshair-\" + (b ? \"category \" : \"thin \") + (g.className || \"\")).attr({\n            zIndex: u(g.zIndex, 2)\n          }).add(), d.styledMode || (e.attr({\n            stroke: g.color || (b ? l.parse(\"#ccd6eb\").setOpacity(.25).get() : \"#cccccc\"),\n            \"stroke-width\": u(g.width, 1)\n          }).css({\n            \"pointer-events\": \"none\"\n          }), g.dashStyle && e.attr({\n            dashstyle: g.dashStyle\n          })));\n          e.show().attr({\n            d: h\n          });\n          b && !g.width && e.attr({\n            \"stroke-width\": this.transA\n          });\n          this.cross.e = a;\n        } else this.hideCrosshair();\n\n        m(this, \"afterDrawCrosshair\", {\n          e: a,\n          point: c\n        });\n      };\n\n      f.prototype.hideCrosshair = function () {\n        this.cross && this.cross.hide();\n        m(this, \"afterHideCrosshair\");\n      };\n\n      f.prototype.hasVerticalPanning = function () {\n        var a = this.chart.options.chart.panning;\n        return !!(a && a.enabled && /y/.test(a.type));\n      };\n\n      f.prototype.validatePositiveValue = function (c) {\n        return a(c) && 0 < c;\n      };\n\n      f.prototype.update = function (a, g) {\n        var b = this.chart;\n        a = c(this.userOptions, a);\n        this.destroy(!0);\n        this.init(b, a);\n        b.isDirtyBox = !0;\n        u(g, !0) && b.redraw();\n      };\n\n      f.prototype.remove = function (a) {\n        for (var c = this.chart, g = this.coll, b = this.series, d = b.length; d--;) b[d] && b[d].remove(!1);\n\n        w(c.axes, this);\n        w(c[g], this);\n        c[g].forEach(function (a, c) {\n          a.options.index = a.userOptions.index = c;\n        });\n        this.destroy();\n        c.isDirtyBox = !0;\n        u(a, !0) && c.redraw();\n      };\n\n      f.prototype.setTitle = function (a, c) {\n        this.update({\n          title: a\n        }, c);\n      };\n\n      f.prototype.setCategories = function (a, c) {\n        this.update({\n          categories: a\n        }, c);\n      };\n\n      f.defaultOptions = e.defaultXAxisOptions;\n      f.keepProps = \"extKey hcEvents names series userMax userMin\".split(\" \");\n      return f;\n    }();\n\n    \"\";\n    return f;\n  });\n  K(l, \"Core/Axis/DateTimeAxis.js\", [l[\"Core/Utilities.js\"]], function (f) {\n    var e = f.addEvent,\n        l = f.getMagnitude,\n        C = f.normalizeTickInterval,\n        v = f.timeUnits,\n        E;\n\n    (function (f) {\n      function B() {\n        return this.chart.time.getTimeTicks.apply(this.chart.time, arguments);\n      }\n\n      function y(d) {\n        \"datetime\" !== d.userOptions.type ? this.dateTime = void 0 : this.dateTime || (this.dateTime = new h(this));\n      }\n\n      var t = [];\n\n      f.compose = function (d) {\n        -1 === t.indexOf(d) && (t.push(d), d.keepProps.push(\"dateTime\"), d.prototype.getTimeTicks = B, e(d, \"init\", y));\n        return d;\n      };\n\n      var h = function () {\n        function d(b) {\n          this.axis = b;\n        }\n\n        d.prototype.normalizeTimeTickInterval = function (b, d) {\n          var e = d || [[\"millisecond\", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], [\"second\", [1, 2, 5, 10, 15, 30]], [\"minute\", [1, 2, 5, 10, 15, 30]], [\"hour\", [1, 2, 3, 4, 6, 8, 12]], [\"day\", [1, 2]], [\"week\", [1, 2]], [\"month\", [1, 2, 3, 4, 6]], [\"year\", null]];\n          d = e[e.length - 1];\n          var h = v[d[0]],\n              f = d[1],\n              p;\n\n          for (p = 0; p < e.length && !(d = e[p], h = v[d[0]], f = d[1], e[p + 1] && b <= (h * f[f.length - 1] + v[e[p + 1][0]]) / 2); p++);\n\n          h === v.year && b < 5 * h && (f = [1, 2, 5]);\n          b = C(b / h, f, \"year\" === d[0] ? Math.max(l(b / h), 1) : 1);\n          return {\n            unitRange: h,\n            count: b,\n            unitName: d[0]\n          };\n        };\n\n        d.prototype.getXDateFormat = function (b, d) {\n          var e = this.axis,\n              h = e.chart.time;\n          return e.closestPointRange ? h.getDateFormat(e.closestPointRange, b, e.options.startOfWeek, d) || h.resolveDTLFormat(d.year).main : h.resolveDTLFormat(d.day).main;\n        };\n\n        return d;\n      }();\n\n      f.Additions = h;\n    })(E || (E = {}));\n\n    return E;\n  });\n  K(l, \"Core/Axis/LogarithmicAxis.js\", [l[\"Core/Utilities.js\"]], function (f) {\n    var e = f.addEvent,\n        l = f.normalizeTickInterval,\n        C = f.pick,\n        v;\n\n    (function (f) {\n      function v(e) {\n        var d = this.logarithmic;\n        \"logarithmic\" !== e.userOptions.type ? this.logarithmic = void 0 : d || (this.logarithmic = new t(this));\n      }\n\n      function B() {\n        var e = this.logarithmic;\n        e && (this.lin2val = function (d) {\n          return e.lin2log(d);\n        }, this.val2lin = function (d) {\n          return e.log2lin(d);\n        });\n      }\n\n      var y = [];\n\n      f.compose = function (h) {\n        -1 === y.indexOf(h) && (y.push(h), h.keepProps.push(\"logarithmic\"), e(h, \"init\", v), e(h, \"afterInit\", B));\n        return h;\n      };\n\n      var t = function () {\n        function e(d) {\n          this.axis = d;\n        }\n\n        e.prototype.getLogTickPositions = function (d, b, e, h) {\n          var f = this.axis,\n              p = f.len,\n              q = f.options,\n              t = [];\n          h || (this.minorAutoInterval = void 0);\n          if (.5 <= d) d = Math.round(d), t = f.getLinearTickPositions(d, b, e);else if (.08 <= d) {\n            var z = Math.floor(b),\n                x,\n                m = q = void 0;\n\n            for (p = .3 < d ? [1, 2, 4] : .15 < d ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; z < e + 1 && !m; z++) {\n              var k = p.length;\n\n              for (x = 0; x < k && !m; x++) {\n                var a = this.log2lin(this.lin2log(z) * p[x]);\n                a > b && (!h || q <= e) && \"undefined\" !== typeof q && t.push(q);\n                q > e && (m = !0);\n                q = a;\n              }\n            }\n          } else b = this.lin2log(b), e = this.lin2log(e), d = h ? f.getMinorTickInterval() : q.tickInterval, d = C(\"auto\" === d ? null : d, this.minorAutoInterval, q.tickPixelInterval / (h ? 5 : 1) * (e - b) / ((h ? p / f.tickPositions.length : p) || 1)), d = l(d), t = f.getLinearTickPositions(d, b, e).map(this.log2lin), h || (this.minorAutoInterval = d / 5);\n          h || (f.tickInterval = d);\n          return t;\n        };\n\n        e.prototype.lin2log = function (d) {\n          return Math.pow(10, d);\n        };\n\n        e.prototype.log2lin = function (d) {\n          return Math.log(d) / Math.LN10;\n        };\n\n        return e;\n      }();\n\n      f.Additions = t;\n    })(v || (v = {}));\n\n    return v;\n  });\n  K(l, \"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\", [l[\"Core/Utilities.js\"]], function (f) {\n    var e = f.erase,\n        l = f.extend,\n        C = f.isNumber,\n        v;\n\n    (function (f) {\n      var v = [],\n          B;\n\n      f.compose = function (e, h) {\n        B || (B = e);\n        -1 === v.indexOf(h) && (v.push(h), l(h.prototype, y.prototype));\n        return h;\n      };\n\n      var y = function () {\n        function f() {}\n\n        f.prototype.getPlotBandPath = function (e, d, b) {\n          void 0 === b && (b = this.options);\n          var h = this.getPlotLinePath({\n            value: d,\n            force: !0,\n            acrossPanes: b.acrossPanes\n          }),\n              f = [],\n              r = this.horiz;\n          d = !C(this.min) || !C(this.max) || e < this.min && d < this.min || e > this.max && d > this.max;\n          e = this.getPlotLinePath({\n            value: e,\n            force: !0,\n            acrossPanes: b.acrossPanes\n          });\n          b = 1;\n\n          if (e && h) {\n            if (d) {\n              var n = e.toString() === h.toString();\n              b = 0;\n            }\n\n            for (d = 0; d < e.length; d += 2) {\n              var l = e[d],\n                  t = e[d + 1],\n                  z = h[d],\n                  x = h[d + 1];\n              \"M\" !== l[0] && \"L\" !== l[0] || \"M\" !== t[0] && \"L\" !== t[0] || \"M\" !== z[0] && \"L\" !== z[0] || \"M\" !== x[0] && \"L\" !== x[0] || (r && z[1] === l[1] ? (z[1] += b, x[1] += b) : r || z[2] !== l[2] || (z[2] += b, x[2] += b), f.push([\"M\", l[1], l[2]], [\"L\", t[1], t[2]], [\"L\", x[1], x[2]], [\"L\", z[1], z[2]], [\"Z\"]));\n              f.isFlat = n;\n            }\n          }\n\n          return f;\n        };\n\n        f.prototype.addPlotBand = function (e) {\n          return this.addPlotBandOrLine(e, \"plotBands\");\n        };\n\n        f.prototype.addPlotLine = function (e) {\n          return this.addPlotBandOrLine(e, \"plotLines\");\n        };\n\n        f.prototype.addPlotBandOrLine = function (e, d) {\n          var b = this,\n              f = this.userOptions,\n              h = new B(this, e);\n          this.visible && (h = h.render());\n\n          if (h) {\n            this._addedPlotLB || (this._addedPlotLB = !0, (f.plotLines || []).concat(f.plotBands || []).forEach(function (d) {\n              b.addPlotBandOrLine(d);\n            }));\n\n            if (d) {\n              var r = f[d] || [];\n              r.push(e);\n              f[d] = r;\n            }\n\n            this.plotLinesAndBands.push(h);\n          }\n\n          return h;\n        };\n\n        f.prototype.removePlotBandOrLine = function (f) {\n          var d = this.plotLinesAndBands,\n              b = this.options,\n              h = this.userOptions;\n\n          if (d) {\n            for (var q = d.length; q--;) d[q].id === f && d[q].destroy();\n\n            [b.plotLines || [], h.plotLines || [], b.plotBands || [], h.plotBands || []].forEach(function (b) {\n              for (q = b.length; q--;) (b[q] || {}).id === f && e(b, b[q]);\n            });\n          }\n        };\n\n        f.prototype.removePlotBand = function (e) {\n          this.removePlotBandOrLine(e);\n        };\n\n        f.prototype.removePlotLine = function (e) {\n          this.removePlotBandOrLine(e);\n        };\n\n        return f;\n      }();\n    })(v || (v = {}));\n\n    return v;\n  });\n  K(l, \"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\", [l[\"Core/Axis/PlotLineOrBand/PlotLineOrBandAxis.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    var l = e.arrayMax,\n        C = e.arrayMin,\n        v = e.defined,\n        E = e.destroyObjectProperties,\n        G = e.erase,\n        B = e.fireEvent,\n        y = e.merge,\n        t = e.objectEach,\n        h = e.pick;\n\n    e = function () {\n      function d(b, d) {\n        this.axis = b;\n        d && (this.options = d, this.id = d.id);\n      }\n\n      d.compose = function (b) {\n        return f.compose(d, b);\n      };\n\n      d.prototype.render = function () {\n        B(this, \"render\");\n        var b = this,\n            d = b.axis,\n            e = d.horiz,\n            f = d.logarithmic,\n            n = b.options,\n            l = n.color,\n            w = h(n.zIndex, 0),\n            z = n.events,\n            x = {},\n            m = d.chart.renderer,\n            k = n.label,\n            a = b.label,\n            g = n.to,\n            c = n.from,\n            D = n.value,\n            A = b.svgElem,\n            u = [],\n            L = v(c) && v(g);\n        u = v(D);\n        var S = !A,\n            R = {\n          \"class\": \"highcharts-plot-\" + (L ? \"band \" : \"line \") + (n.className || \"\")\n        },\n            M = L ? \"bands\" : \"lines\";\n        f && (c = f.log2lin(c), g = f.log2lin(g), D = f.log2lin(D));\n        d.chart.styledMode || (u ? (R.stroke = l || \"#999999\", R[\"stroke-width\"] = h(n.width, 1), n.dashStyle && (R.dashstyle = n.dashStyle)) : L && (R.fill = l || \"#e6ebf5\", n.borderWidth && (R.stroke = n.borderColor, R[\"stroke-width\"] = n.borderWidth)));\n        x.zIndex = w;\n        M += \"-\" + w;\n        (f = d.plotLinesAndBandsGroups[M]) || (d.plotLinesAndBandsGroups[M] = f = m.g(\"plot-\" + M).attr(x).add());\n        S && (b.svgElem = A = m.path().attr(R).add(f));\n        if (u) u = d.getPlotLinePath({\n          value: D,\n          lineWidth: A.strokeWidth(),\n          acrossPanes: n.acrossPanes\n        });else if (L) u = d.getPlotBandPath(c, g, n);else return;\n        !b.eventsAdded && z && (t(z, function (a, c) {\n          A.on(c, function (a) {\n            z[c].apply(b, [a]);\n          });\n        }), b.eventsAdded = !0);\n        (S || !A.d) && u && u.length ? A.attr({\n          d: u\n        }) : A && (u ? (A.show(), A.animate({\n          d: u\n        })) : A.d && (A.hide(), a && (b.label = a = a.destroy())));\n        k && (v(k.text) || v(k.formatter)) && u && u.length && 0 < d.width && 0 < d.height && !u.isFlat ? (k = y({\n          align: e && L && \"center\",\n          x: e ? !L && 4 : 10,\n          verticalAlign: !e && L && \"middle\",\n          y: e ? L ? 16 : 10 : L ? 6 : -4,\n          rotation: e && !L && 90\n        }, k), this.renderLabel(k, u, L, w)) : a && a.hide();\n        return b;\n      };\n\n      d.prototype.renderLabel = function (b, d, e, f) {\n        var h = this.axis,\n            p = h.chart.renderer,\n            r = this.label;\n        r || (this.label = r = p.text(this.getLabelText(b), 0, 0, b.useHTML).attr({\n          align: b.textAlign || b.align,\n          rotation: b.rotation,\n          \"class\": \"highcharts-plot-\" + (e ? \"band\" : \"line\") + \"-label \" + (b.className || \"\"),\n          zIndex: f\n        }).add(), h.chart.styledMode || r.css(y({\n          textOverflow: \"ellipsis\"\n        }, b.style)));\n        f = d.xBounds || [d[0][1], d[1][1], e ? d[2][1] : d[0][1]];\n        d = d.yBounds || [d[0][2], d[1][2], e ? d[2][2] : d[0][2]];\n        e = C(f);\n        p = C(d);\n        r.align(b, !1, {\n          x: e,\n          y: p,\n          width: l(f) - e,\n          height: l(d) - p\n        });\n        r.alignValue && \"left\" !== r.alignValue || r.css({\n          width: (90 === r.rotation ? h.height - (r.alignAttr.y - h.top) : h.width - (r.alignAttr.x - h.left)) + \"px\"\n        });\n        r.show(!0);\n      };\n\n      d.prototype.getLabelText = function (b) {\n        return v(b.formatter) ? b.formatter.call(this) : b.text;\n      };\n\n      d.prototype.destroy = function () {\n        G(this.axis.plotLinesAndBands, this);\n        delete this.axis;\n        E(this);\n      };\n\n      return d;\n    }();\n\n    \"\";\n    \"\";\n    return e;\n  });\n  K(l, \"Core/Tooltip.js\", [l[\"Core/FormatUtilities.js\"], l[\"Core/Globals.js\"], l[\"Core/Renderer/RendererUtilities.js\"], l[\"Core/Renderer/RendererRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v) {\n    var E = f.format,\n        G = e.doc,\n        B = l.distribute,\n        y = v.addEvent,\n        t = v.clamp,\n        h = v.css,\n        d = v.defined,\n        b = v.discardElement,\n        p = v.extend,\n        q = v.fireEvent,\n        r = v.isArray,\n        n = v.isNumber,\n        J = v.isString,\n        w = v.merge,\n        z = v.pick,\n        x = v.splat,\n        m = v.syncTimeout;\n\n    f = function () {\n      function k(a, g) {\n        this.allowShared = !0;\n        this.container = void 0;\n        this.crosshairs = [];\n        this.distance = 0;\n        this.isHidden = !0;\n        this.isSticky = !1;\n        this.now = {};\n        this.options = {};\n        this.outside = !1;\n        this.chart = a;\n        this.init(a, g);\n      }\n\n      k.prototype.applyFilter = function () {\n        var a = this.chart;\n        a.renderer.definition({\n          tagName: \"filter\",\n          attributes: {\n            id: \"drop-shadow-\" + a.index,\n            opacity: .5\n          },\n          children: [{\n            tagName: \"feGaussianBlur\",\n            attributes: {\n              \"in\": \"SourceAlpha\",\n              stdDeviation: 1\n            }\n          }, {\n            tagName: \"feOffset\",\n            attributes: {\n              dx: 1,\n              dy: 1\n            }\n          }, {\n            tagName: \"feComponentTransfer\",\n            children: [{\n              tagName: \"feFuncA\",\n              attributes: {\n                type: \"linear\",\n                slope: .3\n              }\n            }]\n          }, {\n            tagName: \"feMerge\",\n            children: [{\n              tagName: \"feMergeNode\"\n            }, {\n              tagName: \"feMergeNode\",\n              attributes: {\n                \"in\": \"SourceGraphic\"\n              }\n            }]\n          }]\n        });\n      };\n\n      k.prototype.bodyFormatter = function (a) {\n        return a.map(function (a) {\n          var c = a.series.tooltipOptions;\n          return (c[(a.point.formatPrefix || \"point\") + \"Formatter\"] || a.point.tooltipFormatter).call(a.point, c[(a.point.formatPrefix || \"point\") + \"Format\"] || \"\");\n        });\n      };\n\n      k.prototype.cleanSplit = function (a) {\n        this.chart.series.forEach(function (g) {\n          var c = g && g.tt;\n          c && (!c.isActive || a ? g.tt = c.destroy() : c.isActive = !1);\n        });\n      };\n\n      k.prototype.defaultFormatter = function (a) {\n        var g = this.points || x(this);\n        var c = [a.tooltipFooterHeaderFormatter(g[0])];\n        c = c.concat(a.bodyFormatter(g));\n        c.push(a.tooltipFooterHeaderFormatter(g[0], !0));\n        return c;\n      };\n\n      k.prototype.destroy = function () {\n        this.label && (this.label = this.label.destroy());\n        this.split && this.tt && (this.cleanSplit(!0), this.tt = this.tt.destroy());\n        this.renderer && (this.renderer = this.renderer.destroy(), b(this.container));\n        v.clearTimeout(this.hideTimer);\n        v.clearTimeout(this.tooltipTimeout);\n      };\n\n      k.prototype.getAnchor = function (a, g) {\n        var c = this.chart,\n            b = c.pointer,\n            d = c.inverted,\n            k = c.plotTop,\n            e = c.plotLeft,\n            m,\n            f,\n            h = 0,\n            p = 0;\n        a = x(a);\n        this.followPointer && g ? (\"undefined\" === typeof g.chartX && (g = b.normalize(g)), b = [g.chartX - e, g.chartY - k]) : a[0].tooltipPos ? b = a[0].tooltipPos : (a.forEach(function (a) {\n          m = a.series.yAxis;\n          f = a.series.xAxis;\n          h += a.plotX || 0;\n          p += a.plotLow ? (a.plotLow + (a.plotHigh || 0)) / 2 : a.plotY || 0;\n          f && m && (d ? (h += k + c.plotHeight - f.len - f.pos, p += e + c.plotWidth - m.len - m.pos) : (h += f.pos - e, p += m.pos - k));\n        }), h /= a.length, p /= a.length, b = [d ? c.plotWidth - p : h, d ? c.plotHeight - h : p], this.shared && 1 < a.length && g && (d ? b[0] = g.chartX - e : b[1] = g.chartY - k));\n        return b.map(Math.round);\n      };\n\n      k.prototype.getLabel = function () {\n        var a = this,\n            g = this.chart.styledMode,\n            c = this.options,\n            b = this.split && this.allowShared,\n            k = \"tooltip\" + (d(c.className) ? \" \" + c.className : \"\"),\n            m = c.style.pointerEvents || (!this.followPointer && c.stickOnContact ? \"auto\" : \"none\"),\n            f = function () {\n          a.inContact = !0;\n        },\n            p = function (c) {\n          var g = a.chart.hoverSeries;\n          a.inContact = a.shouldStickOnContact() && a.chart.pointer.inClass(c.relatedTarget, \"highcharts-tooltip\");\n          if (!a.inContact && g && g.onMouseOut) g.onMouseOut();\n        },\n            n,\n            r = this.chart.renderer;\n\n        if (a.label) {\n          var q = !a.label.hasClass(\"highcharts-label\");\n          (b && !q || !b && q) && a.destroy();\n        }\n\n        if (!this.label) {\n          if (this.outside) {\n            q = this.chart.options.chart.style;\n            var l = C.getRendererType();\n            this.container = n = e.doc.createElement(\"div\");\n            n.className = \"highcharts-tooltip-container\";\n            h(n, {\n              position: \"absolute\",\n              top: \"1px\",\n              pointerEvents: m,\n              zIndex: Math.max(this.options.style.zIndex || 0, (q && q.zIndex || 0) + 3)\n            });\n            y(n, \"mouseenter\", f);\n            y(n, \"mouseleave\", p);\n            e.doc.body.appendChild(n);\n            this.renderer = r = new l(n, 0, 0, q, void 0, void 0, r.styledMode);\n          }\n\n          b ? this.label = r.g(k) : (this.label = r.label(\"\", 0, 0, c.shape, void 0, void 0, c.useHTML, void 0, k).attr({\n            padding: c.padding,\n            r: c.borderRadius\n          }), g || this.label.attr({\n            fill: c.backgroundColor,\n            \"stroke-width\": c.borderWidth\n          }).css(c.style).css({\n            pointerEvents: m\n          }).shadow(c.shadow));\n          g && c.shadow && (this.applyFilter(), this.label.attr({\n            filter: \"url(#drop-shadow-\" + this.chart.index + \")\"\n          }));\n\n          if (a.outside && !a.split) {\n            var t = this.label,\n                x = t.xSetter,\n                z = t.ySetter;\n\n            t.xSetter = function (c) {\n              x.call(t, a.distance);\n              n.style.left = c + \"px\";\n            };\n\n            t.ySetter = function (c) {\n              z.call(t, a.distance);\n              n.style.top = c + \"px\";\n            };\n          }\n\n          this.label.on(\"mouseenter\", f).on(\"mouseleave\", p).attr({\n            zIndex: 8\n          }).add();\n        }\n\n        return this.label;\n      };\n\n      k.prototype.getPosition = function (a, g, c) {\n        var b = this.chart,\n            d = this.distance,\n            k = {},\n            e = b.inverted && c.h || 0,\n            m = this.outside,\n            f = m ? G.documentElement.clientWidth - 2 * d : b.chartWidth,\n            h = m ? Math.max(G.body.scrollHeight, G.documentElement.scrollHeight, G.body.offsetHeight, G.documentElement.offsetHeight, G.documentElement.clientHeight) : b.chartHeight,\n            p = b.pointer.getChartPosition(),\n            n = function (k) {\n          var e = \"x\" === k;\n          return [k, e ? f : h, e ? a : g].concat(m ? [e ? a * p.scaleX : g * p.scaleY, e ? p.left - d + (c.plotX + b.plotLeft) * p.scaleX : p.top - d + (c.plotY + b.plotTop) * p.scaleY, 0, e ? f : h] : [e ? a : g, e ? c.plotX + b.plotLeft : c.plotY + b.plotTop, e ? b.plotLeft : b.plotTop, e ? b.plotLeft + b.plotWidth : b.plotTop + b.plotHeight]);\n        },\n            r = n(\"y\"),\n            q = n(\"x\"),\n            l;\n\n        n = !!c.negative;\n        !b.polar && b.hoverSeries && b.hoverSeries.yAxis && b.hoverSeries.yAxis.reversed && (n = !n);\n\n        var t = !this.followPointer && z(c.ttBelow, !b.inverted === n),\n            x = function (a, c, g, b, f, h, u) {\n          var n = m ? \"y\" === a ? d * p.scaleY : d * p.scaleX : d,\n              A = (g - b) / 2,\n              D = b < f - d,\n              F = f + d + b < c,\n              r = f - n - g + A;\n          f = f + n - A;\n          if (t && F) k[a] = f;else if (!t && D) k[a] = r;else if (D) k[a] = Math.min(u - b, 0 > r - e ? r : r - e);else if (F) k[a] = Math.max(h, f + e + g > c ? f : f + e);else return !1;\n        },\n            w = function (a, c, g, b, e) {\n          var m;\n          e < d || e > c - d ? m = !1 : k[a] = e < g / 2 ? 1 : e > c - b / 2 ? c - b - 2 : e - g / 2;\n          return m;\n        },\n            F = function (a) {\n          var c = r;\n          r = q;\n          q = c;\n          l = a;\n        },\n            T = function () {\n          !1 !== x.apply(0, r) ? !1 !== w.apply(0, q) || l || (F(!0), T()) : l ? k.x = k.y = 0 : (F(!0), T());\n        };\n\n        (b.inverted || 1 < this.len) && F();\n        T();\n        return k;\n      };\n\n      k.prototype.hide = function (a) {\n        var g = this;\n        v.clearTimeout(this.hideTimer);\n        a = z(a, this.options.hideDelay);\n        this.isHidden || (this.hideTimer = m(function () {\n          g.getLabel().fadeOut(a ? void 0 : a);\n          g.isHidden = !0;\n        }, a));\n      };\n\n      k.prototype.init = function (a, g) {\n        this.chart = a;\n        this.options = g;\n        this.crosshairs = [];\n        this.now = {\n          x: 0,\n          y: 0\n        };\n        this.isHidden = !0;\n        this.split = g.split && !a.inverted && !a.polar;\n        this.shared = g.shared || this.split;\n        this.outside = z(g.outside, !(!a.scrollablePixelsX && !a.scrollablePixelsY));\n      };\n\n      k.prototype.shouldStickOnContact = function () {\n        return !(this.followPointer || !this.options.stickOnContact);\n      };\n\n      k.prototype.isStickyOnContact = function () {\n        return !(!this.shouldStickOnContact() || !this.inContact);\n      };\n\n      k.prototype.move = function (a, g, c, b) {\n        var d = this,\n            k = d.now,\n            e = !1 !== d.options.animation && !d.isHidden && (1 < Math.abs(a - k.x) || 1 < Math.abs(g - k.y)),\n            m = d.followPointer || 1 < d.len;\n        p(k, {\n          x: e ? (2 * k.x + a) / 3 : a,\n          y: e ? (k.y + g) / 2 : g,\n          anchorX: m ? void 0 : e ? (2 * k.anchorX + c) / 3 : c,\n          anchorY: m ? void 0 : e ? (k.anchorY + b) / 2 : b\n        });\n        d.getLabel().attr(k);\n        d.drawTracker();\n        e && (v.clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {\n          d && d.move(a, g, c, b);\n        }, 32));\n      };\n\n      k.prototype.refresh = function (a, g) {\n        var c = this.chart,\n            b = this.options,\n            d = x(a),\n            k = d[0],\n            e = [],\n            m = b.formatter || this.defaultFormatter,\n            f = this.shared,\n            h = c.styledMode,\n            p = {};\n\n        if (b.enabled && k.series) {\n          v.clearTimeout(this.hideTimer);\n          this.allowShared = !(!r(a) && a.series && a.series.noSharedTooltip);\n          this.followPointer = !this.split && k.series.tooltipOptions.followPointer;\n          a = this.getAnchor(a, g);\n          var n = a[0],\n              l = a[1];\n          f && this.allowShared ? (c.pointer.applyInactiveState(d), d.forEach(function (a) {\n            a.setState(\"hover\");\n            e.push(a.getLabelConfig());\n          }), p = {\n            x: k.category,\n            y: k.y\n          }, p.points = e) : p = k.getLabelConfig();\n          this.len = e.length;\n          m = m.call(p, this);\n          f = k.series;\n          this.distance = z(f.tooltipOptions.distance, 16);\n          if (!1 === m) this.hide();else {\n            if (this.split && this.allowShared) this.renderSplit(m, d);else {\n              var t = n,\n                  w = l;\n              g && c.pointer.isDirectTouch && (t = g.chartX - c.plotLeft, w = g.chartY - c.plotTop);\n              if (c.polar || !1 === f.options.clip || d.some(function (a) {\n                return a.series.shouldShowTooltip(t, w);\n              })) g = this.getLabel(), b.style.width && !h || g.css({\n                width: this.chart.spacingBox.width + \"px\"\n              }), g.attr({\n                text: m && m.join ? m.join(\"\") : m\n              }), g.removeClass(/highcharts-color-[\\d]+/g).addClass(\"highcharts-color-\" + z(k.colorIndex, f.colorIndex)), h || g.attr({\n                stroke: b.borderColor || k.color || f.color || \"#666666\"\n              }), this.updatePosition({\n                plotX: n,\n                plotY: l,\n                negative: k.negative,\n                ttBelow: k.ttBelow,\n                h: a[2] || 0\n              });else {\n                this.hide();\n                return;\n              }\n            }\n            this.isHidden && this.label && this.label.attr({\n              opacity: 1\n            }).show();\n            this.isHidden = !1;\n          }\n          q(this, \"refresh\");\n        }\n      };\n\n      k.prototype.renderSplit = function (a, g) {\n        function c(a, c, g, d, k) {\n          void 0 === k && (k = !0);\n          g ? (c = X ? 0 : E, a = t(a - d / 2, N.left, N.right - d - (b.outside ? Q : 0))) : (c -= Z, a = k ? a - d - v : a + v, a = t(a, k ? a : N.left, N.right));\n          return {\n            x: a,\n            y: c\n          };\n        }\n\n        var b = this,\n            d = b.chart,\n            k = b.chart,\n            e = k.chartWidth,\n            m = k.chartHeight,\n            f = k.plotHeight,\n            h = k.plotLeft,\n            n = k.plotTop,\n            r = k.pointer,\n            q = k.scrollablePixelsY;\n        q = void 0 === q ? 0 : q;\n        var l = k.scrollablePixelsX,\n            x = k.scrollingContainer;\n        x = void 0 === x ? {\n          scrollLeft: 0,\n          scrollTop: 0\n        } : x;\n        var w = x.scrollLeft;\n        x = x.scrollTop;\n        var y = k.styledMode,\n            v = b.distance,\n            F = b.options,\n            T = b.options.positioner,\n            N = b.outside && \"number\" !== typeof l ? G.documentElement.getBoundingClientRect() : {\n          left: w,\n          right: w + e,\n          top: x,\n          bottom: x + m\n        },\n            V = b.getLabel(),\n            W = this.renderer || d.renderer,\n            X = !(!d.xAxis[0] || !d.xAxis[0].opposite);\n        d = r.getChartPosition();\n        var Q = d.left;\n        d = d.top;\n        var Z = n + x,\n            ba = 0,\n            E = f - q;\n        J(a) && (a = [!1, a]);\n        a = a.slice(0, g.length + 1).reduce(function (a, d, k) {\n          if (!1 !== d && \"\" !== d) {\n            k = g[k - 1] || {\n              isHeader: !0,\n              plotX: g[0].plotX,\n              plotY: f,\n              series: {}\n            };\n            var e = k.isHeader,\n                m = e ? b : k.series;\n            d = d.toString();\n            var u = m.tt,\n                p = k.isHeader;\n            var A = k.series;\n            var D = \"highcharts-color-\" + z(k.colorIndex, A.colorIndex, \"none\");\n            u || (u = {\n              padding: F.padding,\n              r: F.borderRadius\n            }, y || (u.fill = F.backgroundColor, u[\"stroke-width\"] = F.borderWidth), u = W.label(\"\", 0, 0, F[p ? \"headerShape\" : \"shape\"], void 0, void 0, F.useHTML).addClass((p ? \"highcharts-tooltip-header \" : \"\") + \"highcharts-tooltip-box \" + D).attr(u).add(V));\n            u.isActive = !0;\n            u.attr({\n              text: d\n            });\n            y || u.css(F.style).shadow(F.shadow).attr({\n              stroke: F.borderColor || k.color || A.color || \"#333333\"\n            });\n            m = m.tt = u;\n            p = m.getBBox();\n            d = p.width + m.strokeWidth();\n            e && (ba = p.height, E += ba, X && (Z -= ba));\n            A = k.plotX;\n            A = void 0 === A ? 0 : A;\n            D = k.plotY;\n            D = void 0 === D ? 0 : D;\n            u = k.series;\n\n            if (k.isHeader) {\n              A = h + A;\n              var r = n + f / 2;\n            } else {\n              var q = u.xAxis,\n                  l = u.yAxis;\n              A = q.pos + t(A, -v, q.len + v);\n              u.shouldShowTooltip(0, l.pos - n + D, {\n                ignoreX: !0\n              }) && (r = l.pos + D);\n            }\n\n            A = t(A, N.left - v, N.right + v);\n            \"number\" === typeof r ? (p = p.height + 1, D = T ? T.call(b, d, p, k) : c(A, r, e, d), a.push({\n              align: T ? 0 : void 0,\n              anchorX: A,\n              anchorY: r,\n              boxWidth: d,\n              point: k,\n              rank: z(D.rank, e ? 1 : 0),\n              size: p,\n              target: D.y,\n              tt: m,\n              x: D.x\n            })) : m.isActive = !1;\n          }\n\n          return a;\n        }, []);\n        !T && a.some(function (a) {\n          var c = (b.outside ? Q : 0) + a.anchorX;\n          return c < N.left && c + a.boxWidth < N.right ? !0 : c < Q - N.left + a.boxWidth && N.right - c > c;\n        }) && (a = a.map(function (a) {\n          var b = c(a.anchorX, a.anchorY, a.point.isHeader, a.boxWidth, !1);\n          return p(a, {\n            target: b.y,\n            x: b.x\n          });\n        }));\n        b.cleanSplit();\n        B(a, E);\n        var C = Q,\n            P = Q;\n        a.forEach(function (a) {\n          var c = a.x,\n              g = a.boxWidth;\n          a = a.isHeader;\n          a || (b.outside && Q + c < C && (C = Q + c), !a && b.outside && C + g > P && (P = Q + c));\n        });\n        a.forEach(function (a) {\n          var c = a.x,\n              g = a.anchorX,\n              d = a.pos,\n              k = a.point.isHeader;\n          d = {\n            visibility: \"undefined\" === typeof d ? \"hidden\" : \"inherit\",\n            x: c,\n            y: d + Z,\n            anchorX: g,\n            anchorY: a.anchorY\n          };\n\n          if (b.outside && c < g) {\n            var e = Q - C;\n            0 < e && (k || (d.x = c + e, d.anchorX = g + e), k && (d.x = (P - C) / 2, d.anchorX = g + e));\n          }\n\n          a.tt.attr(d);\n        });\n        a = b.container;\n        q = b.renderer;\n        b.outside && a && q && (k = V.getBBox(), q.setSize(k.width + k.x, k.height + k.y, !1), a.style.left = C + \"px\", a.style.top = d + \"px\");\n      };\n\n      k.prototype.drawTracker = function () {\n        if (this.followPointer || !this.options.stickOnContact) this.tracker && this.tracker.destroy();else {\n          var a = this.chart,\n              b = this.label,\n              c = this.shared ? a.hoverPoints : a.hoverPoint;\n\n          if (b && c) {\n            var d = {\n              x: 0,\n              y: 0,\n              width: 0,\n              height: 0\n            };\n            c = this.getAnchor(c);\n            var k = b.getBBox();\n            c[0] += a.plotLeft - b.translateX;\n            c[1] += a.plotTop - b.translateY;\n            d.x = Math.min(0, c[0]);\n            d.y = Math.min(0, c[1]);\n            d.width = 0 > c[0] ? Math.max(Math.abs(c[0]), k.width - c[0]) : Math.max(Math.abs(c[0]), k.width);\n            d.height = 0 > c[1] ? Math.max(Math.abs(c[1]), k.height - Math.abs(c[1])) : Math.max(Math.abs(c[1]), k.height);\n            this.tracker ? this.tracker.attr(d) : (this.tracker = b.renderer.rect(d).addClass(\"highcharts-tracker\").add(b), a.styledMode || this.tracker.attr({\n              fill: \"rgba(0,0,0,0)\"\n            }));\n          }\n        }\n      };\n\n      k.prototype.styledModeFormat = function (a) {\n        return a.replace('style=\"font-size: 10px\"', 'class=\"highcharts-header\"').replace(/style=\"color:{(point|series)\\.color}\"/g, 'class=\"highcharts-color-{$1.colorIndex}\"');\n      };\n\n      k.prototype.tooltipFooterHeaderFormatter = function (a, b) {\n        var c = a.series,\n            g = c.tooltipOptions,\n            d = c.xAxis,\n            k = d && d.dateTime;\n        d = {\n          isFooter: b,\n          labelConfig: a\n        };\n        var e = g.xDateFormat,\n            m = g[b ? \"footerFormat\" : \"headerFormat\"];\n        q(this, \"headerFormatter\", d, function (b) {\n          k && !e && n(a.key) && (e = k.getXDateFormat(a.key, g.dateTimeLabelFormats));\n          k && e && (a.point && a.point.tooltipDateKeys || [\"key\"]).forEach(function (a) {\n            m = m.replace(\"{point.\" + a + \"}\", \"{point.\" + a + \":\" + e + \"}\");\n          });\n          c.chart.styledMode && (m = this.styledModeFormat(m));\n          b.text = E(m, {\n            point: a,\n            series: c\n          }, this.chart);\n        });\n        return d.text;\n      };\n\n      k.prototype.update = function (a) {\n        this.destroy();\n        w(!0, this.chart.options.tooltip.userOptions, a);\n        this.init(this.chart, w(!0, this.options, a));\n      };\n\n      k.prototype.updatePosition = function (a) {\n        var b = this.chart,\n            c = this.options,\n            d = b.pointer,\n            k = this.getLabel();\n        d = d.getChartPosition();\n        var e = (c.positioner || this.getPosition).call(this, k.width, k.height, a),\n            m = a.plotX + b.plotLeft;\n        a = a.plotY + b.plotTop;\n\n        if (this.outside) {\n          c = c.borderWidth + 2 * this.distance;\n          this.renderer.setSize(k.width + c, k.height + c, !1);\n          if (1 !== d.scaleX || 1 !== d.scaleY) h(this.container, {\n            transform: \"scale(\".concat(d.scaleX, \", \").concat(d.scaleY, \")\")\n          }), m *= d.scaleX, a *= d.scaleY;\n          m += d.left - e.x;\n          a += d.top - e.y;\n        }\n\n        this.move(Math.round(e.x), Math.round(e.y || 0), m, a);\n      };\n\n      return k;\n    }();\n\n    \"\";\n    return f;\n  });\n  K(l, \"Core/Series/Point.js\", [l[\"Core/Renderer/HTML/AST.js\"], l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/DefaultOptions.js\"], l[\"Core/FormatUtilities.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v) {\n    var E = e.animObject,\n        G = l.defaultOptions,\n        B = C.format,\n        y = v.addEvent,\n        t = v.defined,\n        h = v.erase,\n        d = v.extend,\n        b = v.fireEvent,\n        p = v.getNestedProperty,\n        q = v.isArray,\n        r = v.isFunction,\n        n = v.isNumber,\n        J = v.isObject,\n        w = v.merge,\n        z = v.objectEach,\n        x = v.pick,\n        m = v.syncTimeout,\n        k = v.removeEvent,\n        a = v.uniqueKey;\n\n    e = function () {\n      function g() {\n        this.colorIndex = this.category = void 0;\n        this.formatPrefix = \"point\";\n        this.id = void 0;\n        this.isNull = !1;\n        this.percentage = this.options = this.name = void 0;\n        this.selected = !1;\n        this.total = this.shapeArgs = this.series = void 0;\n        this.visible = !0;\n        this.x = void 0;\n      }\n\n      g.prototype.animateBeforeDestroy = function () {\n        var a = this,\n            b = {\n          x: a.startXPos,\n          opacity: 0\n        },\n            g = a.getGraphicalProps();\n        g.singular.forEach(function (c) {\n          a[c] = a[c].animate(\"dataLabel\" === c ? {\n            x: a[c].startXPos,\n            y: a[c].startYPos,\n            opacity: 0\n          } : b);\n        });\n        g.plural.forEach(function (c) {\n          a[c].forEach(function (c) {\n            c.element && c.animate(d({\n              x: a.startXPos\n            }, c.startYPos ? {\n              x: c.startXPos,\n              y: c.startYPos\n            } : {}));\n          });\n        });\n      };\n\n      g.prototype.applyOptions = function (a, b) {\n        var c = this.series,\n            k = c.options.pointValKey || c.pointValKey;\n        a = g.prototype.optionsToObject.call(this, a);\n        d(this, a);\n        this.options = this.options ? d(this.options, a) : a;\n        a.group && delete this.group;\n        a.dataLabels && delete this.dataLabels;\n        k && (this.y = g.prototype.getNestedProperty.call(this, k));\n        this.formatPrefix = (this.isNull = x(this.isValid && !this.isValid(), null === this.x || !n(this.y))) ? \"null\" : \"point\";\n        this.selected && (this.state = \"select\");\n        \"name\" in this && \"undefined\" === typeof b && c.xAxis && c.xAxis.hasNames && (this.x = c.xAxis.nameToX(this));\n        \"undefined\" === typeof this.x && c ? this.x = \"undefined\" === typeof b ? c.autoIncrement() : b : n(a.x) && c.options.relativeXValue && (this.x = c.autoIncrement(a.x));\n        return this;\n      };\n\n      g.prototype.destroy = function () {\n        function a() {\n          if (b.graphic || b.dataLabel || b.dataLabels) k(b), b.destroyElements();\n\n          for (p in b) b[p] = null;\n        }\n\n        var b = this,\n            g = b.series,\n            d = g.chart;\n        g = g.options.dataSorting;\n        var e = d.hoverPoints,\n            f = E(b.series.chart.renderer.globalAnimation),\n            p;\n        b.legendItem && d.legend.destroyItem(b);\n        e && (b.setState(), h(e, b), e.length || (d.hoverPoints = null));\n        if (b === d.hoverPoint) b.onMouseOut();\n        g && g.enabled ? (this.animateBeforeDestroy(), m(a, f.duration)) : a();\n        d.pointCount--;\n      };\n\n      g.prototype.destroyElements = function (a) {\n        var c = this;\n        a = c.getGraphicalProps(a);\n        a.singular.forEach(function (a) {\n          c[a] = c[a].destroy();\n        });\n        a.plural.forEach(function (a) {\n          c[a].forEach(function (a) {\n            a.element && a.destroy();\n          });\n          delete c[a];\n        });\n      };\n\n      g.prototype.firePointEvent = function (a, g, d) {\n        var c = this,\n            k = this.series.options;\n        (k.point.events[a] || c.options && c.options.events && c.options.events[a]) && c.importEvents();\n        \"click\" === a && k.allowPointSelect && (d = function (a) {\n          c.select && c.select(null, a.ctrlKey || a.metaKey || a.shiftKey);\n        });\n        b(c, a, g, d);\n      };\n\n      g.prototype.getClassName = function () {\n        return \"highcharts-point\" + (this.selected ? \" highcharts-point-select\" : \"\") + (this.negative ? \" highcharts-negative\" : \"\") + (this.isNull ? \" highcharts-null-point\" : \"\") + (\"undefined\" !== typeof this.colorIndex ? \" highcharts-color-\" + this.colorIndex : \"\") + (this.options.className ? \" \" + this.options.className : \"\") + (this.zone && this.zone.className ? \" \" + this.zone.className.replace(\"highcharts-negative\", \"\") : \"\");\n      };\n\n      g.prototype.getGraphicalProps = function (a) {\n        var c = this,\n            b = [],\n            g = {\n          singular: [],\n          plural: []\n        },\n            d;\n        a = a || {\n          graphic: 1,\n          dataLabel: 1\n        };\n        a.graphic && b.push(\"graphic\", \"upperGraphic\", \"shadowGroup\");\n        a.dataLabel && b.push(\"dataLabel\", \"dataLabelUpper\", \"connector\");\n\n        for (d = b.length; d--;) {\n          var k = b[d];\n          c[k] && g.singular.push(k);\n        }\n\n        [\"dataLabel\", \"connector\"].forEach(function (b) {\n          var d = b + \"s\";\n          a[b] && c[d] && g.plural.push(d);\n        });\n        return g;\n      };\n\n      g.prototype.getLabelConfig = function () {\n        return {\n          x: this.category,\n          y: this.y,\n          color: this.color,\n          colorIndex: this.colorIndex,\n          key: this.name || this.category,\n          series: this.series,\n          point: this,\n          percentage: this.percentage,\n          total: this.total || this.stackTotal\n        };\n      };\n\n      g.prototype.getNestedProperty = function (a) {\n        if (a) return 0 === a.indexOf(\"custom.\") ? p(a, this.options) : this[a];\n      };\n\n      g.prototype.getZone = function () {\n        var a = this.series,\n            b = a.zones;\n        a = a.zoneAxis || \"y\";\n        var g,\n            d = 0;\n\n        for (g = b[d]; this[a] >= g.value;) g = b[++d];\n\n        this.nonZonedColor || (this.nonZonedColor = this.color);\n        this.color = g && g.color && !this.options.color ? g.color : this.nonZonedColor;\n        return g;\n      };\n\n      g.prototype.hasNewShapeType = function () {\n        return (this.graphic && (this.graphic.symbolName || this.graphic.element.nodeName)) !== this.shapeType;\n      };\n\n      g.prototype.init = function (c, g, d) {\n        this.series = c;\n        this.applyOptions(g, d);\n        this.id = t(this.id) ? this.id : a();\n        this.resolveColor();\n        c.chart.pointCount++;\n        b(this, \"afterInit\");\n        return this;\n      };\n\n      g.prototype.optionsToObject = function (a) {\n        var c = this.series,\n            b = c.options.keys,\n            d = b || c.pointArrayMap || [\"y\"],\n            k = d.length,\n            e = {},\n            m = 0,\n            f = 0;\n        if (n(a) || null === a) e[d[0]] = a;else if (q(a)) for (!b && a.length > k && (c = typeof a[0], \"string\" === c ? e.name = a[0] : \"number\" === c && (e.x = a[0]), m++); f < k;) b && \"undefined\" === typeof a[m] || (0 < d[f].indexOf(\".\") ? g.prototype.setNestedProperty(e, a[m], d[f]) : e[d[f]] = a[m]), m++, f++;else \"object\" === typeof a && (e = a, a.dataLabels && (c._hasPointLabels = !0), a.marker && (c._hasPointMarkers = !0));\n        return e;\n      };\n\n      g.prototype.resolveColor = function () {\n        var a = this.series,\n            b = a.chart.styledMode;\n        var g = a.chart.options.chart.colorCount;\n        delete this.nonZonedColor;\n\n        if (a.options.colorByPoint) {\n          if (!b) {\n            g = a.options.colors || a.chart.options.colors;\n            var d = g[a.colorCounter];\n            g = g.length;\n          }\n\n          b = a.colorCounter;\n          a.colorCounter++;\n          a.colorCounter === g && (a.colorCounter = 0);\n        } else b || (d = a.color), b = a.colorIndex;\n\n        this.colorIndex = x(this.options.colorIndex, b);\n        this.color = x(this.options.color, d);\n      };\n\n      g.prototype.setNestedProperty = function (a, b, g) {\n        g.split(\".\").reduce(function (a, c, g, d) {\n          a[c] = d.length - 1 === g ? b : J(a[c], !0) ? a[c] : {};\n          return a[c];\n        }, a);\n        return a;\n      };\n\n      g.prototype.tooltipFormatter = function (a) {\n        var c = this.series,\n            b = c.tooltipOptions,\n            g = x(b.valueDecimals, \"\"),\n            d = b.valuePrefix || \"\",\n            k = b.valueSuffix || \"\";\n        c.chart.styledMode && (a = c.chart.tooltip.styledModeFormat(a));\n        (c.pointArrayMap || [\"y\"]).forEach(function (c) {\n          c = \"{point.\" + c;\n          if (d || k) a = a.replace(RegExp(c + \"}\", \"g\"), d + c + \"}\" + k);\n          a = a.replace(RegExp(c + \"}\", \"g\"), c + \":,.\" + g + \"f}\");\n        });\n        return B(a, {\n          point: this,\n          series: this.series\n        }, c.chart);\n      };\n\n      g.prototype.update = function (a, b, g, d) {\n        function c() {\n          k.applyOptions(a);\n          var c = m && k.hasDummyGraphic;\n          c = null === k.y ? !c : c;\n          m && c && (k.graphic = m.destroy(), delete k.hasDummyGraphic);\n          J(a, !0) && (m && m.element && a && a.marker && \"undefined\" !== typeof a.marker.symbol && (k.graphic = m.destroy()), a && a.dataLabels && k.dataLabel && (k.dataLabel = k.dataLabel.destroy()), k.connector && (k.connector = k.connector.destroy()));\n          p = k.index;\n          e.updateParallelArrays(k, p);\n          h.data[p] = J(h.data[p], !0) || J(a, !0) ? k.options : x(a, h.data[p]);\n          e.isDirty = e.isDirtyData = !0;\n          !e.fixedBox && e.hasCartesianSeries && (f.isDirtyBox = !0);\n          \"point\" === h.legendType && (f.isDirtyLegend = !0);\n          b && f.redraw(g);\n        }\n\n        var k = this,\n            e = k.series,\n            m = k.graphic,\n            f = e.chart,\n            h = e.options,\n            p;\n        b = x(b, !0);\n        !1 === d ? c() : k.firePointEvent(\"update\", {\n          options: a\n        }, c);\n      };\n\n      g.prototype.remove = function (a, b) {\n        this.series.removePoint(this.series.data.indexOf(this), a, b);\n      };\n\n      g.prototype.select = function (a, b) {\n        var c = this,\n            g = c.series,\n            d = g.chart;\n        this.selectedStaging = a = x(a, !c.selected);\n        c.firePointEvent(a ? \"select\" : \"unselect\", {\n          accumulate: b\n        }, function () {\n          c.selected = c.options.selected = a;\n          g.options.data[g.data.indexOf(c)] = c.options;\n          c.setState(a && \"select\");\n          b || d.getSelectedPoints().forEach(function (a) {\n            var b = a.series;\n            a.selected && a !== c && (a.selected = a.options.selected = !1, b.options.data[b.data.indexOf(a)] = a.options, a.setState(d.hoverPoints && b.options.inactiveOtherPoints ? \"inactive\" : \"\"), a.firePointEvent(\"unselect\"));\n          });\n        });\n        delete this.selectedStaging;\n      };\n\n      g.prototype.onMouseOver = function (a) {\n        var c = this.series.chart,\n            b = c.pointer;\n        a = a ? b.normalize(a) : b.getChartCoordinatesFromPoint(this, c.inverted);\n        b.runPointActions(a, this);\n      };\n\n      g.prototype.onMouseOut = function () {\n        var a = this.series.chart;\n        this.firePointEvent(\"mouseOut\");\n        this.series.options.inactiveOtherPoints || (a.hoverPoints || []).forEach(function (a) {\n          a.setState();\n        });\n        a.hoverPoints = a.hoverPoint = null;\n      };\n\n      g.prototype.importEvents = function () {\n        if (!this.hasImportedEvents) {\n          var a = this,\n              b = w(a.series.options.point, a.options).events;\n          a.events = b;\n          z(b, function (c, b) {\n            r(c) && y(a, b, c);\n          });\n          this.hasImportedEvents = !0;\n        }\n      };\n\n      g.prototype.setState = function (a, g) {\n        var c = this.series,\n            k = this.state,\n            e = c.options.states[a || \"normal\"] || {},\n            m = G.plotOptions[c.type].marker && c.options.marker,\n            h = m && !1 === m.enabled,\n            p = m && m.states && m.states[a || \"normal\"] || {},\n            r = !1 === p.enabled,\n            q = this.marker || {},\n            l = c.chart,\n            D = m && c.markerAttribs,\n            t = c.halo,\n            z,\n            w = c.stateMarkerGraphic;\n        a = a || \"\";\n\n        if (!(a === this.state && !g || this.selected && \"select\" !== a || !1 === e.enabled || a && (r || h && !1 === p.enabled) || a && q.states && q.states[a] && !1 === q.states[a].enabled)) {\n          this.state = a;\n          D && (z = c.markerAttribs(this, a));\n\n          if (this.graphic && !this.hasDummyGraphic) {\n            k && this.graphic.removeClass(\"highcharts-point-\" + k);\n            a && this.graphic.addClass(\"highcharts-point-\" + a);\n\n            if (!l.styledMode) {\n              var y = c.pointAttribs(this, a);\n              var F = x(l.options.chart.animation, e.animation);\n              c.options.inactiveOtherPoints && n(y.opacity) && ((this.dataLabels || []).forEach(function (a) {\n                a && a.animate({\n                  opacity: y.opacity\n                }, F);\n              }), this.connector && this.connector.animate({\n                opacity: y.opacity\n              }, F));\n              this.graphic.animate(y, F);\n            }\n\n            z && this.graphic.animate(z, x(l.options.chart.animation, p.animation, m.animation));\n            w && w.hide();\n          } else {\n            if (a && p) {\n              k = q.symbol || c.symbol;\n              w && w.currentSymbol !== k && (w = w.destroy());\n              if (z) if (w) w[g ? \"animate\" : \"attr\"]({\n                x: z.x,\n                y: z.y\n              });else k && (c.stateMarkerGraphic = w = l.renderer.symbol(k, z.x, z.y, z.width, z.height).add(c.markerGroup), w.currentSymbol = k);\n              !l.styledMode && w && \"inactive\" !== this.state && w.attr(c.pointAttribs(this, a));\n            }\n\n            w && (w[a && this.isInside ? \"show\" : \"hide\"](), w.element.point = this, w.addClass(this.getClassName(), !0));\n          }\n\n          e = e.halo;\n          z = (w = this.graphic || w) && w.visibility || \"inherit\";\n          e && e.size && w && \"hidden\" !== z && !this.isCluster ? (t || (c.halo = t = l.renderer.path().add(w.parentGroup)), t.show()[g ? \"animate\" : \"attr\"]({\n            d: this.haloPath(e.size)\n          }), t.attr({\n            \"class\": \"highcharts-halo highcharts-color-\" + x(this.colorIndex, c.colorIndex) + (this.className ? \" \" + this.className : \"\"),\n            visibility: z,\n            zIndex: -1\n          }), t.point = this, l.styledMode || t.attr(d({\n            fill: this.color || c.color,\n            \"fill-opacity\": e.opacity\n          }, f.filterUserAttributes(e.attributes || {})))) : t && t.point && t.point.haloPath && t.animate({\n            d: t.point.haloPath(0)\n          }, null, t.hide);\n          b(this, \"afterSetState\", {\n            state: a\n          });\n        }\n      };\n\n      g.prototype.haloPath = function (a) {\n        return this.series.chart.renderer.symbols.circle(Math.floor(this.plotX) - a, this.plotY - a, 2 * a, 2 * a);\n      };\n\n      return g;\n    }();\n\n    \"\";\n    return e;\n  });\n  K(l, \"Core/Pointer.js\", [l[\"Core/Color/Color.js\"], l[\"Core/Globals.js\"], l[\"Core/Tooltip.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C) {\n    var v = f.parse,\n        E = e.charts,\n        G = e.noop,\n        B = C.addEvent,\n        y = C.attr,\n        t = C.css,\n        h = C.defined,\n        d = C.extend,\n        b = C.find,\n        p = C.fireEvent,\n        q = C.isNumber,\n        r = C.isObject,\n        n = C.objectEach,\n        J = C.offset,\n        w = C.pick,\n        z = C.splat;\n\n    f = function () {\n      function f(b, d) {\n        this.lastValidTouch = {};\n        this.pinchDown = [];\n        this.runChartClick = !1;\n        this.eventsToUnbind = [];\n        this.chart = b;\n        this.hasDragged = !1;\n        this.options = d;\n        this.init(b, d);\n      }\n\n      f.prototype.applyInactiveState = function (b) {\n        var d = [],\n            a;\n        (b || []).forEach(function (b) {\n          a = b.series;\n          d.push(a);\n          a.linkedParent && d.push(a.linkedParent);\n          a.linkedSeries && (d = d.concat(a.linkedSeries));\n          a.navigatorSeries && d.push(a.navigatorSeries);\n        });\n        this.chart.series.forEach(function (a) {\n          -1 === d.indexOf(a) ? a.setState(\"inactive\", !0) : a.options.inactiveOtherPoints && a.setAllPointsToState(\"inactive\");\n        });\n      };\n\n      f.prototype.destroy = function () {\n        var b = this;\n        this.eventsToUnbind.forEach(function (b) {\n          return b();\n        });\n        this.eventsToUnbind = [];\n        e.chartCount || (f.unbindDocumentMouseUp && (f.unbindDocumentMouseUp = f.unbindDocumentMouseUp()), f.unbindDocumentTouchEnd && (f.unbindDocumentTouchEnd = f.unbindDocumentTouchEnd()));\n        clearInterval(b.tooltipTimeout);\n        n(b, function (d, a) {\n          b[a] = void 0;\n        });\n      };\n\n      f.prototype.drag = function (b) {\n        var d = this.chart,\n            a = d.options.chart,\n            g = this.zoomHor,\n            c = this.zoomVert,\n            e = d.plotLeft,\n            m = d.plotTop,\n            f = d.plotWidth,\n            h = d.plotHeight,\n            p = this.mouseDownX || 0,\n            n = this.mouseDownY || 0,\n            q = r(a.panning) ? a.panning && a.panning.enabled : a.panning,\n            l = a.panKey && b[a.panKey + \"Key\"],\n            t = b.chartX,\n            z = b.chartY,\n            w = this.selectionMarker;\n        if (!w || !w.touch) if (t < e ? t = e : t > e + f && (t = e + f), z < m ? z = m : z > m + h && (z = m + h), this.hasDragged = Math.sqrt(Math.pow(p - t, 2) + Math.pow(n - z, 2)), 10 < this.hasDragged) {\n          var x = d.isInsidePlot(p - e, n - m, {\n            visiblePlotOnly: !0\n          });\n          !d.hasCartesianSeries && !d.mapView || !this.zoomX && !this.zoomY || !x || l || w || (this.selectionMarker = w = d.renderer.rect(e, m, g ? 1 : f, c ? 1 : h, 0).attr({\n            \"class\": \"highcharts-selection-marker\",\n            zIndex: 7\n          }).add(), d.styledMode || w.attr({\n            fill: a.selectionMarkerFill || v(\"#335cad\").setOpacity(.25).get()\n          }));\n          w && g && (g = t - p, w.attr({\n            width: Math.abs(g),\n            x: (0 < g ? 0 : g) + p\n          }));\n          w && c && (g = z - n, w.attr({\n            height: Math.abs(g),\n            y: (0 < g ? 0 : g) + n\n          }));\n          x && !w && q && d.pan(b, a.panning);\n        }\n      };\n\n      f.prototype.dragStart = function (b) {\n        var d = this.chart;\n        d.mouseIsDown = b.type;\n        d.cancelClick = !1;\n        d.mouseDownX = this.mouseDownX = b.chartX;\n        d.mouseDownY = this.mouseDownY = b.chartY;\n      };\n\n      f.prototype.drop = function (b) {\n        var k = this,\n            a = this.chart,\n            g = this.hasPinched;\n\n        if (this.selectionMarker) {\n          var c = this.selectionMarker,\n              e = c.attr ? c.attr(\"x\") : c.x,\n              m = c.attr ? c.attr(\"y\") : c.y,\n              f = c.attr ? c.attr(\"width\") : c.width,\n              n = c.attr ? c.attr(\"height\") : c.height,\n              r = {\n            originalEvent: b,\n            xAxis: [],\n            yAxis: [],\n            x: e,\n            y: m,\n            width: f,\n            height: n\n          },\n              l = !!a.mapView;\n          if (this.hasDragged || g) a.axes.forEach(function (a) {\n            if (a.zoomEnabled && h(a.min) && (g || k[{\n              xAxis: \"zoomX\",\n              yAxis: \"zoomY\"\n            }[a.coll]]) && q(e) && q(m)) {\n              var c = a.horiz,\n                  d = \"touchend\" === b.type ? a.minPixelPadding : 0,\n                  p = a.toValue((c ? e : m) + d);\n              c = a.toValue((c ? e + f : m + n) - d);\n              r[a.coll].push({\n                axis: a,\n                min: Math.min(p, c),\n                max: Math.max(p, c)\n              });\n              l = !0;\n            }\n          }), l && p(a, \"selection\", r, function (c) {\n            a.zoom(d(c, g ? {\n              animation: !1\n            } : null));\n          });\n          q(a.index) && (this.selectionMarker = this.selectionMarker.destroy());\n          g && this.scaleGroups();\n        }\n\n        a && q(a.index) && (t(a.container, {\n          cursor: a._cursor\n        }), a.cancelClick = 10 < this.hasDragged, a.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = []);\n      };\n\n      f.prototype.findNearestKDPoint = function (b, d, a) {\n        var g = this.chart,\n            c = g.hoverPoint;\n        g = g.tooltip;\n        if (c && g && g.isStickyOnContact()) return c;\n        var k;\n        b.forEach(function (c) {\n          var b = !(c.noSharedTooltip && d) && 0 > c.options.findNearestPointBy.indexOf(\"y\");\n          c = c.searchPoint(a, b);\n\n          if ((b = r(c, !0) && c.series) && !(b = !r(k, !0))) {\n            b = k.distX - c.distX;\n            var g = k.dist - c.dist,\n                e = (c.series.group && c.series.group.zIndex) - (k.series.group && k.series.group.zIndex);\n            b = 0 < (0 !== b && d ? b : 0 !== g ? g : 0 !== e ? e : k.series.index > c.series.index ? -1 : 1);\n          }\n\n          b && (k = c);\n        });\n        return k;\n      };\n\n      f.prototype.getChartCoordinatesFromPoint = function (b, d) {\n        var a = b.series,\n            g = a.xAxis;\n        a = a.yAxis;\n        var c = b.shapeArgs;\n\n        if (g && a) {\n          var k = w(b.clientX, b.plotX),\n              e = b.plotY || 0;\n          b.isNode && c && q(c.x) && q(c.y) && (k = c.x, e = c.y);\n          return d ? {\n            chartX: a.len + a.pos - e,\n            chartY: g.len + g.pos - k\n          } : {\n            chartX: k + g.pos,\n            chartY: e + a.pos\n          };\n        }\n\n        if (c && c.x && c.y) return {\n          chartX: c.x,\n          chartY: c.y\n        };\n      };\n\n      f.prototype.getChartPosition = function () {\n        if (this.chartPosition) return this.chartPosition;\n        var b = this.chart.container,\n            d = J(b);\n        this.chartPosition = {\n          left: d.left,\n          top: d.top,\n          scaleX: 1,\n          scaleY: 1\n        };\n        var a = b.offsetWidth;\n        b = b.offsetHeight;\n        2 < a && 2 < b && (this.chartPosition.scaleX = d.width / a, this.chartPosition.scaleY = d.height / b);\n        return this.chartPosition;\n      };\n\n      f.prototype.getCoordinates = function (b) {\n        var d = {\n          xAxis: [],\n          yAxis: []\n        };\n        this.chart.axes.forEach(function (a) {\n          d[a.isXAxis ? \"xAxis\" : \"yAxis\"].push({\n            axis: a,\n            value: a.toValue(b[a.horiz ? \"chartX\" : \"chartY\"])\n          });\n        });\n        return d;\n      };\n\n      f.prototype.getHoverData = function (d, k, a, g, c, e) {\n        var f = [];\n        g = !(!g || !d);\n        var m = {\n          chartX: e ? e.chartX : void 0,\n          chartY: e ? e.chartY : void 0,\n          shared: c\n        };\n        p(this, \"beforeGetHoverData\", m);\n        var h = k && !k.stickyTracking ? [k] : a.filter(function (a) {\n          return m.filter ? m.filter(a) : a.visible && !(!c && a.directTouch) && w(a.options.enableMouseTracking, !0) && a.stickyTracking;\n        });\n        var n = g || !e ? d : this.findNearestKDPoint(h, c, e);\n        k = n && n.series;\n        n && (c && !k.noSharedTooltip ? (h = a.filter(function (a) {\n          return m.filter ? m.filter(a) : a.visible && !(!c && a.directTouch) && w(a.options.enableMouseTracking, !0) && !a.noSharedTooltip;\n        }), h.forEach(function (a) {\n          var c = b(a.points, function (a) {\n            return a.x === n.x && !a.isNull;\n          });\n          r(c) && (a.chart.isBoosting && (c = a.getPoint(c)), f.push(c));\n        })) : f.push(n));\n        m = {\n          hoverPoint: n\n        };\n        p(this, \"afterGetHoverData\", m);\n        return {\n          hoverPoint: m.hoverPoint,\n          hoverSeries: k,\n          hoverPoints: f\n        };\n      };\n\n      f.prototype.getPointFromEvent = function (b) {\n        b = b.target;\n\n        for (var d; b && !d;) d = b.point, b = b.parentNode;\n\n        return d;\n      };\n\n      f.prototype.onTrackerMouseOut = function (b) {\n        b = b.relatedTarget || b.toElement;\n        var d = this.chart.hoverSeries;\n        this.isDirectTouch = !1;\n        if (!(!d || !b || d.stickyTracking || this.inClass(b, \"highcharts-tooltip\") || this.inClass(b, \"highcharts-series-\" + d.index) && this.inClass(b, \"highcharts-tracker\"))) d.onMouseOut();\n      };\n\n      f.prototype.inClass = function (b, d) {\n        for (var a; b;) {\n          if (a = y(b, \"class\")) {\n            if (-1 !== a.indexOf(d)) return !0;\n            if (-1 !== a.indexOf(\"highcharts-container\")) return !1;\n          }\n\n          b = b.parentElement;\n        }\n      };\n\n      f.prototype.init = function (b, d) {\n        this.options = d;\n        this.chart = b;\n        this.runChartClick = !(!d.chart.events || !d.chart.events.click);\n        this.pinchDown = [];\n        this.lastValidTouch = {};\n        l && (b.tooltip = new l(b, d.tooltip), this.followTouchMove = w(d.tooltip.followTouchMove, !0));\n        this.setDOMEvents();\n      };\n\n      f.prototype.normalize = function (b, e) {\n        var a = b.touches,\n            g = a ? a.length ? a.item(0) : w(a.changedTouches, b.changedTouches)[0] : b;\n        e || (e = this.getChartPosition());\n        a = g.pageX - e.left;\n        g = g.pageY - e.top;\n        a /= e.scaleX;\n        g /= e.scaleY;\n        return d(b, {\n          chartX: Math.round(a),\n          chartY: Math.round(g)\n        });\n      };\n\n      f.prototype.onContainerClick = function (b) {\n        var e = this.chart,\n            a = e.hoverPoint;\n        b = this.normalize(b);\n        var g = e.plotLeft,\n            c = e.plotTop;\n        e.cancelClick || (a && this.inClass(b.target, \"highcharts-tracker\") ? (p(a.series, \"click\", d(b, {\n          point: a\n        })), e.hoverPoint && a.firePointEvent(\"click\", b)) : (d(b, this.getCoordinates(b)), e.isInsidePlot(b.chartX - g, b.chartY - c, {\n          visiblePlotOnly: !0\n        }) && p(e, \"click\", b)));\n      };\n\n      f.prototype.onContainerMouseDown = function (b) {\n        var d = 1 === ((b.buttons || b.button) & 1);\n        b = this.normalize(b);\n        if (e.isFirefox && 0 !== b.button) this.onContainerMouseMove(b);\n        if (\"undefined\" === typeof b.button || d) this.zoomOption(b), d && b.preventDefault && b.preventDefault(), this.dragStart(b);\n      };\n\n      f.prototype.onContainerMouseLeave = function (b) {\n        var d = E[w(f.hoverChartIndex, -1)],\n            a = this.chart.tooltip;\n        a && a.shouldStickOnContact() && this.inClass(b.relatedTarget, \"highcharts-tooltip-container\") || (b = this.normalize(b), d && (b.relatedTarget || b.toElement) && (d.pointer.reset(), d.pointer.chartPosition = void 0), a && !a.isHidden && this.reset());\n      };\n\n      f.prototype.onContainerMouseEnter = function (b) {\n        delete this.chartPosition;\n      };\n\n      f.prototype.onContainerMouseMove = function (b) {\n        var d = this.chart;\n        b = this.normalize(b);\n        this.setHoverChartIndex();\n        b.preventDefault || (b.returnValue = !1);\n        (\"mousedown\" === d.mouseIsDown || this.touchSelect(b)) && this.drag(b);\n        d.openMenu || !this.inClass(b.target, \"highcharts-tracker\") && !d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop, {\n          visiblePlotOnly: !0\n        }) || (this.inClass(b.target, \"highcharts-no-tooltip\") ? this.reset(!1, 0) : this.runPointActions(b));\n      };\n\n      f.prototype.onDocumentTouchEnd = function (b) {\n        var d = E[w(f.hoverChartIndex, -1)];\n        d && d.pointer.drop(b);\n      };\n\n      f.prototype.onContainerTouchMove = function (b) {\n        if (this.touchSelect(b)) this.onContainerMouseMove(b);else this.touch(b);\n      };\n\n      f.prototype.onContainerTouchStart = function (b) {\n        if (this.touchSelect(b)) this.onContainerMouseDown(b);else this.zoomOption(b), this.touch(b, !0);\n      };\n\n      f.prototype.onDocumentMouseMove = function (b) {\n        var d = this.chart,\n            a = this.chartPosition;\n        b = this.normalize(b, a);\n        var g = d.tooltip;\n        !a || g && g.isStickyOnContact() || d.isInsidePlot(b.chartX - d.plotLeft, b.chartY - d.plotTop, {\n          visiblePlotOnly: !0\n        }) || this.inClass(b.target, \"highcharts-tracker\") || this.reset();\n      };\n\n      f.prototype.onDocumentMouseUp = function (b) {\n        var d = E[w(f.hoverChartIndex, -1)];\n        d && d.pointer.drop(b);\n      };\n\n      f.prototype.pinch = function (b) {\n        var e = this,\n            a = e.chart,\n            g = e.pinchDown,\n            c = b.touches || [],\n            f = c.length,\n            h = e.lastValidTouch,\n            m = e.hasZoom,\n            n = {},\n            r = 1 === f && (e.inClass(b.target, \"highcharts-tracker\") && a.runTrackerClick || e.runChartClick),\n            q = {},\n            l = e.selectionMarker;\n        1 < f ? e.initiated = !0 : 1 === f && this.followTouchMove && (e.initiated = !1);\n        m && e.initiated && !r && !1 !== b.cancelable && b.preventDefault();\n        [].map.call(c, function (a) {\n          return e.normalize(a);\n        });\n        \"touchstart\" === b.type ? ([].forEach.call(c, function (a, c) {\n          g[c] = {\n            chartX: a.chartX,\n            chartY: a.chartY\n          };\n        }), h.x = [g[0].chartX, g[1] && g[1].chartX], h.y = [g[0].chartY, g[1] && g[1].chartY], a.axes.forEach(function (c) {\n          if (c.zoomEnabled) {\n            var b = a.bounds[c.horiz ? \"h\" : \"v\"],\n                d = c.minPixelPadding,\n                g = c.toPixels(Math.min(w(c.options.min, c.dataMin), c.dataMin)),\n                e = c.toPixels(Math.max(w(c.options.max, c.dataMax), c.dataMax)),\n                k = Math.max(g, e);\n            b.min = Math.min(c.pos, Math.min(g, e) - d);\n            b.max = Math.max(c.pos + c.len, k + d);\n          }\n        }), e.res = !0) : e.followTouchMove && 1 === f ? this.runPointActions(e.normalize(b)) : g.length && (p(a, \"touchpan\", {\n          originalEvent: b\n        }, function () {\n          l || (e.selectionMarker = l = d({\n            destroy: G,\n            touch: !0\n          }, a.plotBox));\n          e.pinchTranslate(g, c, n, l, q, h);\n          e.hasPinched = m;\n          e.scaleGroups(n, q);\n        }), e.res && (e.res = !1, this.reset(!1, 0)));\n      };\n\n      f.prototype.pinchTranslate = function (b, d, a, g, c, e) {\n        this.zoomHor && this.pinchTranslateDirection(!0, b, d, a, g, c, e);\n        this.zoomVert && this.pinchTranslateDirection(!1, b, d, a, g, c, e);\n      };\n\n      f.prototype.pinchTranslateDirection = function (b, d, a, g, c, e, f, h) {\n        var k = this.chart,\n            m = b ? \"x\" : \"y\",\n            p = b ? \"X\" : \"Y\",\n            n = \"chart\" + p,\n            u = b ? \"width\" : \"height\",\n            r = k[\"plot\" + (b ? \"Left\" : \"Top\")],\n            q = k.inverted,\n            l = k.bounds[b ? \"h\" : \"v\"],\n            t = 1 === d.length,\n            A = d[0][n],\n            D = !t && d[1][n];\n\n        d = function () {\n          \"number\" === typeof x && 20 < Math.abs(A - D) && (w = h || Math.abs(N - x) / Math.abs(A - D));\n          F = (r - N) / w + A;\n          z = k[\"plot\" + (b ? \"Width\" : \"Height\")] / w;\n        };\n\n        var z,\n            F,\n            w = h || 1,\n            N = a[0][n],\n            x = !t && a[1][n];\n        d();\n        a = F;\n\n        if (a < l.min) {\n          a = l.min;\n          var y = !0;\n        } else a + z > l.max && (a = l.max - z, y = !0);\n\n        y ? (N -= .8 * (N - f[m][0]), \"number\" === typeof x && (x -= .8 * (x - f[m][1])), d()) : f[m] = [N, x];\n        q || (e[m] = F - r, e[u] = z);\n        e = q ? 1 / w : w;\n        c[u] = z;\n        c[m] = a;\n        g[q ? b ? \"scaleY\" : \"scaleX\" : \"scale\" + p] = w;\n        g[\"translate\" + p] = e * r + (N - e * A);\n      };\n\n      f.prototype.reset = function (b, d) {\n        var a = this.chart,\n            g = a.hoverSeries,\n            c = a.hoverPoint,\n            e = a.hoverPoints,\n            k = a.tooltip,\n            f = k && k.shared ? e : c;\n        b && f && z(f).forEach(function (a) {\n          a.series.isCartesian && \"undefined\" === typeof a.plotX && (b = !1);\n        });\n        if (b) k && f && z(f).length && (k.refresh(f), k.shared && e ? e.forEach(function (a) {\n          a.setState(a.state, !0);\n          a.series.isCartesian && (a.series.xAxis.crosshair && a.series.xAxis.drawCrosshair(null, a), a.series.yAxis.crosshair && a.series.yAxis.drawCrosshair(null, a));\n        }) : c && (c.setState(c.state, !0), a.axes.forEach(function (a) {\n          a.crosshair && c.series[a.coll] === a && a.drawCrosshair(null, c);\n        })));else {\n          if (c) c.onMouseOut();\n          e && e.forEach(function (a) {\n            a.setState();\n          });\n          if (g) g.onMouseOut();\n          k && k.hide(d);\n          this.unDocMouseMove && (this.unDocMouseMove = this.unDocMouseMove());\n          a.axes.forEach(function (a) {\n            a.hideCrosshair();\n          });\n          this.hoverX = a.hoverPoints = a.hoverPoint = null;\n        }\n      };\n\n      f.prototype.runPointActions = function (d, e) {\n        var a = this.chart,\n            g = a.tooltip && a.tooltip.options.enabled ? a.tooltip : void 0,\n            c = g ? g.shared : !1,\n            k = e || a.hoverPoint,\n            h = k && k.series || a.hoverSeries;\n        e = this.getHoverData(k, h, a.series, (!d || \"touchmove\" !== d.type) && (!!e || h && h.directTouch && this.isDirectTouch), c, d);\n        k = e.hoverPoint;\n        h = e.hoverSeries;\n        var m = e.hoverPoints;\n        e = h && h.tooltipOptions.followPointer && !h.tooltipOptions.split;\n        var p = c && h && !h.noSharedTooltip;\n\n        if (k && (k !== a.hoverPoint || g && g.isHidden)) {\n          (a.hoverPoints || []).forEach(function (a) {\n            -1 === m.indexOf(a) && a.setState();\n          });\n          if (a.hoverSeries !== h) h.onMouseOver();\n          this.applyInactiveState(m);\n          (m || []).forEach(function (a) {\n            a.setState(\"hover\");\n          });\n          a.hoverPoint && a.hoverPoint.firePointEvent(\"mouseOut\");\n          if (!k.series) return;\n          a.hoverPoints = m;\n          a.hoverPoint = k;\n          k.firePointEvent(\"mouseOver\", void 0, function () {\n            g && k && g.refresh(p ? m : k, d);\n          });\n        } else e && g && !g.isHidden && (c = g.getAnchor([{}], d), a.isInsidePlot(c[0], c[1], {\n          visiblePlotOnly: !0\n        }) && g.updatePosition({\n          plotX: c[0],\n          plotY: c[1]\n        }));\n\n        this.unDocMouseMove || (this.unDocMouseMove = B(a.container.ownerDocument, \"mousemove\", function (a) {\n          var c = E[f.hoverChartIndex];\n          if (c) c.pointer.onDocumentMouseMove(a);\n        }), this.eventsToUnbind.push(this.unDocMouseMove));\n        a.axes.forEach(function (c) {\n          var g = w((c.crosshair || {}).snap, !0),\n              e;\n          g && ((e = a.hoverPoint) && e.series[c.coll] === c || (e = b(m, function (a) {\n            return a.series && a.series[c.coll] === c;\n          })));\n          e || !g ? c.drawCrosshair(d, e) : c.hideCrosshair();\n        });\n      };\n\n      f.prototype.scaleGroups = function (b, d) {\n        var a = this.chart;\n        a.series.forEach(function (g) {\n          var c = b || g.getPlotBox();\n          g.group && (g.xAxis && g.xAxis.zoomEnabled || a.mapView) && (g.group.attr(c), g.markerGroup && (g.markerGroup.attr(c), g.markerGroup.clip(d ? a.clipRect : null)), g.dataLabelsGroup && g.dataLabelsGroup.attr(c));\n        });\n        a.clipRect.attr(d || a.clipBox);\n      };\n\n      f.prototype.setDOMEvents = function () {\n        var b = this,\n            d = this.chart.container,\n            a = d.ownerDocument;\n        d.onmousedown = this.onContainerMouseDown.bind(this);\n        d.onmousemove = this.onContainerMouseMove.bind(this);\n        d.onclick = this.onContainerClick.bind(this);\n        this.eventsToUnbind.push(B(d, \"mouseenter\", this.onContainerMouseEnter.bind(this)));\n        this.eventsToUnbind.push(B(d, \"mouseleave\", this.onContainerMouseLeave.bind(this)));\n        f.unbindDocumentMouseUp || (f.unbindDocumentMouseUp = B(a, \"mouseup\", this.onDocumentMouseUp.bind(this)));\n\n        for (var g = this.chart.renderTo.parentElement; g && \"BODY\" !== g.tagName;) this.eventsToUnbind.push(B(g, \"scroll\", function () {\n          delete b.chartPosition;\n        })), g = g.parentElement;\n\n        e.hasTouch && (this.eventsToUnbind.push(B(d, \"touchstart\", this.onContainerTouchStart.bind(this), {\n          passive: !1\n        })), this.eventsToUnbind.push(B(d, \"touchmove\", this.onContainerTouchMove.bind(this), {\n          passive: !1\n        })), f.unbindDocumentTouchEnd || (f.unbindDocumentTouchEnd = B(a, \"touchend\", this.onDocumentTouchEnd.bind(this), {\n          passive: !1\n        })));\n      };\n\n      f.prototype.setHoverChartIndex = function () {\n        var b = this.chart,\n            d = e.charts[w(f.hoverChartIndex, -1)];\n        if (d && d !== b) d.pointer.onContainerMouseLeave({\n          relatedTarget: b.container\n        });\n        d && d.mouseIsDown || (f.hoverChartIndex = b.index);\n      };\n\n      f.prototype.touch = function (b, d) {\n        var a = this.chart,\n            g;\n        this.setHoverChartIndex();\n        if (1 === b.touches.length) {\n          if (b = this.normalize(b), (g = a.isInsidePlot(b.chartX - a.plotLeft, b.chartY - a.plotTop, {\n            visiblePlotOnly: !0\n          })) && !a.openMenu) {\n            d && this.runPointActions(b);\n\n            if (\"touchmove\" === b.type) {\n              d = this.pinchDown;\n              var c = d[0] ? 4 <= Math.sqrt(Math.pow(d[0].chartX - b.chartX, 2) + Math.pow(d[0].chartY - b.chartY, 2)) : !1;\n            }\n\n            w(c, !0) && this.pinch(b);\n          } else d && this.reset();\n        } else 2 === b.touches.length && this.pinch(b);\n      };\n\n      f.prototype.touchSelect = function (b) {\n        return !(!this.chart.options.chart.zoomBySingleTouch || !b.touches || 1 !== b.touches.length);\n      };\n\n      f.prototype.zoomOption = function (b) {\n        var d = this.chart,\n            a = d.options.chart;\n        d = d.inverted;\n        var g = a.zoomType || \"\";\n        /touch/.test(b.type) && (g = w(a.pinchType, g));\n        this.zoomX = b = /x/.test(g);\n        this.zoomY = a = /y/.test(g);\n        this.zoomHor = b && !d || a && d;\n        this.zoomVert = a && !d || b && d;\n        this.hasZoom = b || a;\n      };\n\n      return f;\n    }();\n\n    \"\";\n    return f;\n  });\n  K(l, \"Core/MSPointer.js\", [l[\"Core/Globals.js\"], l[\"Core/Pointer.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    function C() {\n      var d = [];\n\n      d.item = function (b) {\n        return this[b];\n      };\n\n      b(q, function (b) {\n        d.push({\n          pageX: b.pageX,\n          pageY: b.pageY,\n          target: b.target\n        });\n      });\n      return d;\n    }\n\n    function v(b, d, f, h) {\n      var p = G[e.hoverChartIndex || NaN];\n      \"touch\" !== b.pointerType && b.pointerType !== b.MSPOINTER_TYPE_TOUCH || !p || (p = p.pointer, h(b), p[d]({\n        type: f,\n        target: b.currentTarget,\n        preventDefault: y,\n        touches: C()\n      }));\n    }\n\n    var E = this && this.__extends || function () {\n      var b = function (d, e) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var e in d) d.hasOwnProperty(e) && (b[e] = d[e]);\n        };\n\n        return b(d, e);\n      };\n\n      return function (d, e) {\n        function f() {\n          this.constructor = d;\n        }\n\n        b(d, e);\n        d.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());\n      };\n    }(),\n        G = f.charts,\n        B = f.doc,\n        y = f.noop,\n        t = f.win,\n        h = l.addEvent,\n        d = l.css,\n        b = l.objectEach,\n        p = l.removeEvent,\n        q = {},\n        r = !!t.PointerEvent;\n\n    return function (b) {\n      function e() {\n        return null !== b && b.apply(this, arguments) || this;\n      }\n\n      E(e, b);\n\n      e.isRequired = function () {\n        return !(f.hasTouch || !t.PointerEvent && !t.MSPointerEvent);\n      };\n\n      e.prototype.batchMSEvents = function (b) {\n        b(this.chart.container, r ? \"pointerdown\" : \"MSPointerDown\", this.onContainerPointerDown);\n        b(this.chart.container, r ? \"pointermove\" : \"MSPointerMove\", this.onContainerPointerMove);\n        b(B, r ? \"pointerup\" : \"MSPointerUp\", this.onDocumentPointerUp);\n      };\n\n      e.prototype.destroy = function () {\n        this.batchMSEvents(p);\n        b.prototype.destroy.call(this);\n      };\n\n      e.prototype.init = function (e, f) {\n        b.prototype.init.call(this, e, f);\n        this.hasZoom && d(e.container, {\n          \"-ms-touch-action\": \"none\",\n          \"touch-action\": \"none\"\n        });\n      };\n\n      e.prototype.onContainerPointerDown = function (b) {\n        v(b, \"onContainerTouchStart\", \"touchstart\", function (b) {\n          q[b.pointerId] = {\n            pageX: b.pageX,\n            pageY: b.pageY,\n            target: b.currentTarget\n          };\n        });\n      };\n\n      e.prototype.onContainerPointerMove = function (b) {\n        v(b, \"onContainerTouchMove\", \"touchmove\", function (b) {\n          q[b.pointerId] = {\n            pageX: b.pageX,\n            pageY: b.pageY\n          };\n          q[b.pointerId].target || (q[b.pointerId].target = b.currentTarget);\n        });\n      };\n\n      e.prototype.onDocumentPointerUp = function (b) {\n        v(b, \"onDocumentTouchEnd\", \"touchend\", function (b) {\n          delete q[b.pointerId];\n        });\n      };\n\n      e.prototype.setDOMEvents = function () {\n        b.prototype.setDOMEvents.call(this);\n        (this.hasZoom || this.followTouchMove) && this.batchMSEvents(h);\n      };\n\n      return e;\n    }(e);\n  });\n  K(l, \"Core/Legend/Legend.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/FormatUtilities.js\"], l[\"Core/Globals.js\"], l[\"Core/Series/Point.js\"], l[\"Core/Renderer/RendererUtilities.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E) {\n    var G = f.animObject,\n        B = f.setAnimation,\n        y = e.format;\n    f = l.isFirefox;\n    var t = l.marginNames;\n    l = l.win;\n    var h = v.distribute,\n        d = E.addEvent,\n        b = E.createElement,\n        p = E.css,\n        q = E.defined,\n        r = E.discardElement,\n        n = E.find,\n        J = E.fireEvent,\n        w = E.isNumber,\n        z = E.merge,\n        x = E.pick,\n        m = E.relativeLength,\n        k = E.stableSort,\n        a = E.syncTimeout;\n    v = E.wrap;\n\n    E = function () {\n      function g(a, b) {\n        this.allItems = [];\n        this.contentGroup = this.box = void 0;\n        this.display = !1;\n        this.group = void 0;\n        this.offsetWidth = this.maxLegendWidth = this.maxItemWidth = this.legendWidth = this.legendHeight = this.lastLineHeight = this.lastItemY = this.itemY = this.itemX = this.itemMarginTop = this.itemMarginBottom = this.itemHeight = this.initialItemY = 0;\n        this.options = void 0;\n        this.padding = 0;\n        this.pages = [];\n        this.proximate = !1;\n        this.scrollGroup = void 0;\n        this.widthOption = this.totalItemWidth = this.titleHeight = this.symbolWidth = this.symbolHeight = 0;\n        this.chart = a;\n        this.init(a, b);\n      }\n\n      g.prototype.init = function (a, b) {\n        this.chart = a;\n        this.setOptions(b);\n        b.enabled && (this.render(), d(this.chart, \"endResize\", function () {\n          this.legend.positionCheckboxes();\n        }), this.proximate ? this.unchartrender = d(this.chart, \"render\", function () {\n          this.legend.proximatePositions();\n          this.legend.positionItems();\n        }) : this.unchartrender && this.unchartrender());\n      };\n\n      g.prototype.setOptions = function (a) {\n        var c = x(a.padding, 8);\n        this.options = a;\n        this.chart.styledMode || (this.itemStyle = a.itemStyle, this.itemHiddenStyle = z(this.itemStyle, a.itemHiddenStyle));\n        this.itemMarginTop = a.itemMarginTop || 0;\n        this.itemMarginBottom = a.itemMarginBottom || 0;\n        this.padding = c;\n        this.initialItemY = c - 5;\n        this.symbolWidth = x(a.symbolWidth, 16);\n        this.pages = [];\n        this.proximate = \"proximate\" === a.layout && !this.chart.inverted;\n        this.baseline = void 0;\n      };\n\n      g.prototype.update = function (a, b) {\n        var c = this.chart;\n        this.setOptions(z(!0, this.options, a));\n        this.destroy();\n        c.isDirtyLegend = c.isDirtyBox = !0;\n        x(b, !0) && c.redraw();\n        J(this, \"afterUpdate\");\n      };\n\n      g.prototype.colorizeItem = function (a, b) {\n        a.legendGroup[b ? \"removeClass\" : \"addClass\"](\"highcharts-legend-item-hidden\");\n\n        if (!this.chart.styledMode) {\n          var c = this.options,\n              d = a.legendItem,\n              g = a.legendLine,\n              e = a.legendSymbol,\n              f = this.itemHiddenStyle.color;\n          c = b ? c.itemStyle.color : f;\n          var k = b ? a.color || f : f,\n              h = a.options && a.options.marker,\n              m = {\n            fill: k\n          };\n          d && d.css({\n            fill: c,\n            color: c\n          });\n          g && g.attr({\n            stroke: k\n          });\n          e && (h && e.isMarker && (m = a.pointAttribs(), b || (m.stroke = m.fill = f)), e.attr(m));\n        }\n\n        J(this, \"afterColorizeItem\", {\n          item: a,\n          visible: b\n        });\n      };\n\n      g.prototype.positionItems = function () {\n        this.allItems.forEach(this.positionItem, this);\n        this.chart.isResizing || this.positionCheckboxes();\n      };\n\n      g.prototype.positionItem = function (a) {\n        var c = this,\n            b = this.options,\n            d = b.symbolPadding,\n            g = !b.rtl,\n            e = a._legendItemPos;\n        b = e[0];\n        e = e[1];\n        var f = a.checkbox,\n            k = a.legendGroup;\n        k && k.element && (d = {\n          translateX: g ? b : this.legendWidth - b - 2 * d - 4,\n          translateY: e\n        }, g = function () {\n          J(c, \"afterPositionItem\", {\n            item: a\n          });\n        }, q(k.translateY) ? k.animate(d, void 0, g) : (k.attr(d), g()));\n        f && (f.x = b, f.y = e);\n      };\n\n      g.prototype.destroyItem = function (a) {\n        var c = a.checkbox;\n        [\"legendItem\", \"legendLine\", \"legendSymbol\", \"legendGroup\"].forEach(function (c) {\n          a[c] && (a[c] = a[c].destroy());\n        });\n        c && r(a.checkbox);\n      };\n\n      g.prototype.destroy = function () {\n        function a(a) {\n          this[a] && (this[a] = this[a].destroy());\n        }\n\n        this.getAllItems().forEach(function (c) {\n          [\"legendItem\", \"legendGroup\"].forEach(a, c);\n        });\n        \"clipRect up down pager nav box title group\".split(\" \").forEach(a, this);\n        this.display = null;\n      };\n\n      g.prototype.positionCheckboxes = function () {\n        var a = this.group && this.group.alignAttr,\n            b = this.clipHeight || this.legendHeight,\n            d = this.titleHeight;\n\n        if (a) {\n          var g = a.translateY;\n          this.allItems.forEach(function (c) {\n            var e = c.checkbox;\n\n            if (e) {\n              var f = g + d + e.y + (this.scrollOffset || 0) + 3;\n              p(e, {\n                left: a.translateX + c.checkboxOffset + e.x - 20 + \"px\",\n                top: f + \"px\",\n                display: this.proximate || f > g - 6 && f < g + b - 6 ? \"\" : \"none\"\n              });\n            }\n          }, this);\n        }\n      };\n\n      g.prototype.renderTitle = function () {\n        var a = this.options,\n            b = this.padding,\n            d = a.title,\n            g = 0;\n        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, b - 3, b - 4, void 0, void 0, void 0, a.useHTML, void 0, \"legend-title\").attr({\n          zIndex: 1\n        }), this.chart.styledMode || this.title.css(d.style), this.title.add(this.group)), d.width || this.title.css({\n          width: this.maxLegendWidth + \"px\"\n        }), a = this.title.getBBox(), g = a.height, this.offsetWidth = a.width, this.contentGroup.attr({\n          translateY: g\n        }));\n        this.titleHeight = g;\n      };\n\n      g.prototype.setText = function (a) {\n        var c = this.options;\n        a.legendItem.attr({\n          text: c.labelFormat ? y(c.labelFormat, a, this.chart) : c.labelFormatter.call(a)\n        });\n      };\n\n      g.prototype.renderItem = function (a) {\n        var c = this.chart,\n            b = c.renderer,\n            d = this.options,\n            g = this.symbolWidth,\n            e = d.symbolPadding || 0,\n            f = this.itemStyle,\n            k = this.itemHiddenStyle,\n            h = \"horizontal\" === d.layout ? x(d.itemDistance, 20) : 0,\n            m = !d.rtl,\n            p = !a.series,\n            n = !p && a.series.drawLegendSymbol ? a.series : a,\n            l = n.options,\n            r = this.createCheckboxForItem && l && l.showCheckbox,\n            q = d.useHTML,\n            t = a.options.className,\n            F = a.legendItem;\n        l = g + e + h + (r ? 20 : 0);\n        F || (a.legendGroup = b.g(\"legend-item\").addClass(\"highcharts-\" + n.type + \"-series highcharts-color-\" + a.colorIndex + (t ? \" \" + t : \"\") + (p ? \" highcharts-series-\" + a.index : \"\")).attr({\n          zIndex: 1\n        }).add(this.scrollGroup), a.legendItem = F = b.text(\"\", m ? g + e : -e, this.baseline || 0, q), c.styledMode || F.css(z(a.visible ? f : k)), F.attr({\n          align: m ? \"left\" : \"right\",\n          zIndex: 2\n        }).add(a.legendGroup), this.baseline || (this.fontMetrics = b.fontMetrics(c.styledMode ? 12 : f.fontSize, F), this.baseline = this.fontMetrics.f + 3 + this.itemMarginTop, F.attr(\"y\", this.baseline), this.symbolHeight = d.symbolHeight || this.fontMetrics.f, d.squareSymbol && (this.symbolWidth = x(d.symbolWidth, Math.max(this.symbolHeight, 16)), l = this.symbolWidth + e + h + (r ? 20 : 0), m && F.attr(\"x\", this.symbolWidth + e))), n.drawLegendSymbol(this, a), this.setItemEvents && this.setItemEvents(a, F, q));\n        r && !a.checkbox && this.createCheckboxForItem && this.createCheckboxForItem(a);\n        this.colorizeItem(a, a.visible);\n        !c.styledMode && f.width || F.css({\n          width: (d.itemWidth || this.widthOption || c.spacingBox.width) - l + \"px\"\n        });\n        this.setText(a);\n        c = F.getBBox();\n        b = this.fontMetrics && this.fontMetrics.h || 0;\n        a.itemWidth = a.checkboxOffset = d.itemWidth || a.legendItemWidth || c.width + l;\n        this.maxItemWidth = Math.max(this.maxItemWidth, a.itemWidth);\n        this.totalItemWidth += a.itemWidth;\n        this.itemHeight = a.itemHeight = Math.round(a.legendItemHeight || (c.height > 1.5 * b ? c.height : b));\n      };\n\n      g.prototype.layoutItem = function (a) {\n        var c = this.options,\n            b = this.padding,\n            d = \"horizontal\" === c.layout,\n            g = a.itemHeight,\n            e = this.itemMarginBottom,\n            f = this.itemMarginTop,\n            k = d ? x(c.itemDistance, 20) : 0,\n            h = this.maxLegendWidth;\n        c = c.alignColumns && this.totalItemWidth > h ? this.maxItemWidth : a.itemWidth;\n        d && this.itemX - b + c > h && (this.itemX = b, this.lastLineHeight && (this.itemY += f + this.lastLineHeight + e), this.lastLineHeight = 0);\n        this.lastItemY = f + this.itemY + e;\n        this.lastLineHeight = Math.max(g, this.lastLineHeight);\n        a._legendItemPos = [this.itemX, this.itemY];\n        d ? this.itemX += c : (this.itemY += f + g + e, this.lastLineHeight = g);\n        this.offsetWidth = this.widthOption || Math.max((d ? this.itemX - b - (a.checkbox ? 0 : k) : c) + b, this.offsetWidth);\n      };\n\n      g.prototype.getAllItems = function () {\n        var a = [];\n        this.chart.series.forEach(function (c) {\n          var b = c && c.options;\n          c && x(b.showInLegend, q(b.linkedTo) ? !1 : void 0, !0) && (a = a.concat(c.legendItems || (\"point\" === b.legendType ? c.data : c)));\n        });\n        J(this, \"afterGetAllItems\", {\n          allItems: a\n        });\n        return a;\n      };\n\n      g.prototype.getAlignment = function () {\n        var a = this.options;\n        return this.proximate ? a.align.charAt(0) + \"tv\" : a.floating ? \"\" : a.align.charAt(0) + a.verticalAlign.charAt(0) + a.layout.charAt(0);\n      };\n\n      g.prototype.adjustMargins = function (a, b) {\n        var c = this.chart,\n            d = this.options,\n            g = this.getAlignment();\n        g && [/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/].forEach(function (e, f) {\n          e.test(g) && !q(a[f]) && (c[t[f]] = Math.max(c[t[f]], c.legend[(f + 1) % 2 ? \"legendHeight\" : \"legendWidth\"] + [1, -1, -1, 1][f] * d[f % 2 ? \"x\" : \"y\"] + x(d.margin, 12) + b[f] + (c.titleOffset[f] || 0)));\n        });\n      };\n\n      g.prototype.proximatePositions = function () {\n        var a = this.chart,\n            b = [],\n            d = \"left\" === this.options.align;\n        this.allItems.forEach(function (c) {\n          var g;\n          var e = d;\n\n          if (c.yAxis) {\n            c.xAxis.options.reversed && (e = !e);\n            c.points && (g = n(e ? c.points : c.points.slice(0).reverse(), function (a) {\n              return w(a.plotY);\n            }));\n            e = this.itemMarginTop + c.legendItem.getBBox().height + this.itemMarginBottom;\n            var f = c.yAxis.top - a.plotTop;\n            c.visible ? (g = g ? g.plotY : c.yAxis.height, g += f - .3 * e) : g = f + c.yAxis.height;\n            b.push({\n              target: g,\n              size: e,\n              item: c\n            });\n          }\n        }, this);\n        h(b, a.plotHeight).forEach(function (c) {\n          c.item._legendItemPos && c.pos && (c.item._legendItemPos[1] = a.plotTop - a.spacing[0] + c.pos);\n        });\n      };\n\n      g.prototype.render = function () {\n        var a = this.chart,\n            b = a.renderer,\n            d = this.options,\n            g = this.padding,\n            e = this.getAllItems(),\n            f = this.group,\n            h = this.box;\n        this.itemX = g;\n        this.itemY = this.initialItemY;\n        this.lastItemY = this.offsetWidth = 0;\n        this.widthOption = m(d.width, a.spacingBox.width - g);\n        var p = a.spacingBox.width - 2 * g - d.x;\n        -1 < [\"rm\", \"lm\"].indexOf(this.getAlignment().substring(0, 2)) && (p /= 2);\n        this.maxLegendWidth = this.widthOption || p;\n        f || (this.group = f = b.g(\"legend\").addClass(d.className || \"\").attr({\n          zIndex: 7\n        }).add(), this.contentGroup = b.g().attr({\n          zIndex: 1\n        }).add(f), this.scrollGroup = b.g().add(this.contentGroup));\n        this.renderTitle();\n        k(e, function (a, c) {\n          return (a.options && a.options.legendIndex || 0) - (c.options && c.options.legendIndex || 0);\n        });\n        d.reversed && e.reverse();\n        this.allItems = e;\n        this.display = p = !!e.length;\n        this.itemHeight = this.totalItemWidth = this.maxItemWidth = this.lastLineHeight = 0;\n        e.forEach(this.renderItem, this);\n        e.forEach(this.layoutItem, this);\n        e = (this.widthOption || this.offsetWidth) + g;\n        var n = this.lastItemY + this.lastLineHeight + this.titleHeight;\n        n = this.handleOverflow(n);\n        n += g;\n        h || (this.box = h = b.rect().addClass(\"highcharts-legend-box\").attr({\n          r: d.borderRadius\n        }).add(f));\n        a.styledMode || h.attr({\n          stroke: d.borderColor,\n          \"stroke-width\": d.borderWidth || 0,\n          fill: d.backgroundColor || \"none\"\n        }).shadow(d.shadow);\n        if (0 < e && 0 < n) h[h.placed ? \"animate\" : \"attr\"](h.crisp.call({}, {\n          x: 0,\n          y: 0,\n          width: e,\n          height: n\n        }, h.strokeWidth()));\n        f[p ? \"show\" : \"hide\"]();\n        a.styledMode && \"none\" === f.getStyle(\"display\") && (e = n = 0);\n        this.legendWidth = e;\n        this.legendHeight = n;\n        p && this.align();\n        this.proximate || this.positionItems();\n        J(this, \"afterRender\");\n      };\n\n      g.prototype.align = function (a) {\n        void 0 === a && (a = this.chart.spacingBox);\n        var c = this.chart,\n            b = this.options,\n            d = a.y;\n        /(lth|ct|rth)/.test(this.getAlignment()) && 0 < c.titleOffset[0] ? d += c.titleOffset[0] : /(lbh|cb|rbh)/.test(this.getAlignment()) && 0 < c.titleOffset[2] && (d -= c.titleOffset[2]);\n        d !== a.y && (a = z(a, {\n          y: d\n        }));\n        c.hasRendered || (this.group.placed = !1);\n        this.group.align(z(b, {\n          width: this.legendWidth,\n          height: this.legendHeight,\n          verticalAlign: this.proximate ? \"top\" : b.verticalAlign\n        }), !0, a);\n      };\n\n      g.prototype.handleOverflow = function (a) {\n        var c = this,\n            b = this.chart,\n            d = b.renderer,\n            g = this.options,\n            e = g.y,\n            f = \"top\" === g.verticalAlign,\n            k = this.padding,\n            h = g.maxHeight,\n            m = g.navigation,\n            p = x(m.animation, !0),\n            n = m.arrowSize || 12,\n            l = this.pages,\n            r = this.allItems,\n            q = function (a) {\n          \"number\" === typeof a ? w.attr({\n            height: a\n          }) : w && (c.clipRect = w.destroy(), c.contentGroup.clip());\n          c.contentGroup.div && (c.contentGroup.div.style.clip = a ? \"rect(\" + k + \"px,9999px,\" + (k + a) + \"px,0)\" : \"auto\");\n        },\n            t = function (a) {\n          c[a] = d.circle(0, 0, 1.3 * n).translate(n / 2, n / 2).add(N);\n          b.styledMode || c[a].attr(\"fill\", \"rgba(0,0,0,0.0001)\");\n          return c[a];\n        },\n            F,\n            z;\n\n        e = b.spacingBox.height + (f ? -e : e) - k;\n        var N = this.nav,\n            w = this.clipRect;\n        \"horizontal\" !== g.layout || \"middle\" === g.verticalAlign || g.floating || (e /= 2);\n        h && (e = Math.min(e, h));\n        l.length = 0;\n        a && 0 < e && a > e && !1 !== m.enabled ? (this.clipHeight = F = Math.max(e - 20 - this.titleHeight - k, 0), this.currentPage = x(this.currentPage, 1), this.fullHeight = a, r.forEach(function (a, c) {\n          var b = a._legendItemPos[1],\n              d = Math.round(a.legendItem.getBBox().height),\n              g = l.length;\n          if (!g || b - l[g - 1] > F && (z || b) !== l[g - 1]) l.push(z || b), g++;\n          a.pageIx = g - 1;\n          z && (r[c - 1].pageIx = g - 1);\n          c === r.length - 1 && b + d - l[g - 1] > F && d <= F && (l.push(b), a.pageIx = g);\n          b !== z && (z = b);\n        }), w || (w = c.clipRect = d.clipRect(0, k, 9999, 0), c.contentGroup.clip(w)), q(F), N || (this.nav = N = d.g().attr({\n          zIndex: 1\n        }).add(this.group), this.up = d.symbol(\"triangle\", 0, 0, n, n).add(N), t(\"upTracker\").on(\"click\", function () {\n          c.scroll(-1, p);\n        }), this.pager = d.text(\"\", 15, 10).addClass(\"highcharts-legend-navigation\"), !b.styledMode && m.style && this.pager.css(m.style), this.pager.add(N), this.down = d.symbol(\"triangle-down\", 0, 0, n, n).add(N), t(\"downTracker\").on(\"click\", function () {\n          c.scroll(1, p);\n        })), c.scroll(0), a = e) : N && (q(), this.nav = N.destroy(), this.scrollGroup.attr({\n          translateY: 1\n        }), this.clipHeight = 0);\n        return a;\n      };\n\n      g.prototype.scroll = function (c, b) {\n        var d = this,\n            g = this.chart,\n            e = this.pages,\n            f = e.length,\n            k = this.clipHeight,\n            h = this.options.navigation,\n            m = this.pager,\n            p = this.padding,\n            n = this.currentPage + c;\n        n > f && (n = f);\n        0 < n && (\"undefined\" !== typeof b && B(b, g), this.nav.attr({\n          translateX: p,\n          translateY: k + this.padding + 7 + this.titleHeight,\n          visibility: \"inherit\"\n        }), [this.up, this.upTracker].forEach(function (a) {\n          a.attr({\n            \"class\": 1 === n ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }), m.attr({\n          text: n + \"/\" + f\n        }), [this.down, this.downTracker].forEach(function (a) {\n          a.attr({\n            x: 18 + this.pager.getBBox().width,\n            \"class\": n === f ? \"highcharts-legend-nav-inactive\" : \"highcharts-legend-nav-active\"\n          });\n        }, this), g.styledMode || (this.up.attr({\n          fill: 1 === n ? h.inactiveColor : h.activeColor\n        }), this.upTracker.css({\n          cursor: 1 === n ? \"default\" : \"pointer\"\n        }), this.down.attr({\n          fill: n === f ? h.inactiveColor : h.activeColor\n        }), this.downTracker.css({\n          cursor: n === f ? \"default\" : \"pointer\"\n        })), this.scrollOffset = -e[n - 1] + this.initialItemY, this.scrollGroup.animate({\n          translateY: this.scrollOffset\n        }), this.currentPage = n, this.positionCheckboxes(), c = G(x(b, g.renderer.globalAnimation, !0)), a(function () {\n          J(d, \"afterScroll\", {\n            currentPage: n\n          });\n        }, c.duration));\n      };\n\n      g.prototype.setItemEvents = function (a, b, d) {\n        var c = this,\n            g = c.chart.renderer.boxWrapper,\n            e = a instanceof C,\n            f = \"highcharts-legend-\" + (e ? \"point\" : \"series\") + \"-active\",\n            k = c.chart.styledMode,\n            h = function (b) {\n          c.allItems.forEach(function (c) {\n            a !== c && [c].concat(c.linkedSeries || []).forEach(function (a) {\n              a.setState(b, !e);\n            });\n          });\n        };\n\n        (d ? [b, a.legendSymbol] : [a.legendGroup]).forEach(function (d) {\n          if (d) d.on(\"mouseover\", function () {\n            a.visible && h(\"inactive\");\n            a.setState(\"hover\");\n            a.visible && g.addClass(f);\n            k || b.css(c.options.itemHoverStyle);\n          }).on(\"mouseout\", function () {\n            c.chart.styledMode || b.css(z(a.visible ? c.itemStyle : c.itemHiddenStyle));\n            h(\"\");\n            g.removeClass(f);\n            a.setState();\n          }).on(\"click\", function (c) {\n            var b = function () {\n              a.setVisible && a.setVisible();\n              h(a.visible ? \"inactive\" : \"\");\n            };\n\n            g.removeClass(f);\n            c = {\n              browserEvent: c\n            };\n            a.firePointEvent ? a.firePointEvent(\"legendItemClick\", c, b) : J(a, \"legendItemClick\", c, b);\n          });\n        });\n      };\n\n      g.prototype.createCheckboxForItem = function (a) {\n        a.checkbox = b(\"input\", {\n          type: \"checkbox\",\n          className: \"highcharts-legend-checkbox\",\n          checked: a.selected,\n          defaultChecked: a.selected\n        }, this.options.itemCheckboxStyle, this.chart.container);\n        d(a.checkbox, \"click\", function (c) {\n          J(a.series || a, \"checkboxClick\", {\n            checked: c.target.checked,\n            item: a\n          }, function () {\n            a.select();\n          });\n        });\n      };\n\n      return g;\n    }();\n\n    (/Trident\\/7\\.0/.test(l.navigator && l.navigator.userAgent) || f) && v(E.prototype, \"positionItem\", function (a, c) {\n      var b = this,\n          d = function () {\n        c._legendItemPos && a.call(b, c);\n      };\n\n      d();\n      b.bubbleLegend || setTimeout(d);\n    });\n    \"\";\n    return E;\n  });\n  K(l, \"Core/Series/SeriesRegistry.js\", [l[\"Core/Globals.js\"], l[\"Core/DefaultOptions.js\"], l[\"Core/Series/Point.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C) {\n    var v = e.defaultOptions,\n        E = C.error,\n        G = C.extendClass,\n        B = C.merge,\n        y;\n\n    (function (e) {\n      function h(d, b) {\n        var f = v.plotOptions || {},\n            h = b.defaultOptions;\n        b.prototype.pointClass || (b.prototype.pointClass = l);\n        b.prototype.type = d;\n        h && (f[d] = h);\n        e.seriesTypes[d] = b;\n      }\n\n      e.seriesTypes = f.seriesTypes;\n\n      e.getSeries = function (d, b) {\n        void 0 === b && (b = {});\n        var f = d.options.chart;\n        f = b.type || f.type || f.defaultSeriesType || \"\";\n        var h = e.seriesTypes[f];\n        e || E(17, !0, d, {\n          missingModuleFor: f\n        });\n        f = new h();\n        \"function\" === typeof f.init && f.init(d, b);\n        return f;\n      };\n\n      e.registerSeriesType = h;\n\n      e.seriesType = function (d, b, f, q, r) {\n        var p = v.plotOptions || {};\n        b = b || \"\";\n        p[d] = B(p[b], f);\n        h(d, G(e.seriesTypes[b] || function () {}, q));\n        e.seriesTypes[d].prototype.type = d;\n        r && (e.seriesTypes[d].prototype.pointClass = G(l, r));\n        return e.seriesTypes[d];\n      };\n    })(y || (y = {}));\n\n    return y;\n  });\n  K(l, \"Core/Chart/Chart.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/Axis/Axis.js\"], l[\"Core/FormatUtilities.js\"], l[\"Core/Foundation.js\"], l[\"Core/Globals.js\"], l[\"Core/Legend/Legend.js\"], l[\"Core/MSPointer.js\"], l[\"Core/DefaultOptions.js\"], l[\"Core/Pointer.js\"], l[\"Core/Renderer/RendererRegistry.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Renderer/SVG/SVGRenderer.js\"], l[\"Core/Time.js\"], l[\"Core/Utilities.js\"], l[\"Core/Renderer/HTML/AST.js\"]], function (f, e, l, C, v, E, G, B, y, t, h, d, b, p, q) {\n    var r = f.animate,\n        n = f.animObject,\n        J = f.setAnimation,\n        w = l.numberFormat,\n        z = C.registerEventOptions,\n        x = v.charts,\n        m = v.doc,\n        k = v.marginNames,\n        a = v.svg,\n        g = v.win,\n        c = B.defaultOptions,\n        D = B.defaultTime,\n        A = h.seriesTypes,\n        u = p.addEvent,\n        L = p.attr,\n        S = p.cleanRecursively,\n        R = p.createElement,\n        M = p.css,\n        U = p.defined,\n        P = p.discardElement,\n        I = p.erase,\n        H = p.error,\n        K = p.extend,\n        da = p.find,\n        O = p.fireEvent,\n        ea = p.getStyle,\n        F = p.isArray,\n        T = p.isNumber,\n        N = p.isObject,\n        V = p.isString,\n        W = p.merge,\n        X = p.objectEach,\n        Q = p.pick,\n        Z = p.pInt,\n        ba = p.relativeLength,\n        ha = p.removeEvent,\n        fa = p.splat,\n        ia = p.syncTimeout,\n        ka = p.uniqueKey;\n\n    f = function () {\n      function f(a, c, b) {\n        this.series = this.renderTo = this.renderer = this.pointer = this.pointCount = this.plotWidth = this.plotTop = this.plotLeft = this.plotHeight = this.plotBox = this.options = this.numberFormatter = this.margin = this.legend = this.labelCollectors = this.isResizing = this.index = this.eventOptions = this.container = this.colorCounter = this.clipBox = this.chartWidth = this.chartHeight = this.bounds = this.axisOffset = this.axes = void 0;\n        this.sharedClips = {};\n        this.yAxis = this.xAxis = this.userOptions = this.titleOffset = this.time = this.symbolCounter = this.spacingBox = this.spacing = void 0;\n        this.getArgs(a, c, b);\n      }\n\n      f.chart = function (a, c, b) {\n        return new f(a, c, b);\n      };\n\n      f.prototype.getArgs = function (a, c, b) {\n        V(a) || a.nodeName ? (this.renderTo = a, this.init(c, b)) : this.init(a, c);\n      };\n\n      f.prototype.init = function (a, d) {\n        var g = a.plotOptions || {};\n        O(this, \"init\", {\n          args: arguments\n        }, function () {\n          var e = W(c, a),\n              f = e.chart;\n          X(e.plotOptions, function (a, c) {\n            N(a) && (a.tooltip = g[c] && W(g[c].tooltip) || void 0);\n          });\n          e.tooltip.userOptions = a.chart && a.chart.forExport && a.tooltip.userOptions || a.tooltip;\n          this.userOptions = a;\n          this.margin = [];\n          this.spacing = [];\n          this.bounds = {\n            h: {},\n            v: {}\n          };\n          this.labelCollectors = [];\n          this.callback = d;\n          this.isResizing = 0;\n          this.options = e;\n          this.axes = [];\n          this.series = [];\n          this.time = a.time && Object.keys(a.time).length ? new b(a.time) : v.time;\n          this.numberFormatter = f.numberFormatter || w;\n          this.styledMode = f.styledMode;\n          this.hasCartesianSeries = f.showAxes;\n          this.index = x.length;\n          x.push(this);\n          v.chartCount++;\n          z(this, f);\n          this.xAxis = [];\n          this.yAxis = [];\n          this.pointCount = this.colorCounter = this.symbolCounter = 0;\n          O(this, \"afterInit\");\n          this.firstRender();\n        });\n      };\n\n      f.prototype.initSeries = function (a) {\n        var c = this.options.chart;\n        c = a.type || c.type || c.defaultSeriesType;\n        var b = A[c];\n        b || H(17, !0, this, {\n          missingModuleFor: c\n        });\n        c = new b();\n        \"function\" === typeof c.init && c.init(this, a);\n        return c;\n      };\n\n      f.prototype.setSeriesData = function () {\n        this.getSeriesOrderByLinks().forEach(function (a) {\n          a.points || a.data || !a.enabledDataSorting || a.setData(a.options.data, !1);\n        });\n      };\n\n      f.prototype.getSeriesOrderByLinks = function () {\n        return this.series.concat().sort(function (a, c) {\n          return a.linkedSeries.length || c.linkedSeries.length ? c.linkedSeries.length - a.linkedSeries.length : 0;\n        });\n      };\n\n      f.prototype.orderSeries = function (a) {\n        var c = this.series;\n        a = a || 0;\n\n        for (var b = c.length; a < b; ++a) c[a] && (c[a].index = a, c[a].name = c[a].getName());\n      };\n\n      f.prototype.isInsidePlot = function (a, c, b) {\n        void 0 === b && (b = {});\n        var d = this.inverted,\n            g = this.plotBox,\n            e = this.plotLeft,\n            f = this.plotTop,\n            k = this.scrollablePlotBox,\n            h = 0;\n        var m = 0;\n        b.visiblePlotOnly && this.scrollingContainer && (m = this.scrollingContainer, h = m.scrollLeft, m = m.scrollTop);\n        var p = b.series;\n        g = b.visiblePlotOnly && k || g;\n        k = b.inverted ? c : a;\n        c = b.inverted ? a : c;\n        a = {\n          x: k,\n          y: c,\n          isInsidePlot: !0\n        };\n\n        if (!b.ignoreX) {\n          var n = p && (d ? p.yAxis : p.xAxis) || {\n            pos: e,\n            len: Infinity\n          };\n          k = b.paneCoordinates ? n.pos + k : e + k;\n          k >= Math.max(h + e, n.pos) && k <= Math.min(h + e + g.width, n.pos + n.len) || (a.isInsidePlot = !1);\n        }\n\n        !b.ignoreY && a.isInsidePlot && (d = p && (d ? p.xAxis : p.yAxis) || {\n          pos: f,\n          len: Infinity\n        }, b = b.paneCoordinates ? d.pos + c : f + c, b >= Math.max(m + f, d.pos) && b <= Math.min(m + f + g.height, d.pos + d.len) || (a.isInsidePlot = !1));\n        O(this, \"afterIsInsidePlot\", a);\n        return a.isInsidePlot;\n      };\n\n      f.prototype.redraw = function (a) {\n        O(this, \"beforeRedraw\");\n        var c = this.hasCartesianSeries ? this.axes : this.colorAxis || [],\n            b = this.series,\n            d = this.pointer,\n            g = this.legend,\n            e = this.userOptions.legend,\n            f = this.renderer,\n            k = f.isHidden(),\n            h = [],\n            m = this.isDirtyBox,\n            p = this.isDirtyLegend;\n        this.setResponsive && this.setResponsive(!1);\n        J(this.hasRendered ? a : !1, this);\n        k && this.temporaryDisplay();\n        this.layOutTitles();\n\n        for (a = b.length; a--;) {\n          var n = b[a];\n\n          if (n.options.stacking || n.options.centerInCategory) {\n            var l = !0;\n\n            if (n.isDirty) {\n              var F = !0;\n              break;\n            }\n          }\n        }\n\n        if (F) for (a = b.length; a--;) n = b[a], n.options.stacking && (n.isDirty = !0);\n        b.forEach(function (a) {\n          a.isDirty && (\"point\" === a.options.legendType ? (\"function\" === typeof a.updateTotals && a.updateTotals(), p = !0) : e && (e.labelFormatter || e.labelFormat) && (p = !0));\n          a.isDirtyData && O(a, \"updatedData\");\n        });\n        p && g && g.options.enabled && (g.render(), this.isDirtyLegend = !1);\n        l && this.getStacks();\n        c.forEach(function (a) {\n          a.updateNames();\n          a.setScale();\n        });\n        this.getMargins();\n        c.forEach(function (a) {\n          a.isDirty && (m = !0);\n        });\n        c.forEach(function (a) {\n          var c = a.min + \",\" + a.max;\n          a.extKey !== c && (a.extKey = c, h.push(function () {\n            O(a, \"afterSetExtremes\", K(a.eventArgs, a.getExtremes()));\n            delete a.eventArgs;\n          }));\n          (m || l) && a.redraw();\n        });\n        m && this.drawChartBox();\n        O(this, \"predraw\");\n        b.forEach(function (a) {\n          (m || a.isDirty) && a.visible && a.redraw();\n          a.isDirtyData = !1;\n        });\n        d && d.reset(!0);\n        f.draw();\n        O(this, \"redraw\");\n        O(this, \"render\");\n        k && this.temporaryDisplay(!0);\n        h.forEach(function (a) {\n          a.call();\n        });\n      };\n\n      f.prototype.get = function (a) {\n        function c(c) {\n          return c.id === a || c.options && c.options.id === a;\n        }\n\n        for (var b = this.series, d = da(this.axes, c) || da(this.series, c), g = 0; !d && g < b.length; g++) d = da(b[g].points || [], c);\n\n        return d;\n      };\n\n      f.prototype.getAxes = function () {\n        var a = this,\n            c = this.options,\n            b = c.xAxis = fa(c.xAxis || {});\n        c = c.yAxis = fa(c.yAxis || {});\n        O(this, \"getAxes\");\n        b.forEach(function (a, c) {\n          a.index = c;\n          a.isX = !0;\n        });\n        c.forEach(function (a, c) {\n          a.index = c;\n        });\n        b.concat(c).forEach(function (c) {\n          new e(a, c);\n        });\n        O(this, \"afterGetAxes\");\n      };\n\n      f.prototype.getSelectedPoints = function () {\n        return this.series.reduce(function (a, c) {\n          c.getPointsCollection().forEach(function (c) {\n            Q(c.selectedStaging, c.selected) && a.push(c);\n          });\n          return a;\n        }, []);\n      };\n\n      f.prototype.getSelectedSeries = function () {\n        return this.series.filter(function (a) {\n          return a.selected;\n        });\n      };\n\n      f.prototype.setTitle = function (a, c, b) {\n        this.applyDescription(\"title\", a);\n        this.applyDescription(\"subtitle\", c);\n        this.applyDescription(\"caption\", void 0);\n        this.layOutTitles(b);\n      };\n\n      f.prototype.applyDescription = function (a, c) {\n        var b = this,\n            d = \"title\" === a ? {\n          color: \"#333333\",\n          fontSize: this.options.isStock ? \"16px\" : \"18px\"\n        } : {\n          color: \"#666666\"\n        };\n        d = this.options[a] = W(!this.styledMode && {\n          style: d\n        }, this.options[a], c);\n        var g = this[a];\n        g && c && (this[a] = g = g.destroy());\n        d && !g && (g = this.renderer.text(d.text, 0, 0, d.useHTML).attr({\n          align: d.align,\n          \"class\": \"highcharts-\" + a,\n          zIndex: d.zIndex || 4\n        }).add(), g.update = function (c) {\n          b[{\n            title: \"setTitle\",\n            subtitle: \"setSubtitle\",\n            caption: \"setCaption\"\n          }[a]](c);\n        }, this.styledMode || g.css(d.style), this[a] = g);\n      };\n\n      f.prototype.layOutTitles = function (a) {\n        var c = [0, 0, 0],\n            b = this.renderer,\n            d = this.spacingBox;\n        [\"title\", \"subtitle\", \"caption\"].forEach(function (a) {\n          var g = this[a],\n              e = this.options[a],\n              f = e.verticalAlign || \"top\";\n          a = \"title\" === a ? \"top\" === f ? -3 : 0 : \"top\" === f ? c[0] + 2 : 0;\n          var k;\n\n          if (g) {\n            this.styledMode || (k = e.style && e.style.fontSize);\n            k = b.fontMetrics(k, g).b;\n            g.css({\n              width: (e.width || d.width + (e.widthAdjust || 0)) + \"px\"\n            });\n            var h = Math.round(g.getBBox(e.useHTML).height);\n            g.align(K({\n              y: \"bottom\" === f ? k : a + k,\n              height: h\n            }, e), !1, \"spacingBox\");\n            e.floating || (\"top\" === f ? c[0] = Math.ceil(c[0] + h) : \"bottom\" === f && (c[2] = Math.ceil(c[2] + h)));\n          }\n        }, this);\n        c[0] && \"top\" === (this.options.title.verticalAlign || \"top\") && (c[0] += this.options.title.margin);\n        c[2] && \"bottom\" === this.options.caption.verticalAlign && (c[2] += this.options.caption.margin);\n        var g = !this.titleOffset || this.titleOffset.join(\",\") !== c.join(\",\");\n        this.titleOffset = c;\n        O(this, \"afterLayOutTitles\");\n        !this.isDirtyBox && g && (this.isDirtyBox = this.isDirtyLegend = g, this.hasRendered && Q(a, !0) && this.isDirtyBox && this.redraw());\n      };\n\n      f.prototype.getChartSize = function () {\n        var a = this.options.chart,\n            c = a.width;\n        a = a.height;\n        var b = this.renderTo;\n        U(c) || (this.containerWidth = ea(b, \"width\"));\n        U(a) || (this.containerHeight = ea(b, \"height\"));\n        this.chartWidth = Math.max(0, c || this.containerWidth || 600);\n        this.chartHeight = Math.max(0, ba(a, this.chartWidth) || (1 < this.containerHeight ? this.containerHeight : 400));\n      };\n\n      f.prototype.temporaryDisplay = function (a) {\n        var c = this.renderTo;\n        if (a) for (; c && c.style;) c.hcOrigStyle && (M(c, c.hcOrigStyle), delete c.hcOrigStyle), c.hcOrigDetached && (m.body.removeChild(c), c.hcOrigDetached = !1), c = c.parentNode;else for (; c && c.style;) {\n          m.body.contains(c) || c.parentNode || (c.hcOrigDetached = !0, m.body.appendChild(c));\n          if (\"none\" === ea(c, \"display\", !1) || c.hcOricDetached) c.hcOrigStyle = {\n            display: c.style.display,\n            height: c.style.height,\n            overflow: c.style.overflow\n          }, a = {\n            display: \"block\",\n            overflow: \"hidden\"\n          }, c !== this.renderTo && (a.height = 0), M(c, a), c.offsetWidth || c.style.setProperty(\"display\", \"block\", \"important\");\n          c = c.parentNode;\n          if (c === m.body) break;\n        }\n      };\n\n      f.prototype.setClassName = function (a) {\n        this.container.className = \"highcharts-container \" + (a || \"\");\n      };\n\n      f.prototype.getContainer = function () {\n        var c = this.options,\n            b = c.chart,\n            g = ka(),\n            e,\n            f = this.renderTo;\n        f || (this.renderTo = f = b.renderTo);\n        V(f) && (this.renderTo = f = m.getElementById(f));\n        f || H(13, !0, this);\n        var k = Z(L(f, \"data-highcharts-chart\"));\n        T(k) && x[k] && x[k].hasRendered && x[k].destroy();\n        L(f, \"data-highcharts-chart\", this.index);\n        f.innerHTML = q.emptyHTML;\n        b.skipClone || f.offsetWidth || this.temporaryDisplay();\n        this.getChartSize();\n        k = this.chartWidth;\n        var h = this.chartHeight;\n        M(f, {\n          overflow: \"hidden\"\n        });\n        this.styledMode || (e = K({\n          position: \"relative\",\n          overflow: \"hidden\",\n          width: k + \"px\",\n          height: h + \"px\",\n          textAlign: \"left\",\n          lineHeight: \"normal\",\n          zIndex: 0,\n          \"-webkit-tap-highlight-color\": \"rgba(0,0,0,0)\",\n          userSelect: \"none\",\n          \"touch-action\": \"manipulation\",\n          outline: \"none\"\n        }, b.style || {}));\n        this.container = g = R(\"div\", {\n          id: g\n        }, e, f);\n        this._cursor = g.style.cursor;\n        this.renderer = new (b.renderer || !a ? t.getRendererType(b.renderer) : d)(g, k, h, void 0, b.forExport, c.exporting && c.exporting.allowHTML, this.styledMode);\n        J(void 0, this);\n        this.setClassName(b.className);\n        if (this.styledMode) for (var p in c.defs) this.renderer.definition(c.defs[p]);else this.renderer.setStyle(b.style);\n        this.renderer.chartIndex = this.index;\n        O(this, \"afterGetContainer\");\n      };\n\n      f.prototype.getMargins = function (a) {\n        var c = this.spacing,\n            b = this.margin,\n            d = this.titleOffset;\n        this.resetMargins();\n        d[0] && !U(b[0]) && (this.plotTop = Math.max(this.plotTop, d[0] + c[0]));\n        d[2] && !U(b[2]) && (this.marginBottom = Math.max(this.marginBottom, d[2] + c[2]));\n        this.legend && this.legend.display && this.legend.adjustMargins(b, c);\n        O(this, \"getMargins\");\n        a || this.getAxisMargins();\n      };\n\n      f.prototype.getAxisMargins = function () {\n        var a = this,\n            c = a.axisOffset = [0, 0, 0, 0],\n            b = a.colorAxis,\n            d = a.margin,\n            g = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.getOffset();\n          });\n        };\n\n        a.hasCartesianSeries ? g(a.axes) : b && b.length && g(b);\n        k.forEach(function (b, g) {\n          U(d[g]) || (a[b] += c[g]);\n        });\n        a.setChartSize();\n      };\n\n      f.prototype.reflow = function (a) {\n        var c = this,\n            b = c.options.chart,\n            d = c.renderTo,\n            e = U(b.width) && U(b.height),\n            f = b.width || ea(d, \"width\");\n        b = b.height || ea(d, \"height\");\n        d = a ? a.target : g;\n        delete c.pointer.chartPosition;\n\n        if (!e && !c.isPrinting && f && b && (d === g || d === m)) {\n          if (f !== c.containerWidth || b !== c.containerHeight) p.clearTimeout(c.reflowTimeout), c.reflowTimeout = ia(function () {\n            c.container && c.setSize(void 0, void 0, !1);\n          }, a ? 100 : 0);\n          c.containerWidth = f;\n          c.containerHeight = b;\n        }\n      };\n\n      f.prototype.setReflow = function (a) {\n        var c = this;\n        !1 === a || this.unbindReflow ? !1 === a && this.unbindReflow && (this.unbindReflow = this.unbindReflow()) : (this.unbindReflow = u(g, \"resize\", function (a) {\n          c.options && c.reflow(a);\n        }), u(this, \"destroy\", this.unbindReflow));\n      };\n\n      f.prototype.setSize = function (a, c, b) {\n        var d = this,\n            g = d.renderer;\n        d.isResizing += 1;\n        J(b, d);\n        b = g.globalAnimation;\n        d.oldChartHeight = d.chartHeight;\n        d.oldChartWidth = d.chartWidth;\n        \"undefined\" !== typeof a && (d.options.chart.width = a);\n        \"undefined\" !== typeof c && (d.options.chart.height = c);\n        d.getChartSize();\n        d.styledMode || (b ? r : M)(d.container, {\n          width: d.chartWidth + \"px\",\n          height: d.chartHeight + \"px\"\n        }, b);\n        d.setChartSize(!0);\n        g.setSize(d.chartWidth, d.chartHeight, b);\n        d.axes.forEach(function (a) {\n          a.isDirty = !0;\n          a.setScale();\n        });\n        d.isDirtyLegend = !0;\n        d.isDirtyBox = !0;\n        d.layOutTitles();\n        d.getMargins();\n        d.redraw(b);\n        d.oldChartHeight = null;\n        O(d, \"resize\");\n        ia(function () {\n          d && O(d, \"endResize\", null, function () {\n            --d.isResizing;\n          });\n        }, n(b).duration);\n      };\n\n      f.prototype.setChartSize = function (a) {\n        var c = this.inverted,\n            b = this.renderer,\n            d = this.chartWidth,\n            g = this.chartHeight,\n            e = this.options.chart,\n            f = this.spacing,\n            k = this.clipOffset,\n            h,\n            m,\n            p,\n            n;\n        this.plotLeft = h = Math.round(this.plotLeft);\n        this.plotTop = m = Math.round(this.plotTop);\n        this.plotWidth = p = Math.max(0, Math.round(d - h - this.marginRight));\n        this.plotHeight = n = Math.max(0, Math.round(g - m - this.marginBottom));\n        this.plotSizeX = c ? n : p;\n        this.plotSizeY = c ? p : n;\n        this.plotBorderWidth = e.plotBorderWidth || 0;\n        this.spacingBox = b.spacingBox = {\n          x: f[3],\n          y: f[0],\n          width: d - f[3] - f[1],\n          height: g - f[0] - f[2]\n        };\n        this.plotBox = b.plotBox = {\n          x: h,\n          y: m,\n          width: p,\n          height: n\n        };\n        c = 2 * Math.floor(this.plotBorderWidth / 2);\n        d = Math.ceil(Math.max(c, k[3]) / 2);\n        g = Math.ceil(Math.max(c, k[0]) / 2);\n        this.clipBox = {\n          x: d,\n          y: g,\n          width: Math.floor(this.plotSizeX - Math.max(c, k[1]) / 2 - d),\n          height: Math.max(0, Math.floor(this.plotSizeY - Math.max(c, k[2]) / 2 - g))\n        };\n        a || (this.axes.forEach(function (a) {\n          a.setAxisSize();\n          a.setAxisTranslation();\n        }), b.alignElements());\n        O(this, \"afterSetChartSize\", {\n          skipAxes: a\n        });\n      };\n\n      f.prototype.resetMargins = function () {\n        O(this, \"resetMargins\");\n        var a = this,\n            c = a.options.chart;\n        [\"margin\", \"spacing\"].forEach(function (b) {\n          var d = c[b],\n              g = N(d) ? d : [d, d, d, d];\n          [\"Top\", \"Right\", \"Bottom\", \"Left\"].forEach(function (d, e) {\n            a[b][e] = Q(c[b + d], g[e]);\n          });\n        });\n        k.forEach(function (c, b) {\n          a[c] = Q(a.margin[b], a.spacing[b]);\n        });\n        a.axisOffset = [0, 0, 0, 0];\n        a.clipOffset = [0, 0, 0, 0];\n      };\n\n      f.prototype.drawChartBox = function () {\n        var a = this.options.chart,\n            c = this.renderer,\n            b = this.chartWidth,\n            d = this.chartHeight,\n            g = this.styledMode,\n            e = this.plotBGImage,\n            f = a.backgroundColor,\n            k = a.plotBackgroundColor,\n            h = a.plotBackgroundImage,\n            m = this.plotLeft,\n            p = this.plotTop,\n            n = this.plotWidth,\n            l = this.plotHeight,\n            F = this.plotBox,\n            r = this.clipRect,\n            q = this.clipBox,\n            u = this.chartBackground,\n            t = this.plotBackground,\n            N = this.plotBorder,\n            z,\n            w = \"animate\";\n        u || (this.chartBackground = u = c.rect().addClass(\"highcharts-background\").add(), w = \"attr\");\n        if (g) var x = z = u.strokeWidth();else {\n          x = a.borderWidth || 0;\n          z = x + (a.shadow ? 8 : 0);\n          f = {\n            fill: f || \"none\"\n          };\n          if (x || u[\"stroke-width\"]) f.stroke = a.borderColor, f[\"stroke-width\"] = x;\n          u.attr(f).shadow(a.shadow);\n        }\n        u[w]({\n          x: z / 2,\n          y: z / 2,\n          width: b - z - x % 2,\n          height: d - z - x % 2,\n          r: a.borderRadius\n        });\n        w = \"animate\";\n        t || (w = \"attr\", this.plotBackground = t = c.rect().addClass(\"highcharts-plot-background\").add());\n        t[w](F);\n        g || (t.attr({\n          fill: k || \"none\"\n        }).shadow(a.plotShadow), h && (e ? (h !== e.attr(\"href\") && e.attr(\"href\", h), e.animate(F)) : this.plotBGImage = c.image(h, m, p, n, l).add()));\n        r ? r.animate({\n          width: q.width,\n          height: q.height\n        }) : this.clipRect = c.clipRect(q);\n        w = \"animate\";\n        N || (w = \"attr\", this.plotBorder = N = c.rect().addClass(\"highcharts-plot-border\").attr({\n          zIndex: 1\n        }).add());\n        g || N.attr({\n          stroke: a.plotBorderColor,\n          \"stroke-width\": a.plotBorderWidth || 0,\n          fill: \"none\"\n        });\n        N[w](N.crisp({\n          x: m,\n          y: p,\n          width: n,\n          height: l\n        }, -N.strokeWidth()));\n        this.isDirtyBox = !1;\n        O(this, \"afterDrawChartBox\");\n      };\n\n      f.prototype.propFromSeries = function () {\n        var a = this,\n            c = a.options.chart,\n            b = a.options.series,\n            d,\n            g,\n            e;\n        [\"inverted\", \"angular\", \"polar\"].forEach(function (f) {\n          g = A[c.type || c.defaultSeriesType];\n          e = c[f] || g && g.prototype[f];\n\n          for (d = b && b.length; !e && d--;) (g = A[b[d].type]) && g.prototype[f] && (e = !0);\n\n          a[f] = e;\n        });\n      };\n\n      f.prototype.linkSeries = function () {\n        var a = this,\n            c = a.series;\n        c.forEach(function (a) {\n          a.linkedSeries.length = 0;\n        });\n        c.forEach(function (c) {\n          var b = c.options.linkedTo;\n          V(b) && (b = \":previous\" === b ? a.series[c.index - 1] : a.get(b)) && b.linkedParent !== c && (b.linkedSeries.push(c), c.linkedParent = b, b.enabledDataSorting && c.setDataSortingOptions(), c.visible = Q(c.options.visible, b.options.visible, c.visible));\n        });\n        O(this, \"afterLinkSeries\");\n      };\n\n      f.prototype.renderSeries = function () {\n        this.series.forEach(function (a) {\n          a.translate();\n          a.render();\n        });\n      };\n\n      f.prototype.renderLabels = function () {\n        var a = this,\n            c = a.options.labels;\n        c.items && c.items.forEach(function (b) {\n          var d = K(c.style, b.style),\n              g = Z(d.left) + a.plotLeft,\n              e = Z(d.top) + a.plotTop + 12;\n          delete d.left;\n          delete d.top;\n          a.renderer.text(b.html, g, e).attr({\n            zIndex: 2\n          }).css(d).add();\n        });\n      };\n\n      f.prototype.render = function () {\n        var a = this.axes,\n            c = this.colorAxis,\n            b = this.renderer,\n            d = this.options,\n            g = function (a) {\n          a.forEach(function (a) {\n            a.visible && a.render();\n          });\n        },\n            e = 0;\n\n        this.setTitle();\n        this.legend = new E(this, d.legend);\n        this.getStacks && this.getStacks();\n        this.getMargins(!0);\n        this.setChartSize();\n        d = this.plotWidth;\n        a.some(function (a) {\n          if (a.horiz && a.visible && a.options.labels.enabled && a.series.length) return e = 21, !0;\n        });\n        var f = this.plotHeight = Math.max(this.plotHeight - e, 0);\n        a.forEach(function (a) {\n          a.setScale();\n        });\n        this.getAxisMargins();\n        var k = 1.1 < d / this.plotWidth,\n            h = 1.05 < f / this.plotHeight;\n        if (k || h) a.forEach(function (a) {\n          (a.horiz && k || !a.horiz && h) && a.setTickInterval(!0);\n        }), this.getMargins();\n        this.drawChartBox();\n        this.hasCartesianSeries ? g(a) : c && c.length && g(c);\n        this.seriesGroup || (this.seriesGroup = b.g(\"series-group\").attr({\n          zIndex: 3\n        }).add());\n        this.renderSeries();\n        this.renderLabels();\n        this.addCredits();\n        this.setResponsive && this.setResponsive();\n        this.hasRendered = !0;\n      };\n\n      f.prototype.addCredits = function (a) {\n        var c = this,\n            b = W(!0, this.options.credits, a);\n        b.enabled && !this.credits && (this.credits = this.renderer.text(b.text + (this.mapCredits || \"\"), 0, 0).addClass(\"highcharts-credits\").on(\"click\", function () {\n          b.href && (g.location.href = b.href);\n        }).attr({\n          align: b.position.align,\n          zIndex: 8\n        }), c.styledMode || this.credits.css(b.style), this.credits.add().align(b.position), this.credits.update = function (a) {\n          c.credits = c.credits.destroy();\n          c.addCredits(a);\n        });\n      };\n\n      f.prototype.destroy = function () {\n        var a = this,\n            c = a.axes,\n            b = a.series,\n            d = a.container,\n            g = d && d.parentNode,\n            e;\n        O(a, \"destroy\");\n        a.renderer.forExport ? I(x, a) : x[a.index] = void 0;\n        v.chartCount--;\n        a.renderTo.removeAttribute(\"data-highcharts-chart\");\n        ha(a);\n\n        for (e = c.length; e--;) c[e] = c[e].destroy();\n\n        this.scroller && this.scroller.destroy && this.scroller.destroy();\n\n        for (e = b.length; e--;) b[e] = b[e].destroy();\n\n        \"title subtitle chartBackground plotBackground plotBGImage plotBorder seriesGroup clipRect credits pointer rangeSelector legend resetZoomButton tooltip renderer\".split(\" \").forEach(function (c) {\n          var b = a[c];\n          b && b.destroy && (a[c] = b.destroy());\n        });\n        d && (d.innerHTML = q.emptyHTML, ha(d), g && P(d));\n        X(a, function (c, b) {\n          delete a[b];\n        });\n      };\n\n      f.prototype.firstRender = function () {\n        var a = this,\n            c = a.options;\n\n        if (!a.isReadyToRender || a.isReadyToRender()) {\n          a.getContainer();\n          a.resetMargins();\n          a.setChartSize();\n          a.propFromSeries();\n          a.getAxes();\n          (F(c.series) ? c.series : []).forEach(function (c) {\n            a.initSeries(c);\n          });\n          a.linkSeries();\n          a.setSeriesData();\n          O(a, \"beforeRender\");\n          y && (G.isRequired() ? a.pointer = new G(a, c) : a.pointer = new y(a, c));\n          a.render();\n          a.pointer.getChartPosition();\n          if (!a.renderer.imgCount && !a.hasLoaded) a.onload();\n          a.temporaryDisplay(!0);\n        }\n      };\n\n      f.prototype.onload = function () {\n        this.callbacks.concat([this.callback]).forEach(function (a) {\n          a && \"undefined\" !== typeof this.index && a.apply(this, [this]);\n        }, this);\n        O(this, \"load\");\n        O(this, \"render\");\n        U(this.index) && this.setReflow(this.options.chart.reflow);\n        this.warnIfA11yModuleNotLoaded();\n        this.hasLoaded = !0;\n      };\n\n      f.prototype.warnIfA11yModuleNotLoaded = function () {\n        var a = this.options,\n            c = this.title;\n        a && !this.accessibility && (this.renderer.boxWrapper.attr({\n          role: \"img\",\n          \"aria-label\": c && c.element.textContent || \"\"\n        }), a.accessibility && !1 === a.accessibility.enabled || H('Highcharts warning: Consider including the \"accessibility.js\" module to make your chart more usable for people with disabilities. Set the \"accessibility.enabled\" option to false to remove this warning. See https://www.highcharts.com/docs/accessibility/accessibility-module.', !1, this));\n      };\n\n      f.prototype.addSeries = function (a, c, b) {\n        var d = this,\n            g;\n        a && (c = Q(c, !0), O(d, \"addSeries\", {\n          options: a\n        }, function () {\n          g = d.initSeries(a);\n          d.isDirtyLegend = !0;\n          d.linkSeries();\n          g.enabledDataSorting && g.setData(a.data, !1);\n          O(d, \"afterAddSeries\", {\n            series: g\n          });\n          c && d.redraw(b);\n        }));\n        return g;\n      };\n\n      f.prototype.addAxis = function (a, c, b, d) {\n        return this.createAxis(c ? \"xAxis\" : \"yAxis\", {\n          axis: a,\n          redraw: b,\n          animation: d\n        });\n      };\n\n      f.prototype.addColorAxis = function (a, c, b) {\n        return this.createAxis(\"colorAxis\", {\n          axis: a,\n          redraw: c,\n          animation: b\n        });\n      };\n\n      f.prototype.createAxis = function (a, c) {\n        a = new e(this, W(c.axis, {\n          index: this[a].length,\n          isX: \"xAxis\" === a\n        }));\n        Q(c.redraw, !0) && this.redraw(c.animation);\n        return a;\n      };\n\n      f.prototype.showLoading = function (a) {\n        var c = this,\n            b = c.options,\n            d = b.loading,\n            g = function () {\n          e && M(e, {\n            left: c.plotLeft + \"px\",\n            top: c.plotTop + \"px\",\n            width: c.plotWidth + \"px\",\n            height: c.plotHeight + \"px\"\n          });\n        },\n            e = c.loadingDiv,\n            f = c.loadingSpan;\n\n        e || (c.loadingDiv = e = R(\"div\", {\n          className: \"highcharts-loading highcharts-loading-hidden\"\n        }, null, c.container));\n        f || (c.loadingSpan = f = R(\"span\", {\n          className: \"highcharts-loading-inner\"\n        }, null, e), u(c, \"redraw\", g));\n        e.className = \"highcharts-loading\";\n        q.setElementHTML(f, Q(a, b.lang.loading, \"\"));\n        c.styledMode || (M(e, K(d.style, {\n          zIndex: 10\n        })), M(f, d.labelStyle), c.loadingShown || (M(e, {\n          opacity: 0,\n          display: \"\"\n        }), r(e, {\n          opacity: d.style.opacity || .5\n        }, {\n          duration: d.showDuration || 0\n        })));\n        c.loadingShown = !0;\n        g();\n      };\n\n      f.prototype.hideLoading = function () {\n        var a = this.options,\n            c = this.loadingDiv;\n        c && (c.className = \"highcharts-loading highcharts-loading-hidden\", this.styledMode || r(c, {\n          opacity: 0\n        }, {\n          duration: a.loading.hideDuration || 100,\n          complete: function () {\n            M(c, {\n              display: \"none\"\n            });\n          }\n        }));\n        this.loadingShown = !1;\n      };\n\n      f.prototype.update = function (a, c, d, g) {\n        var e = this,\n            f = {\n          credits: \"addCredits\",\n          title: \"setTitle\",\n          subtitle: \"setSubtitle\",\n          caption: \"setCaption\"\n        },\n            k = a.isResponsiveOptions,\n            h = [],\n            m,\n            p;\n        O(e, \"update\", {\n          options: a\n        });\n        k || e.setResponsive(!1, !0);\n        a = S(a, e.options);\n        e.userOptions = W(e.userOptions, a);\n        var n = a.chart;\n\n        if (n) {\n          W(!0, e.options.chart, n);\n          \"className\" in n && e.setClassName(n.className);\n          \"reflow\" in n && e.setReflow(n.reflow);\n\n          if (\"inverted\" in n || \"polar\" in n || \"type\" in n) {\n            e.propFromSeries();\n            var l = !0;\n          }\n\n          \"alignTicks\" in n && (l = !0);\n          \"events\" in n && z(this, n);\n          X(n, function (a, c) {\n            -1 !== e.propsRequireUpdateSeries.indexOf(\"chart.\" + c) && (m = !0);\n            -1 !== e.propsRequireDirtyBox.indexOf(c) && (e.isDirtyBox = !0);\n            -1 !== e.propsRequireReflow.indexOf(c) && (k ? e.isDirtyBox = !0 : p = !0);\n          });\n          !e.styledMode && n.style && e.renderer.setStyle(e.options.chart.style || {});\n        }\n\n        !e.styledMode && a.colors && (this.options.colors = a.colors);\n        a.time && (this.time === D && (this.time = new b(a.time)), W(!0, e.options.time, a.time));\n        X(a, function (c, b) {\n          if (e[b] && \"function\" === typeof e[b].update) e[b].update(c, !1);else if (\"function\" === typeof e[f[b]]) e[f[b]](c);else \"colors\" !== b && -1 === e.collectionsWithUpdate.indexOf(b) && W(!0, e.options[b], a[b]);\n          \"chart\" !== b && -1 !== e.propsRequireUpdateSeries.indexOf(b) && (m = !0);\n        });\n        this.collectionsWithUpdate.forEach(function (c) {\n          if (a[c]) {\n            var b = [];\n            e[c].forEach(function (a, c) {\n              a.options.isInternal || b.push(Q(a.options.index, c));\n            });\n            fa(a[c]).forEach(function (a, g) {\n              var f = U(a.id),\n                  k;\n              f && (k = e.get(a.id));\n              !k && e[c] && (k = e[c][b ? b[g] : g]) && f && U(k.options.id) && (k = void 0);\n              k && k.coll === c && (k.update(a, !1), d && (k.touched = !0));\n              !k && d && e.collectionsWithInit[c] && (e.collectionsWithInit[c][0].apply(e, [a].concat(e.collectionsWithInit[c][1] || []).concat([!1])).touched = !0);\n            });\n            d && e[c].forEach(function (a) {\n              a.touched || a.options.isInternal ? delete a.touched : h.push(a);\n            });\n          }\n        });\n        h.forEach(function (a) {\n          a.chart && a.remove && a.remove(!1);\n        });\n        l && e.axes.forEach(function (a) {\n          a.update({}, !1);\n        });\n        m && e.getSeriesOrderByLinks().forEach(function (a) {\n          a.chart && a.update({}, !1);\n        }, this);\n        l = n && n.width;\n        n = n && (V(n.height) ? ba(n.height, l || e.chartWidth) : n.height);\n        p || T(l) && l !== e.chartWidth || T(n) && n !== e.chartHeight ? e.setSize(l, n, g) : Q(c, !0) && e.redraw(g);\n        O(e, \"afterUpdate\", {\n          options: a,\n          redraw: c,\n          animation: g\n        });\n      };\n\n      f.prototype.setSubtitle = function (a, c) {\n        this.applyDescription(\"subtitle\", a);\n        this.layOutTitles(c);\n      };\n\n      f.prototype.setCaption = function (a, c) {\n        this.applyDescription(\"caption\", a);\n        this.layOutTitles(c);\n      };\n\n      f.prototype.showResetZoom = function () {\n        function a() {\n          b.zoomOut();\n        }\n\n        var b = this,\n            d = c.lang,\n            g = b.options.chart.resetZoomButton,\n            e = g.theme,\n            f = \"chart\" === g.relativeTo || \"spacingBox\" === g.relativeTo ? null : \"scrollablePlotBox\";\n        O(this, \"beforeShowResetZoom\", null, function () {\n          b.resetZoomButton = b.renderer.button(d.resetZoom, null, null, a, e).attr({\n            align: g.position.align,\n            title: d.resetZoomTitle\n          }).addClass(\"highcharts-reset-zoom\").add().align(g.position, !1, f);\n        });\n        O(this, \"afterShowResetZoom\");\n      };\n\n      f.prototype.zoomOut = function () {\n        O(this, \"selection\", {\n          resetSelection: !0\n        }, this.zoom);\n      };\n\n      f.prototype.zoom = function (a) {\n        var c = this,\n            b = c.pointer,\n            d = c.inverted ? b.mouseDownX : b.mouseDownY,\n            g = !1,\n            e;\n        !a || a.resetSelection ? (c.axes.forEach(function (a) {\n          e = a.zoom();\n        }), b.initiated = !1) : a.xAxis.concat(a.yAxis).forEach(function (a) {\n          var f = a.axis,\n              k = c.inverted ? f.left : f.top,\n              h = c.inverted ? k + f.width : k + f.height,\n              m = f.isXAxis,\n              n = !1;\n          if (!m && d >= k && d <= h || m || !U(d)) n = !0;\n          b[m ? \"zoomX\" : \"zoomY\"] && n && (e = f.zoom(a.min, a.max), f.displayBtn && (g = !0));\n        });\n        var f = c.resetZoomButton;\n        g && !f ? c.showResetZoom() : !g && N(f) && (c.resetZoomButton = f.destroy());\n        e && c.redraw(Q(c.options.chart.animation, a && a.animation, 100 > c.pointCount));\n      };\n\n      f.prototype.pan = function (a, c) {\n        var b = this,\n            d = b.hoverPoints;\n        c = \"object\" === typeof c ? c : {\n          enabled: c,\n          type: \"x\"\n        };\n        var g = b.options.chart;\n        g && g.panning && (g.panning = c);\n        var e = c.type,\n            f;\n        O(this, \"pan\", {\n          originalEvent: a\n        }, function () {\n          d && d.forEach(function (a) {\n            a.setState();\n          });\n          var c = b.xAxis;\n          \"xy\" === e ? c = c.concat(b.yAxis) : \"y\" === e && (c = b.yAxis);\n          var g = {};\n          c.forEach(function (c) {\n            if (c.options.panningEnabled && !c.options.isInternal) {\n              var d = c.horiz,\n                  k = a[d ? \"chartX\" : \"chartY\"];\n              d = d ? \"mouseDownX\" : \"mouseDownY\";\n              var h = b[d],\n                  m = c.minPointOffset || 0,\n                  n = c.reversed && !b.inverted || !c.reversed && b.inverted ? -1 : 1,\n                  p = c.getExtremes(),\n                  l = c.toValue(h - k, !0) + m * n,\n                  F = c.toValue(h + c.len - k, !0) - (m * n || c.isXAxis && c.pointRangePadding || 0),\n                  r = F < l;\n              n = c.hasVerticalPanning();\n              h = r ? F : l;\n              l = r ? l : F;\n              var q = c.panningState;\n              !n || c.isXAxis || q && !q.isDirty || c.series.forEach(function (a) {\n                var c = a.getProcessedData(!0);\n                c = a.getExtremes(c.yData, !0);\n                q || (q = {\n                  startMin: Number.MAX_VALUE,\n                  startMax: -Number.MAX_VALUE\n                });\n                T(c.dataMin) && T(c.dataMax) && (q.startMin = Math.min(Q(a.options.threshold, Infinity), c.dataMin, q.startMin), q.startMax = Math.max(Q(a.options.threshold, -Infinity), c.dataMax, q.startMax));\n              });\n              n = Math.min(Q(q && q.startMin, p.dataMin), m ? p.min : c.toValue(c.toPixels(p.min) - c.minPixelPadding));\n              F = Math.max(Q(q && q.startMax, p.dataMax), m ? p.max : c.toValue(c.toPixels(p.max) + c.minPixelPadding));\n              c.panningState = q;\n              c.isOrdinal || (m = n - h, 0 < m && (l += m, h = n), m = l - F, 0 < m && (l = F, h -= m), c.series.length && h !== p.min && l !== p.max && h >= n && l <= F && (c.setExtremes(h, l, !1, !1, {\n                trigger: \"pan\"\n              }), !b.resetZoomButton && h !== n && l !== F && e.match(\"y\") && (b.showResetZoom(), c.displayBtn = !1), f = !0), g[d] = k);\n            }\n          });\n          X(g, function (a, c) {\n            b[c] = a;\n          });\n          f && b.redraw(!1);\n          M(b.container, {\n            cursor: \"move\"\n          });\n        });\n      };\n\n      return f;\n    }();\n\n    K(f.prototype, {\n      callbacks: [],\n      collectionsWithInit: {\n        xAxis: [f.prototype.addAxis, [!0]],\n        yAxis: [f.prototype.addAxis, [!1]],\n        series: [f.prototype.addSeries]\n      },\n      collectionsWithUpdate: [\"xAxis\", \"yAxis\", \"series\"],\n      propsRequireDirtyBox: \"backgroundColor borderColor borderWidth borderRadius plotBackgroundColor plotBackgroundImage plotBorderColor plotBorderWidth plotShadow shadow\".split(\" \"),\n      propsRequireReflow: \"margin marginTop marginRight marginBottom marginLeft spacing spacingTop spacingRight spacingBottom spacingLeft\".split(\" \"),\n      propsRequireUpdateSeries: \"chart.inverted chart.polar chart.ignoreHiddenSeries chart.type colors plotOptions time tooltip\".split(\" \")\n    });\n    \"\";\n    return f;\n  });\n  K(l, \"Core/Legend/LegendSymbol.js\", [l[\"Core/Utilities.js\"]], function (f) {\n    var e = f.merge,\n        l = f.pick,\n        C;\n\n    (function (f) {\n      f.drawLineMarker = function (f) {\n        var v = this.options,\n            B = f.symbolWidth,\n            y = f.symbolHeight,\n            t = y / 2,\n            h = this.chart.renderer,\n            d = this.legendGroup;\n        f = f.baseline - Math.round(.3 * f.fontMetrics.b);\n        var b = {},\n            p = v.marker;\n        this.chart.styledMode || (b = {\n          \"stroke-width\": v.lineWidth || 0\n        }, v.dashStyle && (b.dashstyle = v.dashStyle));\n        this.legendLine = h.path([[\"M\", 0, f], [\"L\", B, f]]).addClass(\"highcharts-graph\").attr(b).add(d);\n        p && !1 !== p.enabled && B && (v = Math.min(l(p.radius, t), t), 0 === this.symbol.indexOf(\"url\") && (p = e(p, {\n          width: y,\n          height: y\n        }), v = 0), this.legendSymbol = B = h.symbol(this.symbol, B / 2 - v, f - v, 2 * v, 2 * v, p).addClass(\"highcharts-point\").add(d), B.isMarker = !0);\n      };\n\n      f.drawRectangle = function (e, f) {\n        var v = e.symbolHeight,\n            y = e.options.squareSymbol;\n        f.legendSymbol = this.chart.renderer.rect(y ? (e.symbolWidth - v) / 2 : 0, e.baseline - v + 1, y ? v : e.symbolWidth, v, l(e.options.symbolRadius, v / 2)).addClass(\"highcharts-point\").attr({\n          zIndex: 3\n        }).add(f.legendGroup);\n      };\n    })(C || (C = {}));\n\n    return C;\n  });\n  K(l, \"Core/Series/SeriesDefaults.js\", [], function () {\n    return {\n      lineWidth: 2,\n      allowPointSelect: !1,\n      crisp: !0,\n      showCheckbox: !1,\n      animation: {\n        duration: 1E3\n      },\n      events: {},\n      marker: {\n        enabledThreshold: 2,\n        lineColor: \"#ffffff\",\n        lineWidth: 0,\n        radius: 4,\n        states: {\n          normal: {\n            animation: !0\n          },\n          hover: {\n            animation: {\n              duration: 50\n            },\n            enabled: !0,\n            radiusPlus: 2,\n            lineWidthPlus: 1\n          },\n          select: {\n            fillColor: \"#cccccc\",\n            lineColor: \"#000000\",\n            lineWidth: 2\n          }\n        }\n      },\n      point: {\n        events: {}\n      },\n      dataLabels: {\n        animation: {},\n        align: \"center\",\n        defer: !0,\n        formatter: function () {\n          var f = this.series.chart.numberFormatter;\n          return \"number\" !== typeof this.y ? \"\" : f(this.y, -1);\n        },\n        padding: 5,\n        style: {\n          fontSize: \"11px\",\n          fontWeight: \"bold\",\n          color: \"contrast\",\n          textOutline: \"1px contrast\"\n        },\n        verticalAlign: \"bottom\",\n        x: 0,\n        y: 0\n      },\n      cropThreshold: 300,\n      opacity: 1,\n      pointRange: 0,\n      softThreshold: !0,\n      states: {\n        normal: {\n          animation: !0\n        },\n        hover: {\n          animation: {\n            duration: 50\n          },\n          lineWidthPlus: 1,\n          marker: {},\n          halo: {\n            size: 10,\n            opacity: .25\n          }\n        },\n        select: {\n          animation: {\n            duration: 0\n          }\n        },\n        inactive: {\n          animation: {\n            duration: 50\n          },\n          opacity: .2\n        }\n      },\n      stickyTracking: !0,\n      turboThreshold: 1E3,\n      findNearestPointBy: \"x\"\n    };\n  });\n  K(l, \"Core/Series/Series.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/DefaultOptions.js\"], l[\"Core/Foundation.js\"], l[\"Core/Globals.js\"], l[\"Core/Legend/LegendSymbol.js\"], l[\"Core/Series/Point.js\"], l[\"Core/Series/SeriesDefaults.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Renderer/SVG/SVGElement.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E, G, B, y, t) {\n    var h = f.animObject,\n        d = f.setAnimation,\n        b = e.defaultOptions,\n        p = l.registerEventOptions,\n        q = C.hasTouch,\n        r = C.svg,\n        n = C.win,\n        J = B.seriesTypes,\n        w = t.addEvent,\n        z = t.arrayMax,\n        x = t.arrayMin,\n        m = t.clamp,\n        k = t.cleanRecursively,\n        a = t.correctFloat,\n        g = t.defined,\n        c = t.erase,\n        D = t.error,\n        A = t.extend,\n        u = t.find,\n        L = t.fireEvent,\n        S = t.getNestedProperty,\n        R = t.isArray,\n        M = t.isNumber,\n        U = t.isString,\n        P = t.merge,\n        I = t.objectEach,\n        H = t.pick,\n        K = t.removeEvent,\n        da = t.splat,\n        O = t.syncTimeout;\n\n    f = function () {\n      function e() {\n        this.zones = this.yAxis = this.xAxis = this.userOptions = this.tooltipOptions = this.processedYData = this.processedXData = this.points = this.options = this.linkedSeries = this.index = this.eventsToUnbind = this.eventOptions = this.data = this.chart = this._i = void 0;\n      }\n\n      e.prototype.init = function (a, c) {\n        L(this, \"init\", {\n          options: c\n        });\n        var b = this,\n            d = a.series;\n        this.eventsToUnbind = [];\n        b.chart = a;\n        b.options = b.setOptions(c);\n        c = b.options;\n        b.linkedSeries = [];\n        b.bindAxes();\n        A(b, {\n          name: c.name,\n          state: \"\",\n          visible: !1 !== c.visible,\n          selected: !0 === c.selected\n        });\n        p(this, c);\n        var g = c.events;\n        if (g && g.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) a.runTrackerClick = !0;\n        b.getColor();\n        b.getSymbol();\n        b.parallelArrays.forEach(function (a) {\n          b[a + \"Data\"] || (b[a + \"Data\"] = []);\n        });\n        b.isCartesian && (a.hasCartesianSeries = !0);\n        var e;\n        d.length && (e = d[d.length - 1]);\n        b._i = H(e && e._i, -1) + 1;\n        b.opacity = b.options.opacity;\n        a.orderSeries(this.insert(d));\n        c.dataSorting && c.dataSorting.enabled ? b.setDataSortingOptions() : b.points || b.data || b.setData(c.data, !1);\n        L(this, \"afterInit\");\n      };\n\n      e.prototype.is = function (a) {\n        return J[a] && this instanceof J[a];\n      };\n\n      e.prototype.insert = function (a) {\n        var c = this.options.index,\n            b;\n\n        if (M(c)) {\n          for (b = a.length; b--;) if (c >= H(a[b].options.index, a[b]._i)) {\n            a.splice(b + 1, 0, this);\n            break;\n          }\n\n          -1 === b && a.unshift(this);\n          b += 1;\n        } else a.push(this);\n\n        return H(b, a.length - 1);\n      };\n\n      e.prototype.bindAxes = function () {\n        var a = this,\n            c = a.options,\n            b = a.chart,\n            d;\n        L(this, \"bindAxes\", null, function () {\n          (a.axisTypes || []).forEach(function (g) {\n            var e = 0;\n            b[g].forEach(function (b) {\n              d = b.options;\n              if (c[g] === e && !d.isInternal || \"undefined\" !== typeof c[g] && c[g] === d.id || \"undefined\" === typeof c[g] && 0 === d.index) a.insert(b.series), a[g] = b, b.isDirty = !0;\n              d.isInternal || e++;\n            });\n            a[g] || a.optionalAxis === g || D(18, !0, b);\n          });\n        });\n        L(this, \"afterBindAxes\");\n      };\n\n      e.prototype.updateParallelArrays = function (a, c) {\n        var b = a.series,\n            d = arguments,\n            g = M(c) ? function (d) {\n          var g = \"y\" === d && b.toYData ? b.toYData(a) : a[d];\n          b[d + \"Data\"][c] = g;\n        } : function (a) {\n          Array.prototype[c].apply(b[a + \"Data\"], Array.prototype.slice.call(d, 2));\n        };\n        b.parallelArrays.forEach(g);\n      };\n\n      e.prototype.hasData = function () {\n        return this.visible && \"undefined\" !== typeof this.dataMax && \"undefined\" !== typeof this.dataMin || this.visible && this.yData && 0 < this.yData.length;\n      };\n\n      e.prototype.autoIncrement = function (a) {\n        var c = this.options,\n            b = c.pointIntervalUnit,\n            d = c.relativeXValue,\n            g = this.chart.time,\n            e = this.xIncrement,\n            f;\n        e = H(e, c.pointStart, 0);\n        this.pointInterval = f = H(this.pointInterval, c.pointInterval, 1);\n        d && M(a) && (f *= a);\n        b && (c = new g.Date(e), \"day\" === b ? g.set(\"Date\", c, g.get(\"Date\", c) + f) : \"month\" === b ? g.set(\"Month\", c, g.get(\"Month\", c) + f) : \"year\" === b && g.set(\"FullYear\", c, g.get(\"FullYear\", c) + f), f = c.getTime() - e);\n        if (d && M(a)) return e + f;\n        this.xIncrement = e + f;\n        return e;\n      };\n\n      e.prototype.setDataSortingOptions = function () {\n        var a = this.options;\n        A(this, {\n          requireSorting: !1,\n          sorted: !1,\n          enabledDataSorting: !0,\n          allowDG: !1\n        });\n        g(a.pointRange) || (a.pointRange = 1);\n      };\n\n      e.prototype.setOptions = function (a) {\n        var c = this.chart,\n            d = c.options,\n            e = d.plotOptions,\n            f = c.userOptions || {};\n        a = P(a);\n        c = c.styledMode;\n        var k = {\n          plotOptions: e,\n          userOptions: a\n        };\n        L(this, \"setOptions\", k);\n        var h = k.plotOptions[this.type],\n            m = f.plotOptions || {};\n        this.userOptions = k.userOptions;\n        f = P(h, e.series, f.plotOptions && f.plotOptions[this.type], a);\n        this.tooltipOptions = P(b.tooltip, b.plotOptions.series && b.plotOptions.series.tooltip, b.plotOptions[this.type].tooltip, d.tooltip.userOptions, e.series && e.series.tooltip, e[this.type].tooltip, a.tooltip);\n        this.stickyTracking = H(a.stickyTracking, m[this.type] && m[this.type].stickyTracking, m.series && m.series.stickyTracking, this.tooltipOptions.shared && !this.noSharedTooltip ? !0 : f.stickyTracking);\n        null === h.marker && delete f.marker;\n        this.zoneAxis = f.zoneAxis;\n        e = this.zones = (f.zones || []).slice();\n        !f.negativeColor && !f.negativeFillColor || f.zones || (d = {\n          value: f[this.zoneAxis + \"Threshold\"] || f.threshold || 0,\n          className: \"highcharts-negative\"\n        }, c || (d.color = f.negativeColor, d.fillColor = f.negativeFillColor), e.push(d));\n        e.length && g(e[e.length - 1].value) && e.push(c ? {} : {\n          color: this.color,\n          fillColor: this.fillColor\n        });\n        L(this, \"afterSetOptions\", {\n          options: f\n        });\n        return f;\n      };\n\n      e.prototype.getName = function () {\n        return H(this.options.name, \"Series \" + (this.index + 1));\n      };\n\n      e.prototype.getCyclic = function (a, c, b) {\n        var d = this.chart,\n            e = this.userOptions,\n            f = a + \"Index\",\n            k = a + \"Counter\",\n            h = b ? b.length : H(d.options.chart[a + \"Count\"], d[a + \"Count\"]);\n\n        if (!c) {\n          var m = H(e[f], e[\"_\" + f]);\n          g(m) || (d.series.length || (d[k] = 0), e[\"_\" + f] = m = d[k] % h, d[k] += 1);\n          b && (c = b[m]);\n        }\n\n        \"undefined\" !== typeof m && (this[f] = m);\n        this[a] = c;\n      };\n\n      e.prototype.getColor = function () {\n        this.chart.styledMode ? this.getCyclic(\"color\") : this.options.colorByPoint ? this.color = \"#cccccc\" : this.getCyclic(\"color\", this.options.color || b.plotOptions[this.type].color, this.chart.options.colors);\n      };\n\n      e.prototype.getPointsCollection = function () {\n        return (this.hasGroupedData ? this.points : this.data) || [];\n      };\n\n      e.prototype.getSymbol = function () {\n        this.getCyclic(\"symbol\", this.options.marker.symbol, this.chart.options.symbols);\n      };\n\n      e.prototype.findPointIndex = function (a, c) {\n        var b = a.id,\n            d = a.x,\n            g = this.points,\n            e = this.options.dataSorting,\n            f,\n            k;\n        if (b) e = this.chart.get(b), e instanceof E && (f = e);else if (this.linkedParent || this.enabledDataSorting || this.options.relativeXValue) if (f = function (c) {\n          return !c.touched && c.index === a.index;\n        }, e && e.matchByName ? f = function (c) {\n          return !c.touched && c.name === a.name;\n        } : this.options.relativeXValue && (f = function (c) {\n          return !c.touched && c.options.x === a.x;\n        }), f = u(g, f), !f) return;\n\n        if (f) {\n          var h = f && f.index;\n          \"undefined\" !== typeof h && (k = !0);\n        }\n\n        \"undefined\" === typeof h && M(d) && (h = this.xData.indexOf(d, c));\n        -1 !== h && \"undefined\" !== typeof h && this.cropped && (h = h >= this.cropStart ? h - this.cropStart : h);\n        !k && M(h) && g[h] && g[h].touched && (h = void 0);\n        return h;\n      };\n\n      e.prototype.updateData = function (a, c) {\n        var b = this.options,\n            d = b.dataSorting,\n            e = this.points,\n            f = [],\n            k = this.requireSorting,\n            h = a.length === e.length,\n            m,\n            n,\n            p,\n            l = !0;\n        this.xIncrement = null;\n        a.forEach(function (a, c) {\n          var n = g(a) && this.pointClass.prototype.optionsToObject.call({\n            series: this\n          }, a) || {},\n              l = n.x;\n\n          if (n.id || M(l)) {\n            if (n = this.findPointIndex(n, p), -1 === n || \"undefined\" === typeof n ? f.push(a) : e[n] && a !== b.data[n] ? (e[n].update(a, !1, null, !1), e[n].touched = !0, k && (p = n + 1)) : e[n] && (e[n].touched = !0), !h || c !== n || d && d.enabled || this.hasDerivedData) m = !0;\n          } else f.push(a);\n        }, this);\n        if (m) for (a = e.length; a--;) (n = e[a]) && !n.touched && n.remove && n.remove(!1, c);else !h || d && d.enabled ? l = !1 : (a.forEach(function (a, c) {\n          a !== e[c].y && e[c].update && e[c].update(a, !1, null, !1);\n        }), f.length = 0);\n        e.forEach(function (a) {\n          a && (a.touched = !1);\n        });\n        if (!l) return !1;\n        f.forEach(function (a) {\n          this.addPoint(a, !1, null, null, !1);\n        }, this);\n        null === this.xIncrement && this.xData && this.xData.length && (this.xIncrement = z(this.xData), this.autoIncrement());\n        return !0;\n      };\n\n      e.prototype.setData = function (a, c, b, d) {\n        var g = this,\n            e = g.points,\n            f = e && e.length || 0,\n            k = g.options,\n            h = g.chart,\n            m = k.dataSorting,\n            n = g.xAxis,\n            p = k.turboThreshold,\n            l = this.xData,\n            r = this.yData,\n            q = g.pointArrayMap;\n        q = q && q.length;\n        var F = k.keys,\n            u,\n            t = 0,\n            z = 1,\n            w = null;\n\n        if (!h.options.chart.allowMutatingData) {\n          k.data && delete g.options.data;\n          g.userOptions.data && delete g.userOptions.data;\n          var x = P(!0, a);\n        }\n\n        a = x || a || [];\n        x = a.length;\n        c = H(c, !0);\n        m && m.enabled && (a = this.sortData(a));\n        h.options.chart.allowMutatingData && !1 !== d && x && f && !g.cropped && !g.hasGroupedData && g.visible && !g.isSeriesBoosting && (u = this.updateData(a, b));\n\n        if (!u) {\n          g.xIncrement = null;\n          g.colorCounter = 0;\n          this.parallelArrays.forEach(function (a) {\n            g[a + \"Data\"].length = 0;\n          });\n          if (p && x > p) {\n            if (w = g.getFirstValidPoint(a), M(w)) for (b = 0; b < x; b++) l[b] = this.autoIncrement(), r[b] = a[b];else if (R(w)) {\n              if (q) {\n                if (w.length === q) for (b = 0; b < x; b++) l[b] = this.autoIncrement(), r[b] = a[b];else for (b = 0; b < x; b++) d = a[b], l[b] = d[0], r[b] = d.slice(1, q + 1);\n              } else if (F && (t = F.indexOf(\"x\"), z = F.indexOf(\"y\"), t = 0 <= t ? t : 0, z = 0 <= z ? z : 1), 1 === w.length && (z = 0), t === z) for (b = 0; b < x; b++) l[b] = this.autoIncrement(), r[b] = a[b][z];else for (b = 0; b < x; b++) d = a[b], l[b] = d[t], r[b] = d[z];\n            } else D(12, !1, h);\n          } else for (b = 0; b < x; b++) \"undefined\" !== typeof a[b] && (d = {\n            series: g\n          }, g.pointClass.prototype.applyOptions.apply(d, [a[b]]), g.updateParallelArrays(d, b));\n          r && U(r[0]) && D(14, !0, h);\n          g.data = [];\n          g.options.data = g.userOptions.data = a;\n\n          for (b = f; b--;) e[b] && e[b].destroy && e[b].destroy();\n\n          n && (n.minRange = n.userMinRange);\n          g.isDirty = h.isDirtyBox = !0;\n          g.isDirtyData = !!e;\n          b = !1;\n        }\n\n        \"point\" === k.legendType && (this.processData(), this.generatePoints());\n        c && h.redraw(b);\n      };\n\n      e.prototype.sortData = function (a) {\n        var c = this,\n            b = c.options.dataSorting.sortKey || \"y\",\n            d = function (a, c) {\n          return g(c) && a.pointClass.prototype.optionsToObject.call({\n            series: a\n          }, c) || {};\n        };\n\n        a.forEach(function (b, g) {\n          a[g] = d(c, b);\n          a[g].index = g;\n        }, this);\n        a.concat().sort(function (a, c) {\n          a = S(b, a);\n          c = S(b, c);\n          return c < a ? -1 : c > a ? 1 : 0;\n        }).forEach(function (a, c) {\n          a.x = c;\n        }, this);\n        c.linkedSeries && c.linkedSeries.forEach(function (c) {\n          var b = c.options,\n              g = b.data;\n          b.dataSorting && b.dataSorting.enabled || !g || (g.forEach(function (b, e) {\n            g[e] = d(c, b);\n            a[e] && (g[e].x = a[e].x, g[e].index = e);\n          }), c.setData(g, !1));\n        });\n        return a;\n      };\n\n      e.prototype.getProcessedData = function (a) {\n        var c = this.xAxis,\n            b = this.options,\n            d = b.cropThreshold,\n            g = a || this.getExtremesFromAll || b.getExtremesFromAll,\n            e = this.isCartesian;\n        a = c && c.val2lin;\n        b = !(!c || !c.logarithmic);\n        var f = 0,\n            k = this.xData,\n            h = this.yData,\n            m = this.requireSorting;\n        var n = !1;\n        var p = k.length;\n\n        if (c) {\n          n = c.getExtremes();\n          var l = n.min;\n          var r = n.max;\n          n = !(!c.categories || c.names.length);\n        }\n\n        if (e && this.sorted && !g && (!d || p > d || this.forceCrop)) if (k[p - 1] < l || k[0] > r) k = [], h = [];else if (this.yData && (k[0] < l || k[p - 1] > r)) {\n          var q = this.cropData(this.xData, this.yData, l, r);\n          k = q.xData;\n          h = q.yData;\n          f = q.start;\n          q = !0;\n        }\n\n        for (d = k.length || 1; --d;) if (c = b ? a(k[d]) - a(k[d - 1]) : k[d] - k[d - 1], 0 < c && (\"undefined\" === typeof u || c < u)) var u = c;else 0 > c && m && !n && (D(15, !1, this.chart), m = !1);\n\n        return {\n          xData: k,\n          yData: h,\n          cropped: q,\n          cropStart: f,\n          closestPointRange: u\n        };\n      };\n\n      e.prototype.processData = function (a) {\n        var c = this.xAxis;\n        if (this.isCartesian && !this.isDirty && !c.isDirty && !this.yAxis.isDirty && !a) return !1;\n        a = this.getProcessedData();\n        this.cropped = a.cropped;\n        this.cropStart = a.cropStart;\n        this.processedXData = a.xData;\n        this.processedYData = a.yData;\n        this.closestPointRange = this.basePointRange = a.closestPointRange;\n        L(this, \"afterProcessData\");\n      };\n\n      e.prototype.cropData = function (a, c, b, d, g) {\n        var e = a.length,\n            f,\n            k = 0,\n            h = e;\n        g = H(g, this.cropShoulder);\n\n        for (f = 0; f < e; f++) if (a[f] >= b) {\n          k = Math.max(0, f - g);\n          break;\n        }\n\n        for (b = f; b < e; b++) if (a[b] > d) {\n          h = b + g;\n          break;\n        }\n\n        return {\n          xData: a.slice(k, h),\n          yData: c.slice(k, h),\n          start: k,\n          end: h\n        };\n      };\n\n      e.prototype.generatePoints = function () {\n        var a = this.options,\n            c = this.processedData || a.data,\n            b = this.processedXData,\n            d = this.processedYData,\n            g = this.pointClass,\n            e = b.length,\n            f = this.cropStart || 0,\n            k = this.hasGroupedData,\n            h = a.keys,\n            m = [];\n        a = a.dataGrouping && a.dataGrouping.groupAll ? f : 0;\n        var n,\n            p,\n            l = this.data;\n\n        if (!l && !k) {\n          var r = [];\n          r.length = c.length;\n          l = this.data = r;\n        }\n\n        h && k && (this.options.keys = !1);\n\n        for (p = 0; p < e; p++) {\n          r = f + p;\n\n          if (k) {\n            var q = new g().init(this, [b[p]].concat(da(d[p])));\n            q.dataGroup = this.groupMap[a + p];\n            q.dataGroup.options && (q.options = q.dataGroup.options, A(q, q.dataGroup.options), delete q.dataLabels);\n          } else (q = l[r]) || \"undefined\" === typeof c[r] || (l[r] = q = new g().init(this, c[r], b[p]));\n\n          q && (q.index = k ? a + p : r, m[p] = q);\n        }\n\n        this.options.keys = h;\n        if (l && (e !== (n = l.length) || k)) for (p = 0; p < n; p++) p !== f || k || (p += e), l[p] && (l[p].destroyElements(), l[p].plotX = void 0);\n        this.data = l;\n        this.points = m;\n        L(this, \"afterGeneratePoints\");\n      };\n\n      e.prototype.getXExtremes = function (a) {\n        return {\n          min: x(a),\n          max: z(a)\n        };\n      };\n\n      e.prototype.getExtremes = function (a, c) {\n        var b = this.xAxis,\n            d = this.yAxis,\n            g = this.processedXData || this.xData,\n            e = [],\n            f = this.requireSorting ? this.cropShoulder : 0;\n        d = d ? d.positiveValuesOnly : !1;\n        var k,\n            h = 0,\n            m = 0,\n            n = 0;\n        a = a || this.stackedYData || this.processedYData || [];\n        var p = a.length;\n\n        if (b) {\n          var l = b.getExtremes();\n          h = l.min;\n          m = l.max;\n        }\n\n        for (k = 0; k < p; k++) {\n          var q = g[k];\n          l = a[k];\n          var r = (M(l) || R(l)) && (l.length || 0 < l || !d);\n          q = c || this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || !b || (g[k + f] || q) >= h && (g[k - f] || q) <= m;\n          if (r && q) if (r = l.length) for (; r--;) M(l[r]) && (e[n++] = l[r]);else e[n++] = l;\n        }\n\n        a = {\n          activeYData: e,\n          dataMin: x(e),\n          dataMax: z(e)\n        };\n        L(this, \"afterGetExtremes\", {\n          dataExtremes: a\n        });\n        return a;\n      };\n\n      e.prototype.applyExtremes = function () {\n        var a = this.getExtremes();\n        this.dataMin = a.dataMin;\n        this.dataMax = a.dataMax;\n        return a;\n      };\n\n      e.prototype.getFirstValidPoint = function (a) {\n        for (var c = a.length, b = 0, d = null; null === d && b < c;) d = a[b], b++;\n\n        return d;\n      };\n\n      e.prototype.translate = function () {\n        this.processedXData || this.processData();\n        this.generatePoints();\n        var c = this.options,\n            b = c.stacking,\n            d = this.xAxis,\n            e = d.categories,\n            f = this.enabledDataSorting,\n            k = this.yAxis,\n            h = this.points,\n            n = h.length,\n            p = this.pointPlacementToXValue(),\n            l = !!p,\n            q = c.threshold,\n            r = c.startFromThreshold ? q : 0,\n            u = this.zoneAxis || \"y\",\n            t,\n            z,\n            w = Number.MAX_VALUE;\n\n        for (t = 0; t < n; t++) {\n          var x = h[t],\n              A = x.x,\n              y = void 0,\n              D = void 0,\n              v = x.y,\n              J = x.low,\n              B = b && k.stacking && k.stacking.stacks[(this.negStacks && v < (r ? 0 : q) ? \"-\" : \"\") + this.stackKey];\n          if (k.positiveValuesOnly && !k.validatePositiveValue(v) || d.positiveValuesOnly && !d.validatePositiveValue(A)) x.isNull = !0;\n          x.plotX = z = a(m(d.translate(A, 0, 0, 0, 1, p, \"flags\" === this.type), -1E5, 1E5));\n\n          if (b && this.visible && B && B[A]) {\n            var C = this.getStackIndicator(C, A, this.index);\n            x.isNull || (y = B[A], D = y.points[C.key]);\n          }\n\n          R(D) && (J = D[0], v = D[1], J === r && C.key === B[A].base && (J = H(M(q) && q, k.min)), k.positiveValuesOnly && 0 >= J && (J = null), x.total = x.stackTotal = y.total, x.percentage = y.total && x.y / y.total * 100, x.stackY = v, this.irregularWidths || y.setOffset(this.pointXOffset || 0, this.barW || 0));\n          x.yBottom = g(J) ? m(k.translate(J, 0, 1, 0, 1), -1E5, 1E5) : null;\n          this.dataModify && (v = this.dataModify.modifyValue(v, t));\n          x.plotY = void 0;\n          M(v) && (y = k.translate(v, !1, !0, !1, !0), \"undefined\" !== typeof y && (x.plotY = m(y, -1E5, 1E5)));\n          x.isInside = this.isPointInside(x);\n          x.clientX = l ? a(d.translate(A, 0, 0, 0, 1, p)) : z;\n          x.negative = x[u] < (c[u + \"Threshold\"] || q || 0);\n          x.category = H(e && e[x.x], x.x);\n\n          if (!x.isNull && !1 !== x.visible) {\n            \"undefined\" !== typeof G && (w = Math.min(w, Math.abs(z - G)));\n            var G = z;\n          }\n\n          x.zone = this.zones.length ? x.getZone() : void 0;\n          !x.graphic && this.group && f && (x.isNew = !0);\n        }\n\n        this.closestPointRangePx = w;\n        L(this, \"afterTranslate\");\n      };\n\n      e.prototype.getValidPoints = function (a, c, b) {\n        var d = this.chart;\n        return (a || this.points || []).filter(function (a) {\n          return c && !d.isInsidePlot(a.plotX, a.plotY, {\n            inverted: d.inverted\n          }) ? !1 : !1 !== a.visible && (b || !a.isNull);\n        });\n      };\n\n      e.prototype.getClipBox = function () {\n        var a = this.chart,\n            c = this.xAxis,\n            b = this.yAxis,\n            d = P(a.clipBox);\n        c && c.len !== a.plotSizeX && (d.width = c.len);\n        b && b.len !== a.plotSizeY && (d.height = b.len);\n        return d;\n      };\n\n      e.prototype.getSharedClipKey = function () {\n        return this.sharedClipKey = (this.options.xAxis || 0) + \",\" + (this.options.yAxis || 0);\n      };\n\n      e.prototype.setClip = function () {\n        var a = this.chart,\n            c = this.group,\n            b = this.markerGroup,\n            d = a.sharedClips;\n        a = a.renderer;\n        var g = this.getClipBox(),\n            e = this.getSharedClipKey(),\n            f = d[e];\n        f ? f.animate(g) : d[e] = f = a.clipRect(g);\n        c && c.clip(!1 === this.options.clip ? void 0 : f);\n        b && b.clip();\n      };\n\n      e.prototype.animate = function (a) {\n        var c = this.chart,\n            b = this.group,\n            d = this.markerGroup,\n            g = c.inverted,\n            e = h(this.options.animation),\n            f = [this.getSharedClipKey(), e.duration, e.easing, e.defer].join(),\n            k = c.sharedClips[f],\n            m = c.sharedClips[f + \"m\"];\n        if (a && b) e = this.getClipBox(), k ? k.attr(\"height\", e.height) : (e.width = 0, g && (e.x = c.plotHeight), k = c.renderer.clipRect(e), c.sharedClips[f] = k, m = c.renderer.clipRect({\n          x: g ? (c.plotSizeX || 0) + 99 : -99,\n          y: g ? -c.plotLeft : -c.plotTop,\n          width: 99,\n          height: g ? c.chartWidth : c.chartHeight\n        }), c.sharedClips[f + \"m\"] = m), b.clip(k), d && d.clip(m);else if (k && !k.hasClass(\"highcharts-animating\")) {\n          c = this.getClipBox();\n          var n = e.step;\n          d && d.element.childNodes.length && (e.step = function (a, c) {\n            n && n.apply(c, arguments);\n            m && m.element && m.attr(c.prop, \"width\" === c.prop ? a + 99 : a);\n          });\n          k.addClass(\"highcharts-animating\").animate(c, e);\n        }\n      };\n\n      e.prototype.afterAnimate = function () {\n        var a = this;\n        this.setClip();\n        I(this.chart.sharedClips, function (c, b, d) {\n          c && !a.chart.container.querySelector('[clip-path=\"url(#'.concat(c.id, ')\"]')) && (c.destroy(), delete d[b]);\n        });\n        this.finishedAnimating = !0;\n        L(this, \"afterAnimate\");\n      };\n\n      e.prototype.drawPoints = function () {\n        var a = this.points,\n            c = this.chart,\n            b = this.options.marker,\n            d = this[this.specialGroup] || this.markerGroup,\n            g = this.xAxis,\n            e = H(b.enabled, !g || g.isRadial ? !0 : null, this.closestPointRangePx >= b.enabledThreshold * b.radius),\n            f,\n            k;\n        if (!1 !== b.enabled || this._hasPointMarkers) for (f = 0; f < a.length; f++) {\n          var h = a[f];\n          var m = (k = h.graphic) ? \"animate\" : \"attr\";\n          var n = h.marker || {};\n          var p = !!h.marker;\n\n          if ((e && \"undefined\" === typeof n.enabled || n.enabled) && !h.isNull && !1 !== h.visible) {\n            var l = H(n.symbol, this.symbol, \"rect\");\n            var q = this.markerAttribs(h, h.selected && \"select\");\n            this.enabledDataSorting && (h.startXPos = g.reversed ? -(q.width || 0) : g.width);\n            var r = !1 !== h.isInside;\n            k ? k[r ? \"show\" : \"hide\"](r).animate(q) : r && (0 < (q.width || 0) || h.hasImage) && (h.graphic = k = c.renderer.symbol(l, q.x, q.y, q.width, q.height, p ? n : b).add(d), this.enabledDataSorting && c.hasRendered && (k.attr({\n              x: h.startXPos\n            }), m = \"animate\"));\n            k && \"animate\" === m && k[r ? \"show\" : \"hide\"](r).animate(q);\n            if (k && !c.styledMode) k[m](this.pointAttribs(h, h.selected && \"select\"));\n            k && k.addClass(h.getClassName(), !0);\n          } else k && (h.graphic = k.destroy());\n        }\n      };\n\n      e.prototype.markerAttribs = function (a, c) {\n        var b = this.options,\n            d = b.marker,\n            g = a.marker || {},\n            e = g.symbol || d.symbol,\n            f = H(g.radius, d && d.radius);\n        c && (d = d.states[c], c = g.states && g.states[c], f = H(c && c.radius, d && d.radius, f && f + (d && d.radiusPlus || 0)));\n        a.hasImage = e && 0 === e.indexOf(\"url\");\n        a.hasImage && (f = 0);\n        a = M(f) ? {\n          x: b.crisp ? Math.floor(a.plotX - f) : a.plotX - f,\n          y: a.plotY - f\n        } : {};\n        f && (a.width = a.height = 2 * f);\n        return a;\n      };\n\n      e.prototype.pointAttribs = function (a, c) {\n        var b = this.options.marker,\n            d = a && a.options,\n            g = d && d.marker || {},\n            e = d && d.color,\n            f = a && a.color,\n            k = a && a.zone && a.zone.color,\n            h = this.color;\n        a = H(g.lineWidth, b.lineWidth);\n        d = 1;\n        h = e || k || f || h;\n        e = g.fillColor || b.fillColor || h;\n        f = g.lineColor || b.lineColor || h;\n        c = c || \"normal\";\n        b = b.states[c] || {};\n        c = g.states && g.states[c] || {};\n        a = H(c.lineWidth, b.lineWidth, a + H(c.lineWidthPlus, b.lineWidthPlus, 0));\n        e = c.fillColor || b.fillColor || e;\n        f = c.lineColor || b.lineColor || f;\n        d = H(c.opacity, b.opacity, d);\n        return {\n          stroke: f,\n          \"stroke-width\": a,\n          fill: e,\n          opacity: d\n        };\n      };\n\n      e.prototype.destroy = function (a) {\n        var b = this,\n            d = b.chart,\n            g = /AppleWebKit\\/533/.test(n.navigator.userAgent),\n            e = b.data || [],\n            f,\n            k,\n            h,\n            m;\n        L(b, \"destroy\", {\n          keepEventsForUpdate: a\n        });\n        this.removeEvents(a);\n        (b.axisTypes || []).forEach(function (a) {\n          (m = b[a]) && m.series && (c(m.series, b), m.isDirty = m.forceRedraw = !0);\n        });\n        b.legendItem && b.chart.legend.destroyItem(b);\n\n        for (k = e.length; k--;) (h = e[k]) && h.destroy && h.destroy();\n\n        b.clips && b.clips.forEach(function (a) {\n          return a.destroy();\n        });\n        t.clearTimeout(b.animationTimeout);\n        I(b, function (a, c) {\n          a instanceof y && !a.survive && (f = g && \"group\" === c ? \"hide\" : \"destroy\", a[f]());\n        });\n        d.hoverSeries === b && (d.hoverSeries = void 0);\n        c(d.series, b);\n        d.orderSeries();\n        I(b, function (c, d) {\n          a && \"hcEvents\" === d || delete b[d];\n        });\n      };\n\n      e.prototype.applyZones = function () {\n        var a = this,\n            c = this.chart,\n            b = c.renderer,\n            d = this.zones,\n            g = this.clips || [],\n            e = this.graph,\n            f = this.area,\n            k = Math.max(c.chartWidth, c.chartHeight),\n            h = this[(this.zoneAxis || \"y\") + \"Axis\"],\n            n = c.inverted,\n            p,\n            l,\n            q,\n            r,\n            u,\n            t,\n            z,\n            x,\n            w = !1;\n\n        if (d.length && (e || f) && h && \"undefined\" !== typeof h.min) {\n          var A = h.reversed;\n          var y = h.horiz;\n          e && !this.showLine && e.hide();\n          f && f.hide();\n          var D = h.getExtremes();\n          d.forEach(function (d, F) {\n            p = A ? y ? c.plotWidth : 0 : y ? 0 : h.toPixels(D.min) || 0;\n            p = m(H(l, p), 0, k);\n            l = m(Math.round(h.toPixels(H(d.value, D.max), !0) || 0), 0, k);\n            w && (p = l = h.toPixels(D.max));\n            r = Math.abs(p - l);\n            u = Math.min(p, l);\n            t = Math.max(p, l);\n            h.isXAxis ? (q = {\n              x: n ? t : u,\n              y: 0,\n              width: r,\n              height: k\n            }, y || (q.x = c.plotHeight - q.x)) : (q = {\n              x: 0,\n              y: n ? t : u,\n              width: k,\n              height: r\n            }, y && (q.y = c.plotWidth - q.y));\n            n && b.isVML && (q = h.isXAxis ? {\n              x: 0,\n              y: A ? u : t,\n              height: q.width,\n              width: c.chartWidth\n            } : {\n              x: q.y - c.plotLeft - c.spacingBox.x,\n              y: 0,\n              width: q.height,\n              height: c.chartHeight\n            });\n            g[F] ? g[F].animate(q) : g[F] = b.clipRect(q);\n            z = a[\"zone-area-\" + F];\n            x = a[\"zone-graph-\" + F];\n            e && x && x.clip(g[F]);\n            f && z && z.clip(g[F]);\n            w = d.value > D.max;\n            a.resetZones && 0 === l && (l = void 0);\n          });\n          this.clips = g;\n        } else a.visible && (e && e.show(), f && f.show());\n      };\n\n      e.prototype.invertGroups = function (a) {\n        function c() {\n          [\"group\", \"markerGroup\"].forEach(function (c) {\n            b[c] && (d.renderer.isVML && b[c].attr({\n              width: b.yAxis.len,\n              height: b.xAxis.len\n            }), b[c].width = b.yAxis.len, b[c].height = b.xAxis.len, b[c].invert(b.isRadialSeries ? !1 : a));\n          });\n        }\n\n        var b = this,\n            d = b.chart;\n        b.xAxis && (b.eventsToUnbind.push(w(d, \"resize\", c)), c(), b.invertGroups = c);\n      };\n\n      e.prototype.plotGroup = function (a, c, b, d, e) {\n        var f = this[a],\n            k = !f;\n        b = {\n          visibility: b,\n          zIndex: d || .1\n        };\n        \"undefined\" === typeof this.opacity || this.chart.styledMode || \"inactive\" === this.state || (b.opacity = this.opacity);\n        k && (this[a] = f = this.chart.renderer.g().add(e));\n        f.addClass(\"highcharts-\" + c + \" highcharts-series-\" + this.index + \" highcharts-\" + this.type + \"-series \" + (g(this.colorIndex) ? \"highcharts-color-\" + this.colorIndex + \" \" : \"\") + (this.options.className || \"\") + (f.hasClass(\"highcharts-tracker\") ? \" highcharts-tracker\" : \"\"), !0);\n        f.attr(b)[k ? \"attr\" : \"animate\"](this.getPlotBox());\n        return f;\n      };\n\n      e.prototype.getPlotBox = function () {\n        var a = this.chart,\n            c = this.xAxis,\n            b = this.yAxis;\n        a.inverted && (c = b, b = this.xAxis);\n        return {\n          translateX: c ? c.left : a.plotLeft,\n          translateY: b ? b.top : a.plotTop,\n          scaleX: 1,\n          scaleY: 1\n        };\n      };\n\n      e.prototype.removeEvents = function (a) {\n        a || K(this);\n        this.eventsToUnbind.length && (this.eventsToUnbind.forEach(function (a) {\n          a();\n        }), this.eventsToUnbind.length = 0);\n      };\n\n      e.prototype.render = function () {\n        var a = this,\n            c = a.chart,\n            b = a.options,\n            d = h(b.animation),\n            g = a.visible ? \"inherit\" : \"hidden\",\n            e = b.zIndex,\n            f = a.hasRendered,\n            k = c.seriesGroup,\n            m = c.inverted;\n        c = !a.finishedAnimating && c.renderer.isSVG ? d.duration : 0;\n        L(this, \"render\");\n        var n = a.plotGroup(\"group\", \"series\", g, e, k);\n        a.markerGroup = a.plotGroup(\"markerGroup\", \"markers\", g, e, k);\n        !1 !== b.clip && a.setClip();\n        a.animate && c && a.animate(!0);\n        n.inverted = H(a.invertible, a.isCartesian) ? m : !1;\n        a.drawGraph && (a.drawGraph(), a.applyZones());\n        a.visible && a.drawPoints();\n        a.drawDataLabels && a.drawDataLabels();\n        a.redrawPoints && a.redrawPoints();\n        a.drawTracker && !1 !== a.options.enableMouseTracking && a.drawTracker();\n        a.invertGroups(m);\n        a.animate && c && a.animate();\n        f || (c && d.defer && (c += d.defer), a.animationTimeout = O(function () {\n          a.afterAnimate();\n        }, c || 0));\n        a.isDirty = !1;\n        a.hasRendered = !0;\n        L(a, \"afterRender\");\n      };\n\n      e.prototype.redraw = function () {\n        var a = this.chart,\n            c = this.isDirty || this.isDirtyData,\n            b = this.group,\n            d = this.xAxis,\n            g = this.yAxis;\n        b && (a.inverted && b.attr({\n          width: a.plotWidth,\n          height: a.plotHeight\n        }), b.animate({\n          translateX: H(d && d.left, a.plotLeft),\n          translateY: H(g && g.top, a.plotTop)\n        }));\n        this.translate();\n        this.render();\n        c && delete this.kdTree;\n      };\n\n      e.prototype.searchPoint = function (a, c) {\n        var b = this.xAxis,\n            d = this.yAxis,\n            g = this.chart.inverted;\n        return this.searchKDTree({\n          clientX: g ? b.len - a.chartY + b.pos : a.chartX - b.pos,\n          plotY: g ? d.len - a.chartX + d.pos : a.chartY - d.pos\n        }, c, a);\n      };\n\n      e.prototype.buildKDTree = function (a) {\n        function c(a, d, g) {\n          var e = a && a.length;\n\n          if (e) {\n            var f = b.kdAxisArray[d % g];\n            a.sort(function (a, c) {\n              return a[f] - c[f];\n            });\n            e = Math.floor(e / 2);\n            return {\n              point: a[e],\n              left: c(a.slice(0, e), d + 1, g),\n              right: c(a.slice(e + 1), d + 1, g)\n            };\n          }\n        }\n\n        this.buildingKdTree = !0;\n        var b = this,\n            d = -1 < b.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        delete b.kdTree;\n        O(function () {\n          b.kdTree = c(b.getValidPoints(null, !b.directTouch), d, d);\n          b.buildingKdTree = !1;\n        }, b.options.kdNow || a && \"touchstart\" === a.type ? 0 : 1);\n      };\n\n      e.prototype.searchKDTree = function (a, c, b) {\n        function d(a, c, b, m) {\n          var n = c.point,\n              p = e.kdAxisArray[b % m],\n              l = n,\n              q = g(a[f]) && g(n[f]) ? Math.pow(a[f] - n[f], 2) : null;\n          var r = g(a[k]) && g(n[k]) ? Math.pow(a[k] - n[k], 2) : null;\n          r = (q || 0) + (r || 0);\n          n.dist = g(r) ? Math.sqrt(r) : Number.MAX_VALUE;\n          n.distX = g(q) ? Math.sqrt(q) : Number.MAX_VALUE;\n          p = a[p] - n[p];\n          r = 0 > p ? \"left\" : \"right\";\n          q = 0 > p ? \"right\" : \"left\";\n          c[r] && (r = d(a, c[r], b + 1, m), l = r[h] < l[h] ? r : n);\n          c[q] && Math.sqrt(p * p) < l[h] && (a = d(a, c[q], b + 1, m), l = a[h] < l[h] ? a : l);\n          return l;\n        }\n\n        var e = this,\n            f = this.kdAxisArray[0],\n            k = this.kdAxisArray[1],\n            h = c ? \"distX\" : \"dist\";\n        c = -1 < e.options.findNearestPointBy.indexOf(\"y\") ? 2 : 1;\n        this.kdTree || this.buildingKdTree || this.buildKDTree(b);\n        if (this.kdTree) return d(a, this.kdTree, c, c);\n      };\n\n      e.prototype.pointPlacementToXValue = function () {\n        var a = this.options,\n            c = a.pointRange,\n            b = this.xAxis;\n        a = a.pointPlacement;\n        \"between\" === a && (a = b.reversed ? -.5 : .5);\n        return M(a) ? a * (c || b.pointRange) : 0;\n      };\n\n      e.prototype.isPointInside = function (a) {\n        var c = this.chart,\n            b = this.xAxis,\n            d = this.yAxis;\n        return \"undefined\" !== typeof a.plotY && \"undefined\" !== typeof a.plotX && 0 <= a.plotY && a.plotY <= (d ? d.len : c.plotHeight) && 0 <= a.plotX && a.plotX <= (b ? b.len : c.plotWidth);\n      };\n\n      e.prototype.drawTracker = function () {\n        var a = this,\n            c = a.options,\n            b = c.trackByArea,\n            d = [].concat(b ? a.areaPath : a.graphPath),\n            g = a.chart,\n            e = g.pointer,\n            f = g.renderer,\n            k = g.options.tooltip.snap,\n            h = a.tracker,\n            m = function (c) {\n          if (g.hoverSeries !== a) a.onMouseOver();\n        },\n            n = \"rgba(192,192,192,\" + (r ? .0001 : .002) + \")\";\n\n        h ? h.attr({\n          d: d\n        }) : a.graph && (a.tracker = f.path(d).attr({\n          visibility: a.visible ? \"inherit\" : \"hidden\",\n          zIndex: 2\n        }).addClass(b ? \"highcharts-tracker-area\" : \"highcharts-tracker-line\").add(a.group), g.styledMode || a.tracker.attr({\n          \"stroke-linecap\": \"round\",\n          \"stroke-linejoin\": \"round\",\n          stroke: n,\n          fill: b ? n : \"none\",\n          \"stroke-width\": a.graph.strokeWidth() + (b ? 0 : 2 * k)\n        }), [a.tracker, a.markerGroup, a.dataLabelsGroup].forEach(function (a) {\n          if (a && (a.addClass(\"highcharts-tracker\").on(\"mouseover\", m).on(\"mouseout\", function (a) {\n            e.onTrackerMouseOut(a);\n          }), c.cursor && !g.styledMode && a.css({\n            cursor: c.cursor\n          }), q)) a.on(\"touchstart\", m);\n        }));\n        L(this, \"afterDrawTracker\");\n      };\n\n      e.prototype.addPoint = function (a, c, b, d, g) {\n        var e = this.options,\n            f = this.data,\n            k = this.chart,\n            h = this.xAxis;\n        h = h && h.hasNames && h.names;\n        var m = e.data,\n            n = this.xData,\n            p;\n        c = H(c, !0);\n        var l = {\n          series: this\n        };\n        this.pointClass.prototype.applyOptions.apply(l, [a]);\n        var q = l.x;\n        var r = n.length;\n        if (this.requireSorting && q < n[r - 1]) for (p = !0; r && n[r - 1] > q;) r--;\n        this.updateParallelArrays(l, \"splice\", r, 0, 0);\n        this.updateParallelArrays(l, r);\n        h && l.name && (h[q] = l.name);\n        m.splice(r, 0, a);\n        if (p || this.processedData) this.data.splice(r, 0, null), this.processData();\n        \"point\" === e.legendType && this.generatePoints();\n        b && (f[0] && f[0].remove ? f[0].remove(!1) : (f.shift(), this.updateParallelArrays(l, \"shift\"), m.shift()));\n        !1 !== g && L(this, \"addPoint\", {\n          point: l\n        });\n        this.isDirtyData = this.isDirty = !0;\n        c && k.redraw(d);\n      };\n\n      e.prototype.removePoint = function (a, c, b) {\n        var g = this,\n            e = g.data,\n            f = e[a],\n            k = g.points,\n            h = g.chart,\n            m = function () {\n          k && k.length === e.length && k.splice(a, 1);\n          e.splice(a, 1);\n          g.options.data.splice(a, 1);\n          g.updateParallelArrays(f || {\n            series: g\n          }, \"splice\", a, 1);\n          f && f.destroy();\n          g.isDirty = !0;\n          g.isDirtyData = !0;\n          c && h.redraw();\n        };\n\n        d(b, h);\n        c = H(c, !0);\n        f ? f.firePointEvent(\"remove\", null, m) : m();\n      };\n\n      e.prototype.remove = function (a, c, b, d) {\n        function g() {\n          e.destroy(d);\n          f.isDirtyLegend = f.isDirtyBox = !0;\n          f.linkSeries();\n          H(a, !0) && f.redraw(c);\n        }\n\n        var e = this,\n            f = e.chart;\n        !1 !== b ? L(e, \"remove\", null, g) : g();\n      };\n\n      e.prototype.update = function (a, c) {\n        a = k(a, this.userOptions);\n        L(this, \"update\", {\n          options: a\n        });\n        var b = this,\n            d = b.chart,\n            g = b.userOptions,\n            e = b.initialType || b.type,\n            f = d.options.plotOptions,\n            h = J[e].prototype,\n            m = b.finishedAnimating && {\n          animation: !1\n        },\n            n = {},\n            p,\n            l = [\"eventOptions\", \"navigatorSeries\", \"baseSeries\"],\n            q = a.type || g.type || d.options.chart.type,\n            r = !(this.hasDerivedData || q && q !== this.type || \"undefined\" !== typeof a.pointStart || \"undefined\" !== typeof a.pointInterval || \"undefined\" !== typeof a.relativeXValue || a.joinBy || a.mapData || b.hasOptionChanged(\"dataGrouping\") || b.hasOptionChanged(\"pointStart\") || b.hasOptionChanged(\"pointInterval\") || b.hasOptionChanged(\"pointIntervalUnit\") || b.hasOptionChanged(\"keys\"));\n        q = q || e;\n        r && (l.push(\"data\", \"isDirtyData\", \"points\", \"processedData\", \"processedXData\", \"processedYData\", \"xIncrement\", \"cropped\", \"_hasPointMarkers\", \"_hasPointLabels\", \"clips\", \"nodes\", \"layout\", \"level\", \"mapMap\", \"mapData\", \"minY\", \"maxY\", \"minX\", \"maxX\"), !1 !== a.visible && l.push(\"area\", \"graph\"), b.parallelArrays.forEach(function (a) {\n          l.push(a + \"Data\");\n        }), a.data && (a.dataSorting && A(b.options.dataSorting, a.dataSorting), this.setData(a.data, !1)));\n        a = P(g, m, {\n          index: \"undefined\" === typeof g.index ? b.index : g.index,\n          pointStart: H(f && f.series && f.series.pointStart, g.pointStart, b.xData[0])\n        }, !r && {\n          data: b.options.data\n        }, a);\n        r && a.data && (a.data = b.options.data);\n        l = [\"group\", \"markerGroup\", \"dataLabelsGroup\", \"transformGroup\"].concat(l);\n        l.forEach(function (a) {\n          l[a] = b[a];\n          delete b[a];\n        });\n        f = !1;\n\n        if (J[q]) {\n          if (f = q !== b.type, b.remove(!1, !1, !1, !0), f) if (Object.setPrototypeOf) Object.setPrototypeOf(b, J[q].prototype);else {\n            m = Object.hasOwnProperty.call(b, \"hcEvents\") && b.hcEvents;\n\n            for (p in h) b[p] = void 0;\n\n            A(b, J[q].prototype);\n            m ? b.hcEvents = m : delete b.hcEvents;\n          }\n        } else D(17, !0, d, {\n          missingModuleFor: q\n        });\n\n        l.forEach(function (a) {\n          b[a] = l[a];\n        });\n        b.init(d, a);\n\n        if (r && this.points) {\n          var u = b.options;\n          !1 === u.visible ? (n.graphic = 1, n.dataLabel = 1) : b._hasPointLabels || (a = u.marker, h = u.dataLabels, !a || !1 !== a.enabled && (g.marker && g.marker.symbol) === a.symbol || (n.graphic = 1), h && !1 === h.enabled && (n.dataLabel = 1));\n          this.points.forEach(function (a) {\n            a && a.series && (a.resolveColor(), Object.keys(n).length && a.destroyElements(n), !1 === u.showInLegend && a.legendItem && d.legend.destroyItem(a));\n          }, this);\n        }\n\n        b.initialType = e;\n        d.linkSeries();\n        f && b.linkedSeries.length && (b.isDirtyData = !0);\n        L(this, \"afterUpdate\");\n        H(c, !0) && d.redraw(r ? void 0 : !1);\n      };\n\n      e.prototype.setName = function (a) {\n        this.name = this.options.name = this.userOptions.name = a;\n        this.chart.isDirtyLegend = !0;\n      };\n\n      e.prototype.hasOptionChanged = function (a) {\n        var c = this.options[a],\n            b = this.chart.options.plotOptions,\n            d = this.userOptions[a];\n        return d ? c !== d : c !== H(b && b[this.type] && b[this.type][a], b && b.series && b.series[a], c);\n      };\n\n      e.prototype.onMouseOver = function () {\n        var a = this.chart,\n            c = a.hoverSeries;\n        a.pointer.setHoverChartIndex();\n        if (c && c !== this) c.onMouseOut();\n        this.options.events.mouseOver && L(this, \"mouseOver\");\n        this.setState(\"hover\");\n        a.hoverSeries = this;\n      };\n\n      e.prototype.onMouseOut = function () {\n        var a = this.options,\n            c = this.chart,\n            b = c.tooltip,\n            d = c.hoverPoint;\n        c.hoverSeries = null;\n        if (d) d.onMouseOut();\n        this && a.events.mouseOut && L(this, \"mouseOut\");\n        !b || this.stickyTracking || b.shared && !this.noSharedTooltip || b.hide();\n        c.series.forEach(function (a) {\n          a.setState(\"\", !0);\n        });\n      };\n\n      e.prototype.setState = function (a, c) {\n        var b = this,\n            d = b.options,\n            g = b.graph,\n            e = d.inactiveOtherPoints,\n            f = d.states,\n            k = H(f[a || \"normal\"] && f[a || \"normal\"].animation, b.chart.options.chart.animation),\n            h = d.lineWidth,\n            m = 0,\n            n = d.opacity;\n        a = a || \"\";\n\n        if (b.state !== a && ([b.group, b.markerGroup, b.dataLabelsGroup].forEach(function (c) {\n          c && (b.state && c.removeClass(\"highcharts-series-\" + b.state), a && c.addClass(\"highcharts-series-\" + a));\n        }), b.state = a, !b.chart.styledMode)) {\n          if (f[a] && !1 === f[a].enabled) return;\n          a && (h = f[a].lineWidth || h + (f[a].lineWidthPlus || 0), n = H(f[a].opacity, n));\n          if (g && !g.dashstyle) for (d = {\n            \"stroke-width\": h\n          }, g.animate(d, k); b[\"zone-graph-\" + m];) b[\"zone-graph-\" + m].animate(d, k), m += 1;\n          e || [b.group, b.markerGroup, b.dataLabelsGroup, b.labelBySeries].forEach(function (a) {\n            a && a.animate({\n              opacity: n\n            }, k);\n          });\n        }\n\n        c && e && b.points && b.setAllPointsToState(a || void 0);\n      };\n\n      e.prototype.setAllPointsToState = function (a) {\n        this.points.forEach(function (c) {\n          c.setState && c.setState(a);\n        });\n      };\n\n      e.prototype.setVisible = function (a, c) {\n        var b = this,\n            d = b.chart,\n            g = b.legendItem,\n            e = d.options.chart.ignoreHiddenSeries,\n            f = b.visible,\n            k = (b.visible = a = b.options.visible = b.userOptions.visible = \"undefined\" === typeof a ? !f : a) ? \"show\" : \"hide\";\n        [\"group\", \"dataLabelsGroup\", \"markerGroup\", \"tracker\", \"tt\"].forEach(function (a) {\n          if (b[a]) b[a][k]();\n        });\n        if (d.hoverSeries === b || (d.hoverPoint && d.hoverPoint.series) === b) b.onMouseOut();\n        g && d.legend.colorizeItem(b, a);\n        b.isDirty = !0;\n        b.options.stacking && d.series.forEach(function (a) {\n          a.options.stacking && a.visible && (a.isDirty = !0);\n        });\n        b.linkedSeries.forEach(function (c) {\n          c.setVisible(a, !1);\n        });\n        e && (d.isDirtyBox = !0);\n        L(b, k);\n        !1 !== c && d.redraw();\n      };\n\n      e.prototype.show = function () {\n        this.setVisible(!0);\n      };\n\n      e.prototype.hide = function () {\n        this.setVisible(!1);\n      };\n\n      e.prototype.select = function (a) {\n        this.selected = a = this.options.selected = \"undefined\" === typeof a ? !this.selected : a;\n        this.checkbox && (this.checkbox.checked = a);\n        L(this, a ? \"select\" : \"unselect\");\n      };\n\n      e.prototype.shouldShowTooltip = function (a, c, b) {\n        void 0 === b && (b = {});\n        b.series = this;\n        b.visiblePlotOnly = !0;\n        return this.chart.isInsidePlot(a, c, b);\n      };\n\n      e.defaultOptions = G;\n      return e;\n    }();\n\n    A(f.prototype, {\n      axisTypes: [\"xAxis\", \"yAxis\"],\n      coll: \"series\",\n      colorCounter: 0,\n      cropShoulder: 1,\n      directTouch: !1,\n      drawLegendSymbol: v.drawLineMarker,\n      isCartesian: !0,\n      kdAxisArray: [\"clientX\", \"plotY\"],\n      parallelArrays: [\"x\", \"y\"],\n      pointClass: E,\n      requireSorting: !0,\n      sorted: !0\n    });\n    B.series = f;\n    \"\";\n    \"\";\n    return f;\n  });\n  K(l, \"Extensions/ScrollablePlotArea.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/Axis/Axis.js\"], l[\"Core/Chart/Chart.js\"], l[\"Core/Series/Series.js\"], l[\"Core/Renderer/RendererRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E) {\n    var G = f.stop,\n        B = E.addEvent,\n        y = E.createElement,\n        t = E.defined,\n        h = E.merge,\n        d = E.pick;\n    B(l, \"afterSetChartSize\", function (b) {\n      var d = this.options.chart.scrollablePlotArea,\n          f = d && d.minWidth;\n      d = d && d.minHeight;\n\n      if (!this.renderer.forExport) {\n        if (f) {\n          if (this.scrollablePixelsX = f = Math.max(0, f - this.chartWidth)) {\n            this.scrollablePlotBox = this.renderer.scrollablePlotBox = h(this.plotBox);\n            this.plotBox.width = this.plotWidth += f;\n            this.inverted ? this.clipBox.height += f : this.clipBox.width += f;\n            var l = {\n              1: {\n                name: \"right\",\n                value: f\n              }\n            };\n          }\n        } else d && (this.scrollablePixelsY = f = Math.max(0, d - this.chartHeight), t(f) && (this.scrollablePlotBox = this.renderer.scrollablePlotBox = h(this.plotBox), this.plotBox.height = this.plotHeight += f, this.inverted ? this.clipBox.width += f : this.clipBox.height += f, l = {\n          2: {\n            name: \"bottom\",\n            value: f\n          }\n        }));\n\n        l && !b.skipAxes && this.axes.forEach(function (b) {\n          l[b.side] ? b.getPlotLinePath = function () {\n            var d = l[b.side].name,\n                f = this[d];\n            this[d] = f - l[b.side].value;\n            var h = e.prototype.getPlotLinePath.apply(this, arguments);\n            this[d] = f;\n            return h;\n          } : (b.setAxisSize(), b.setAxisTranslation());\n        });\n      }\n    });\n    B(l, \"render\", function () {\n      this.scrollablePixelsX || this.scrollablePixelsY ? (this.setUpScrolling && this.setUpScrolling(), this.applyFixed()) : this.fixedDiv && this.applyFixed();\n    });\n\n    l.prototype.setUpScrolling = function () {\n      var b = this,\n          d = {\n        WebkitOverflowScrolling: \"touch\",\n        overflowX: \"hidden\",\n        overflowY: \"hidden\"\n      };\n      this.scrollablePixelsX && (d.overflowX = \"auto\");\n      this.scrollablePixelsY && (d.overflowY = \"auto\");\n      this.scrollingParent = y(\"div\", {\n        className: \"highcharts-scrolling-parent\"\n      }, {\n        position: \"relative\"\n      }, this.renderTo);\n      this.scrollingContainer = y(\"div\", {\n        className: \"highcharts-scrolling\"\n      }, d, this.scrollingParent);\n      B(this.scrollingContainer, \"scroll\", function () {\n        b.pointer && delete b.pointer.chartPosition;\n      });\n      this.innerContainer = y(\"div\", {\n        className: \"highcharts-inner-container\"\n      }, null, this.scrollingContainer);\n      this.innerContainer.appendChild(this.container);\n      this.setUpScrolling = null;\n    };\n\n    l.prototype.moveFixedElements = function () {\n      var b = this.container,\n          d = this.fixedRenderer,\n          e = \".highcharts-contextbutton .highcharts-credits .highcharts-legend .highcharts-legend-checkbox .highcharts-navigator-series .highcharts-navigator-xaxis .highcharts-navigator-yaxis .highcharts-navigator .highcharts-reset-zoom .highcharts-drillup-button .highcharts-scrollbar .highcharts-subtitle .highcharts-title\".split(\" \"),\n          f;\n      this.scrollablePixelsX && !this.inverted ? f = \".highcharts-yaxis\" : this.scrollablePixelsX && this.inverted ? f = \".highcharts-xaxis\" : this.scrollablePixelsY && !this.inverted ? f = \".highcharts-xaxis\" : this.scrollablePixelsY && this.inverted && (f = \".highcharts-yaxis\");\n      f && e.push(\"\" + f + \":not(.highcharts-radial-axis)\", \"\" + f + \"-labels:not(.highcharts-radial-axis-labels)\");\n      e.forEach(function (e) {\n        [].forEach.call(b.querySelectorAll(e), function (b) {\n          (b.namespaceURI === d.SVG_NS ? d.box : d.box.parentNode).appendChild(b);\n          b.style.pointerEvents = \"auto\";\n        });\n      });\n    };\n\n    l.prototype.applyFixed = function () {\n      var b = !this.fixedDiv,\n          e = this.options.chart,\n          f = e.scrollablePlotArea,\n          h = v.getRendererType();\n      b ? (this.fixedDiv = y(\"div\", {\n        className: \"highcharts-fixed\"\n      }, {\n        position: \"absolute\",\n        overflow: \"hidden\",\n        pointerEvents: \"none\",\n        zIndex: (e.style && e.style.zIndex || 0) + 2,\n        top: 0\n      }, null, !0), this.scrollingContainer && this.scrollingContainer.parentNode.insertBefore(this.fixedDiv, this.scrollingContainer), this.renderTo.style.overflow = \"visible\", this.fixedRenderer = e = new h(this.fixedDiv, this.chartWidth, this.chartHeight, this.options.chart.style), this.scrollableMask = e.path().attr({\n        fill: this.options.chart.backgroundColor || \"#fff\",\n        \"fill-opacity\": d(f.opacity, .85),\n        zIndex: -1\n      }).addClass(\"highcharts-scrollable-mask\").add(), B(this, \"afterShowResetZoom\", this.moveFixedElements), B(this, \"afterApplyDrilldown\", this.moveFixedElements), B(this, \"afterLayOutTitles\", this.moveFixedElements)) : this.fixedRenderer.setSize(this.chartWidth, this.chartHeight);\n      if (this.scrollableDirty || b) this.scrollableDirty = !1, this.moveFixedElements();\n      e = this.chartWidth + (this.scrollablePixelsX || 0);\n      h = this.chartHeight + (this.scrollablePixelsY || 0);\n      G(this.container);\n      this.container.style.width = e + \"px\";\n      this.container.style.height = h + \"px\";\n      this.renderer.boxWrapper.attr({\n        width: e,\n        height: h,\n        viewBox: [0, 0, e, h].join(\" \")\n      });\n      this.chartBackground.attr({\n        width: e,\n        height: h\n      });\n      this.scrollingContainer.style.height = this.chartHeight + \"px\";\n      b && (f.scrollPositionX && (this.scrollingContainer.scrollLeft = this.scrollablePixelsX * f.scrollPositionX), f.scrollPositionY && (this.scrollingContainer.scrollTop = this.scrollablePixelsY * f.scrollPositionY));\n      h = this.axisOffset;\n      b = this.plotTop - h[0] - 1;\n      f = this.plotLeft - h[3] - 1;\n      e = this.plotTop + this.plotHeight + h[2] + 1;\n      h = this.plotLeft + this.plotWidth + h[1] + 1;\n      var n = this.plotLeft + this.plotWidth - (this.scrollablePixelsX || 0),\n          l = this.plotTop + this.plotHeight - (this.scrollablePixelsY || 0);\n      b = this.scrollablePixelsX ? [[\"M\", 0, b], [\"L\", this.plotLeft - 1, b], [\"L\", this.plotLeft - 1, e], [\"L\", 0, e], [\"Z\"], [\"M\", n, b], [\"L\", this.chartWidth, b], [\"L\", this.chartWidth, e], [\"L\", n, e], [\"Z\"]] : this.scrollablePixelsY ? [[\"M\", f, 0], [\"L\", f, this.plotTop - 1], [\"L\", h, this.plotTop - 1], [\"L\", h, 0], [\"Z\"], [\"M\", f, l], [\"L\", f, this.chartHeight], [\"L\", h, this.chartHeight], [\"L\", h, l], [\"Z\"]] : [[\"M\", 0, 0]];\n      \"adjustHeight\" !== this.redrawTrigger && this.scrollableMask.attr({\n        d: b\n      });\n    };\n\n    B(e, \"afterInit\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    B(C, \"show\", function () {\n      this.chart.scrollableDirty = !0;\n    });\n    \"\";\n  });\n  K(l, \"Core/Axis/StackingAxis.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/Axis/Axis.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = f.getDeferredAnimation,\n        v = l.addEvent,\n        E = l.destroyObjectProperties,\n        G = l.fireEvent,\n        B = l.isNumber,\n        y = l.objectEach,\n        t;\n\n    (function (e) {\n      function d() {\n        var b = this.stacking;\n\n        if (b) {\n          var d = b.stacks;\n          y(d, function (b, e) {\n            E(b);\n            d[e] = null;\n          });\n          b && b.stackTotalGroup && b.stackTotalGroup.destroy();\n        }\n      }\n\n      function b() {\n        this.stacking || (this.stacking = new h(this));\n      }\n\n      var f = [];\n\n      e.compose = function (e) {\n        -1 === f.indexOf(e) && (f.push(e), v(e, \"init\", b), v(e, \"destroy\", d));\n        return e;\n      };\n\n      var h = function () {\n        function b(b) {\n          this.oldStacks = {};\n          this.stacks = {};\n          this.stacksTouched = 0;\n          this.axis = b;\n        }\n\n        b.prototype.buildStacks = function () {\n          var b = this.axis,\n              d = b.series,\n              e = b.options.reversedStacks,\n              f = d.length,\n              h;\n\n          if (!b.isXAxis) {\n            this.usePercentage = !1;\n\n            for (h = f; h--;) {\n              var m = d[e ? h : f - h - 1];\n              m.setStackedPoints();\n              m.setGroupedPoints();\n            }\n\n            for (h = 0; h < f; h++) d[h].modifyStacks();\n\n            G(b, \"afterBuildStacks\");\n          }\n        };\n\n        b.prototype.cleanStacks = function () {\n          if (!this.axis.isXAxis) {\n            if (this.oldStacks) var b = this.stacks = this.oldStacks;\n            y(b, function (b) {\n              y(b, function (b) {\n                b.cumulative = b.total;\n              });\n            });\n          }\n        };\n\n        b.prototype.resetStacks = function () {\n          var b = this,\n              d = b.stacks;\n          b.axis.isXAxis || y(d, function (d) {\n            y(d, function (e, f) {\n              B(e.touched) && e.touched < b.stacksTouched ? (e.destroy(), delete d[f]) : (e.total = null, e.cumulative = null);\n            });\n          });\n        };\n\n        b.prototype.renderStackTotals = function () {\n          var b = this.axis,\n              d = b.chart,\n              e = d.renderer,\n              f = this.stacks;\n          b = C(d, b.options.stackLabels && b.options.stackLabels.animation || !1);\n          var h = this.stackTotalGroup = this.stackTotalGroup || e.g(\"stack-labels\").attr({\n            zIndex: 6,\n            opacity: 0\n          }).add();\n          h.translate(d.plotLeft, d.plotTop);\n          y(f, function (b) {\n            y(b, function (b) {\n              b.render(h);\n            });\n          });\n          h.animate({\n            opacity: 1\n          }, b);\n        };\n\n        return b;\n      }();\n\n      e.Additions = h;\n    })(t || (t = {}));\n\n    return t;\n  });\n  K(l, \"Extensions/Stacking.js\", [l[\"Core/Axis/Axis.js\"], l[\"Core/Chart/Chart.js\"], l[\"Core/FormatUtilities.js\"], l[\"Core/Globals.js\"], l[\"Core/Series/Series.js\"], l[\"Core/Axis/StackingAxis.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E, G) {\n    var B = l.format,\n        y = G.correctFloat,\n        t = G.defined,\n        h = G.destroyObjectProperties,\n        d = G.isArray,\n        b = G.isNumber,\n        p = G.objectEach,\n        q = G.pick,\n        r = function () {\n      function d(b, d, e, f, h) {\n        var k = b.chart.inverted;\n        this.axis = b;\n        this.isNegative = e;\n        this.options = d = d || {};\n        this.x = f;\n        this.total = null;\n        this.points = {};\n        this.hasValidPoints = !1;\n        this.stack = h;\n        this.rightCliff = this.leftCliff = 0;\n        this.alignOptions = {\n          align: d.align || (k ? e ? \"left\" : \"right\" : \"center\"),\n          verticalAlign: d.verticalAlign || (k ? \"middle\" : e ? \"bottom\" : \"top\"),\n          y: d.y,\n          x: d.x\n        };\n        this.textAlign = d.textAlign || (k ? e ? \"right\" : \"left\" : \"center\");\n      }\n\n      d.prototype.destroy = function () {\n        h(this, this.axis);\n      };\n\n      d.prototype.render = function (b) {\n        var d = this.axis.chart,\n            e = this.options,\n            f = e.format;\n        f = f ? B(f, this, d) : e.formatter.call(this);\n        this.label ? this.label.attr({\n          text: f,\n          visibility: \"hidden\"\n        }) : (this.label = d.renderer.label(f, null, null, e.shape, null, null, e.useHTML, !1, \"stack-labels\"), f = {\n          r: e.borderRadius || 0,\n          text: f,\n          rotation: e.rotation,\n          padding: q(e.padding, 5),\n          visibility: \"hidden\"\n        }, d.styledMode || (f.fill = e.backgroundColor, f.stroke = e.borderColor, f[\"stroke-width\"] = e.borderWidth, this.label.css(e.style)), this.label.attr(f), this.label.added || this.label.add(b));\n        this.label.labelrank = d.plotSizeY;\n      };\n\n      d.prototype.setOffset = function (d, e, f, h, m) {\n        var k = this.axis,\n            a = k.chart;\n        h = k.translate(k.stacking.usePercentage ? 100 : h ? h : this.total, 0, 0, 0, 1);\n        f = k.translate(f ? f : 0);\n        f = t(h) && Math.abs(h - f);\n        d = q(m, a.xAxis[0].translate(this.x)) + d;\n        k = t(h) && this.getStackBox(a, this, d, h, e, f, k);\n        e = this.label;\n        f = this.isNegative;\n        d = \"justify\" === q(this.options.overflow, \"justify\");\n        var g = this.textAlign;\n        e && k && (m = e.getBBox(), h = e.padding, g = \"left\" === g ? a.inverted ? -h : h : \"right\" === g ? m.width : a.inverted && \"center\" === g ? m.width / 2 : a.inverted ? f ? m.width + h : -h : m.width / 2, f = a.inverted ? m.height / 2 : f ? -h : m.height, this.alignOptions.x = q(this.options.x, 0), this.alignOptions.y = q(this.options.y, 0), k.x -= g, k.y -= f, e.align(this.alignOptions, null, k), a.isInsidePlot(e.alignAttr.x + g - this.alignOptions.x, e.alignAttr.y + f - this.alignOptions.y) ? e.show() : (e.hide(), d = !1), d && v.prototype.justifyDataLabel.call(this.axis, e, this.alignOptions, e.alignAttr, m, k), e.attr({\n          x: e.alignAttr.x,\n          y: e.alignAttr.y\n        }), q(!d && this.options.crop, !0) && ((a = b(e.x) && b(e.y) && a.isInsidePlot(e.x - h + e.width, e.y) && a.isInsidePlot(e.x + h, e.y)) || e.hide()));\n      };\n\n      d.prototype.getStackBox = function (b, d, e, f, h, k, a) {\n        var g = d.axis.reversed,\n            c = b.inverted,\n            m = a.height + a.pos - (c ? b.plotLeft : b.plotTop);\n        d = d.isNegative && !g || !d.isNegative && g;\n        return {\n          x: c ? d ? f - a.right : f - k + a.pos - b.plotLeft : e + b.xAxis[0].transB - b.plotLeft,\n          y: c ? a.height - e - h : d ? m - f - k : m - f,\n          width: c ? k : h,\n          height: c ? h : k\n        };\n      };\n\n      return d;\n    }();\n\n    e.prototype.getStacks = function () {\n      var b = this,\n          d = b.inverted;\n      b.yAxis.forEach(function (b) {\n        b.stacking && b.stacking.stacks && b.hasVisibleSeries && (b.stacking.oldStacks = b.stacking.stacks);\n      });\n      b.series.forEach(function (e) {\n        var f = e.xAxis && e.xAxis.options || {};\n        !e.options.stacking || !0 !== e.visible && !1 !== b.options.chart.ignoreHiddenSeries || (e.stackKey = [e.type, q(e.options.stack, \"\"), d ? f.top : f.left, d ? f.height : f.width].join());\n      });\n    };\n\n    E.compose(f);\n\n    v.prototype.setGroupedPoints = function () {\n      var b = this.yAxis.stacking;\n      this.options.centerInCategory && (this.is(\"column\") || this.is(\"columnrange\")) && !this.options.stacking && 1 < this.chart.series.length ? v.prototype.setStackedPoints.call(this, \"group\") : b && p(b.stacks, function (d, e) {\n        \"group\" === e.slice(-5) && (p(d, function (b) {\n          return b.destroy();\n        }), delete b.stacks[e]);\n      });\n    };\n\n    v.prototype.setStackedPoints = function (b) {\n      var e = b || this.options.stacking;\n\n      if (e && (!0 === this.visible || !1 === this.chart.options.chart.ignoreHiddenSeries)) {\n        var f = this.processedXData,\n            h = this.processedYData,\n            n = [],\n            m = h.length,\n            k = this.options,\n            a = k.threshold,\n            g = q(k.startFromThreshold && a, 0);\n        k = k.stack;\n        b = b ? \"\" + this.type + \",\".concat(e) : this.stackKey;\n        var c = \"-\" + b,\n            p = this.negStacks,\n            l = this.yAxis,\n            u = l.stacking.stacks,\n            v = l.stacking.oldStacks,\n            B,\n            C;\n        l.stacking.stacksTouched += 1;\n\n        for (C = 0; C < m; C++) {\n          var M = f[C];\n          var G = h[C];\n          var E = this.getStackIndicator(E, M, this.index);\n          var I = E.key;\n          var H = (B = p && G < (g ? 0 : a)) ? c : b;\n          u[H] || (u[H] = {});\n          u[H][M] || (v[H] && v[H][M] ? (u[H][M] = v[H][M], u[H][M].total = null) : u[H][M] = new r(l, l.options.stackLabels, B, M, k));\n          H = u[H][M];\n          null !== G ? (H.points[I] = H.points[this.index] = [q(H.cumulative, g)], t(H.cumulative) || (H.base = I), H.touched = l.stacking.stacksTouched, 0 < E.index && !1 === this.singleStacks && (H.points[I][0] = H.points[this.index + \",\" + M + \",0\"][0])) : H.points[I] = H.points[this.index] = null;\n          \"percent\" === e ? (B = B ? b : c, p && u[B] && u[B][M] ? (B = u[B][M], H.total = B.total = Math.max(B.total, H.total) + Math.abs(G) || 0) : H.total = y(H.total + (Math.abs(G) || 0))) : \"group\" === e ? (d(G) && (G = G[0]), null !== G && (H.total = (H.total || 0) + 1)) : H.total = y(H.total + (G || 0));\n          H.cumulative = \"group\" === e ? (H.total || 1) - 1 : q(H.cumulative, g) + (G || 0);\n          null !== G && (H.points[I].push(H.cumulative), n[C] = H.cumulative, H.hasValidPoints = !0);\n        }\n\n        \"percent\" === e && (l.stacking.usePercentage = !0);\n        \"group\" !== e && (this.stackedYData = n);\n        l.stacking.oldStacks = {};\n      }\n    };\n\n    v.prototype.modifyStacks = function () {\n      var b = this,\n          d = b.stackKey,\n          e = b.yAxis.stacking.stacks,\n          f = b.processedXData,\n          h,\n          m = b.options.stacking;\n      b[m + \"Stacker\"] && [d, \"-\" + d].forEach(function (d) {\n        for (var a = f.length, g, c; a--;) if (g = f[a], h = b.getStackIndicator(h, g, b.index, d), c = (g = e[d] && e[d][g]) && g.points[h.key]) b[m + \"Stacker\"](c, g, a);\n      });\n    };\n\n    v.prototype.percentStacker = function (b, d, e) {\n      d = d.total ? 100 / d.total : 0;\n      b[0] = y(b[0] * d);\n      b[1] = y(b[1] * d);\n      this.stackedYData[e] = b[1];\n    };\n\n    v.prototype.getStackIndicator = function (b, d, e, f) {\n      !t(b) || b.x !== d || f && b.stackKey !== f ? b = {\n        x: d,\n        index: 0,\n        key: f,\n        stackKey: f\n      } : b.index++;\n      b.key = [e, d, b.index].join();\n      return b;\n    };\n\n    C.StackItem = r;\n    \"\";\n    return C.StackItem;\n  });\n  K(l, \"Series/Line/LineSeries.js\", [l[\"Core/Series/Series.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = this && this.__extends || function () {\n      var e = function (f, l) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (e, f) {\n          e.__proto__ = f;\n        } || function (e, f) {\n          for (var d in f) f.hasOwnProperty(d) && (e[d] = f[d]);\n        };\n\n        return e(f, l);\n      };\n\n      return function (f, l) {\n        function t() {\n          this.constructor = f;\n        }\n\n        e(f, l);\n        f.prototype = null === l ? Object.create(l) : (t.prototype = l.prototype, new t());\n      };\n    }(),\n        v = l.defined,\n        E = l.merge;\n\n    l = function (e) {\n      function l() {\n        var f = null !== e && e.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      C(l, e);\n\n      l.prototype.drawGraph = function () {\n        var e = this,\n            f = this.options,\n            h = (this.gappedPath || this.getGraphPath).call(this),\n            d = this.chart.styledMode,\n            b = [[\"graph\", \"highcharts-graph\"]];\n        d || b[0].push(f.lineColor || this.color || \"#cccccc\", f.dashStyle);\n        b = e.getZonesGraphs(b);\n        b.forEach(function (b, l) {\n          var p = b[0],\n              n = e[p],\n              q = n ? \"animate\" : \"attr\";\n          n ? (n.endX = e.preventGraphAnimation ? null : h.xMap, n.animate({\n            d: h\n          })) : h.length && (e[p] = n = e.chart.renderer.path(h).addClass(b[1]).attr({\n            zIndex: 1\n          }).add(e.group));\n          n && !d && (p = {\n            stroke: b[2],\n            \"stroke-width\": f.lineWidth,\n            fill: e.fillGraph && e.color || \"none\"\n          }, b[3] ? p.dashstyle = b[3] : \"square\" !== f.linecap && (p[\"stroke-linecap\"] = p[\"stroke-linejoin\"] = \"round\"), n[q](p).shadow(2 > l && f.shadow));\n          n && (n.startX = h.xMap, n.isArea = h.isArea);\n        });\n      };\n\n      l.prototype.getGraphPath = function (e, f, h) {\n        var d = this,\n            b = d.options,\n            p = [],\n            l = [],\n            r,\n            n = b.step;\n        e = e || d.points;\n        var t = e.reversed;\n        t && e.reverse();\n        (n = {\n          right: 1,\n          center: 2\n        }[n] || n && 3) && t && (n = 4 - n);\n        e = this.getValidPoints(e, !1, !(b.connectNulls && !f && !h));\n        e.forEach(function (q, t) {\n          var x = q.plotX,\n              m = q.plotY,\n              k = e[t - 1];\n          (q.leftCliff || k && k.rightCliff) && !h && (r = !0);\n          q.isNull && !v(f) && 0 < t ? r = !b.connectNulls : q.isNull && !f ? r = !0 : (0 === t || r ? t = [[\"M\", q.plotX, q.plotY]] : d.getPointSpline ? t = [d.getPointSpline(e, q, t)] : n ? (t = 1 === n ? [[\"L\", k.plotX, m]] : 2 === n ? [[\"L\", (k.plotX + x) / 2, k.plotY], [\"L\", (k.plotX + x) / 2, m]] : [[\"L\", x, k.plotY]], t.push([\"L\", x, m])) : t = [[\"L\", x, m]], l.push(q.x), n && (l.push(q.x), 2 === n && l.push(q.x)), p.push.apply(p, t), r = !1);\n        });\n        p.xMap = l;\n        return d.graphPath = p;\n      };\n\n      l.prototype.getZonesGraphs = function (e) {\n        this.zones.forEach(function (f, h) {\n          h = [\"zone-graph-\" + h, \"highcharts-graph highcharts-zone-graph-\" + h + \" \" + (f.className || \"\")];\n          this.chart.styledMode || h.push(f.color || this.color, f.dashStyle || this.options.dashStyle);\n          e.push(h);\n        }, this);\n        return e;\n      };\n\n      l.defaultOptions = E(f.defaultOptions, {});\n      return l;\n    }(f);\n\n    e.registerSeriesType(\"line\", l);\n    \"\";\n    return l;\n  });\n  K(l, \"Series/Area/AreaSeries.js\", [l[\"Core/Color/Color.js\"], l[\"Core/Legend/LegendSymbol.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C) {\n    var v = this && this.__extends || function () {\n      var e = function (d, b) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var e in d) d.hasOwnProperty(e) && (b[e] = d[e]);\n        };\n\n        return e(d, b);\n      };\n\n      return function (d, b) {\n        function f() {\n          this.constructor = d;\n        }\n\n        e(d, b);\n        d.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());\n      };\n    }(),\n        E = f.parse,\n        G = l.seriesTypes.line;\n\n    f = C.extend;\n    var B = C.merge,\n        y = C.objectEach,\n        t = C.pick;\n\n    C = function (e) {\n      function d() {\n        var b = null !== e && e.apply(this, arguments) || this;\n        b.data = void 0;\n        b.options = void 0;\n        b.points = void 0;\n        return b;\n      }\n\n      v(d, e);\n\n      d.prototype.drawGraph = function () {\n        this.areaPath = [];\n        e.prototype.drawGraph.apply(this);\n        var b = this,\n            d = this.areaPath,\n            f = this.options,\n            h = [[\"area\", \"highcharts-area\", this.color, f.fillColor]];\n        this.zones.forEach(function (d, e) {\n          h.push([\"zone-area-\" + e, \"highcharts-area highcharts-zone-area-\" + e + \" \" + d.className, d.color || b.color, d.fillColor || f.fillColor]);\n        });\n        h.forEach(function (e) {\n          var h = e[0],\n              p = {},\n              n = b[h],\n              l = n ? \"animate\" : \"attr\";\n          n ? (n.endX = b.preventGraphAnimation ? null : d.xMap, n.animate({\n            d: d\n          })) : (p.zIndex = 0, n = b[h] = b.chart.renderer.path(d).addClass(e[1]).add(b.group), n.isArea = !0);\n          b.chart.styledMode || (p.fill = t(e[3], E(e[2]).setOpacity(t(f.fillOpacity, .75)).get()));\n          n[l](p);\n          n.startX = d.xMap;\n          n.shiftUnit = f.step ? 2 : 1;\n        });\n      };\n\n      d.prototype.getGraphPath = function (b) {\n        var d = G.prototype.getGraphPath,\n            e = this.options,\n            f = e.stacking,\n            h = this.yAxis,\n            l = [],\n            w = [],\n            z = this.index,\n            x = h.stacking.stacks[this.stackKey],\n            m = e.threshold,\n            k = Math.round(h.getThreshold(e.threshold));\n        e = t(e.connectNulls, \"percent\" === f);\n\n        var a = function (a, c, d) {\n          var e = b[a];\n          a = f && x[e.x].points[z];\n          var g = e[d + \"Null\"] || 0;\n          d = e[d + \"Cliff\"] || 0;\n          e = !0;\n\n          if (d || g) {\n            var p = (g ? a[0] : a[1]) + d;\n            var n = a[0] + d;\n            e = !!g;\n          } else !f && b[c] && b[c].isNull && (p = n = m);\n\n          \"undefined\" !== typeof p && (w.push({\n            plotX: A,\n            plotY: null === p ? k : h.getThreshold(p),\n            isNull: e,\n            isCliff: !0\n          }), l.push({\n            plotX: A,\n            plotY: null === n ? k : h.getThreshold(n),\n            doCurve: !1\n          }));\n        };\n\n        b = b || this.points;\n        f && (b = this.getStackPoints(b));\n\n        for (var g = 0, c = b.length; g < c; ++g) {\n          f || (b[g].leftCliff = b[g].rightCliff = b[g].leftNull = b[g].rightNull = void 0);\n          var D = b[g].isNull;\n          var A = t(b[g].rectPlotX, b[g].plotX);\n          var u = f ? t(b[g].yBottom, k) : k;\n          if (!D || e) e || a(g, g - 1, \"left\"), D && !f && e || (w.push(b[g]), l.push({\n            x: g,\n            plotX: A,\n            plotY: u\n          })), e || a(g, g + 1, \"right\");\n        }\n\n        a = d.call(this, w, !0, !0);\n        l.reversed = !0;\n        D = d.call(this, l, !0, !0);\n        (u = D[0]) && \"M\" === u[0] && (D[0] = [\"L\", u[1], u[2]]);\n        D = a.concat(D);\n        D.length && D.push([\"Z\"]);\n        d = d.call(this, w, !1, e);\n        D.xMap = a.xMap;\n        this.areaPath = D;\n        return d;\n      };\n\n      d.prototype.getStackPoints = function (b) {\n        var d = this,\n            e = [],\n            f = [],\n            h = this.xAxis,\n            l = this.yAxis,\n            w = l.stacking.stacks[this.stackKey],\n            z = {},\n            x = l.series,\n            m = x.length,\n            k = l.options.reversedStacks ? 1 : -1,\n            a = x.indexOf(d);\n        b = b || this.points;\n\n        if (this.options.stacking) {\n          for (var g = 0; g < b.length; g++) b[g].leftNull = b[g].rightNull = void 0, z[b[g].x] = b[g];\n\n          y(w, function (a, c) {\n            null !== a.total && f.push(c);\n          });\n          f.sort(function (a, c) {\n            return a - c;\n          });\n          var c = x.map(function (a) {\n            return a.visible;\n          });\n          f.forEach(function (b, g) {\n            var p = 0,\n                n,\n                q;\n            if (z[b] && !z[b].isNull) e.push(z[b]), [-1, 1].forEach(function (e) {\n              var h = 1 === e ? \"rightNull\" : \"leftNull\",\n                  p = w[f[g + e]],\n                  l = 0;\n              if (p) for (var r = a; 0 <= r && r < m;) {\n                var u = x[r].index;\n                n = p.points[u];\n                n || (u === d.index ? z[b][h] = !0 : c[r] && (q = w[b].points[u]) && (l -= q[1] - q[0]));\n                r += k;\n              }\n              z[b][1 === e ? \"rightCliff\" : \"leftCliff\"] = l;\n            });else {\n              for (var r = a; 0 <= r && r < m;) {\n                if (n = w[b].points[x[r].index]) {\n                  p = n[1];\n                  break;\n                }\n\n                r += k;\n              }\n\n              p = t(p, 0);\n              p = l.translate(p, 0, 1, 0, 1);\n              e.push({\n                isNull: !0,\n                plotX: h.translate(b, 0, 0, 0, 1),\n                x: b,\n                plotY: p,\n                yBottom: p\n              });\n            }\n          });\n        }\n\n        return e;\n      };\n\n      d.defaultOptions = B(G.defaultOptions, {\n        threshold: 0\n      });\n      return d;\n    }(G);\n\n    f(C.prototype, {\n      singleStacks: !1,\n      drawLegendSymbol: e.drawRectangle\n    });\n    l.registerSeriesType(\"area\", C);\n    \"\";\n    return C;\n  });\n  K(l, \"Series/Spline/SplineSeries.js\", [l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    var l = this && this.__extends || function () {\n      var e = function (f, l) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (e, f) {\n          e.__proto__ = f;\n        } || function (e, f) {\n          for (var d in f) f.hasOwnProperty(d) && (e[d] = f[d]);\n        };\n\n        return e(f, l);\n      };\n\n      return function (f, l) {\n        function t() {\n          this.constructor = f;\n        }\n\n        e(f, l);\n        f.prototype = null === l ? Object.create(l) : (t.prototype = l.prototype, new t());\n      };\n    }(),\n        C = f.seriesTypes.line,\n        v = e.merge,\n        E = e.pick;\n\n    e = function (e) {\n      function f() {\n        var f = null !== e && e.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      l(f, e);\n\n      f.prototype.getPointSpline = function (e, f, h) {\n        var d = f.plotX || 0,\n            b = f.plotY || 0,\n            p = e[h - 1];\n        h = e[h + 1];\n\n        if (p && !p.isNull && !1 !== p.doCurve && !f.isCliff && h && !h.isNull && !1 !== h.doCurve && !f.isCliff) {\n          e = p.plotY || 0;\n          var l = h.plotX || 0;\n          h = h.plotY || 0;\n          var r = 0;\n          var n = (1.5 * d + (p.plotX || 0)) / 2.5;\n          var t = (1.5 * b + e) / 2.5;\n          l = (1.5 * d + l) / 2.5;\n          var w = (1.5 * b + h) / 2.5;\n          l !== n && (r = (w - t) * (l - d) / (l - n) + b - w);\n          t += r;\n          w += r;\n          t > e && t > b ? (t = Math.max(e, b), w = 2 * b - t) : t < e && t < b && (t = Math.min(e, b), w = 2 * b - t);\n          w > h && w > b ? (w = Math.max(h, b), t = 2 * b - w) : w < h && w < b && (w = Math.min(h, b), t = 2 * b - w);\n          f.rightContX = l;\n          f.rightContY = w;\n        }\n\n        f = [\"C\", E(p.rightContX, p.plotX, 0), E(p.rightContY, p.plotY, 0), E(n, d, 0), E(t, b, 0), d, b];\n        p.rightContX = p.rightContY = void 0;\n        return f;\n      };\n\n      f.defaultOptions = v(C.defaultOptions);\n      return f;\n    }(C);\n\n    f.registerSeriesType(\"spline\", e);\n    \"\";\n    return e;\n  });\n  K(l, \"Series/AreaSpline/AreaSplineSeries.js\", [l[\"Series/Spline/SplineSeries.js\"], l[\"Core/Legend/LegendSymbol.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C) {\n    var v = this && this.__extends || function () {\n      var e = function (f, d) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var e in d) d.hasOwnProperty(e) && (b[e] = d[e]);\n        };\n\n        return e(f, d);\n      };\n\n      return function (f, d) {\n        function b() {\n          this.constructor = f;\n        }\n\n        e(f, d);\n        f.prototype = null === d ? Object.create(d) : (b.prototype = d.prototype, new b());\n      };\n    }(),\n        E = l.seriesTypes,\n        G = E.area;\n\n    E = E.area.prototype;\n    var B = C.extend,\n        y = C.merge;\n\n    C = function (e) {\n      function h() {\n        var d = null !== e && e.apply(this, arguments) || this;\n        d.data = void 0;\n        d.points = void 0;\n        d.options = void 0;\n        return d;\n      }\n\n      v(h, e);\n      h.defaultOptions = y(f.defaultOptions, G.defaultOptions);\n      return h;\n    }(f);\n\n    B(C.prototype, {\n      getGraphPath: E.getGraphPath,\n      getStackPoints: E.getStackPoints,\n      drawGraph: E.drawGraph,\n      drawLegendSymbol: e.drawRectangle\n    });\n    l.registerSeriesType(\"areaspline\", C);\n    \"\";\n    return C;\n  });\n  K(l, \"Series/Column/ColumnSeries.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/Color/Color.js\"], l[\"Core/Globals.js\"], l[\"Core/Legend/LegendSymbol.js\"], l[\"Core/Series/Series.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E, G) {\n    var B = this && this.__extends || function () {\n      var b = function (d, a) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (a, c) {\n          a.__proto__ = c;\n        } || function (a, c) {\n          for (var b in c) c.hasOwnProperty(b) && (a[b] = c[b]);\n        };\n\n        return b(d, a);\n      };\n\n      return function (d, a) {\n        function e() {\n          this.constructor = d;\n        }\n\n        b(d, a);\n        d.prototype = null === a ? Object.create(a) : (e.prototype = a.prototype, new e());\n      };\n    }(),\n        y = f.animObject,\n        t = e.parse,\n        h = l.hasTouch;\n\n    f = l.noop;\n    var d = G.clamp,\n        b = G.css,\n        p = G.defined,\n        q = G.extend,\n        r = G.fireEvent,\n        n = G.isArray,\n        J = G.isNumber,\n        w = G.merge,\n        z = G.pick,\n        x = G.objectEach;\n\n    G = function (e) {\n      function f() {\n        var a = null !== e && e.apply(this, arguments) || this;\n        a.borderWidth = void 0;\n        a.data = void 0;\n        a.group = void 0;\n        a.options = void 0;\n        a.points = void 0;\n        return a;\n      }\n\n      B(f, e);\n\n      f.prototype.animate = function (a) {\n        var b = this,\n            c = this.yAxis,\n            e = b.options,\n            f = this.chart.inverted,\n            k = {},\n            h = f ? \"translateX\" : \"translateY\";\n        if (a) k.scaleY = .001, a = d(c.toPixels(e.threshold), c.pos, c.pos + c.len), f ? k.translateX = a - c.len : k.translateY = a, b.clipBox && b.setClip(), b.group.attr(k);else {\n          var m = Number(b.group.attr(h));\n          b.group.animate({\n            scaleY: 1\n          }, q(y(b.options.animation), {\n            step: function (a, d) {\n              b.group && (k[h] = m + d.pos * (c.pos - m), b.group.attr(k));\n            }\n          }));\n        }\n      };\n\n      f.prototype.init = function (a, b) {\n        e.prototype.init.apply(this, arguments);\n        var c = this;\n        a = c.chart;\n        a.hasRendered && a.series.forEach(function (a) {\n          a.type === c.type && (a.isDirty = !0);\n        });\n      };\n\n      f.prototype.getColumnMetrics = function () {\n        var a = this,\n            b = a.options,\n            c = a.xAxis,\n            d = a.yAxis,\n            e = c.options.reversedStacks;\n        e = c.reversed && !e || !c.reversed && e;\n        var f = {},\n            k,\n            h = 0;\n        !1 === b.grouping ? h = 1 : a.chart.series.forEach(function (b) {\n          var c = b.yAxis,\n              e = b.options;\n\n          if (b.type === a.type && (b.visible || !a.chart.options.chart.ignoreHiddenSeries) && d.len === c.len && d.pos === c.pos) {\n            if (e.stacking && \"group\" !== e.stacking) {\n              k = b.stackKey;\n              \"undefined\" === typeof f[k] && (f[k] = h++);\n              var g = f[k];\n            } else !1 !== e.grouping && (g = h++);\n\n            b.columnIndex = g;\n          }\n        });\n        var m = Math.min(Math.abs(c.transA) * (c.ordinal && c.ordinal.slope || b.pointRange || c.closestPointRange || c.tickInterval || 1), c.len),\n            l = m * b.groupPadding,\n            p = (m - 2 * l) / (h || 1);\n        b = Math.min(b.maxPointWidth || c.len, z(b.pointWidth, p * (1 - 2 * b.pointPadding)));\n        a.columnMetrics = {\n          width: b,\n          offset: (p - b) / 2 + (l + ((a.columnIndex || 0) + (e ? 1 : 0)) * p - m / 2) * (e ? -1 : 1),\n          paddedWidth: p,\n          columnCount: h\n        };\n        return a.columnMetrics;\n      };\n\n      f.prototype.crispCol = function (a, b, c, d) {\n        var e = this.chart,\n            g = this.borderWidth,\n            f = -(g % 2 ? .5 : 0);\n        g = g % 2 ? .5 : 1;\n        e.inverted && e.renderer.isVML && (g += 1);\n        this.options.crisp && (c = Math.round(a + c) + f, a = Math.round(a) + f, c -= a);\n        d = Math.round(b + d) + g;\n        f = .5 >= Math.abs(b) && .5 < d;\n        b = Math.round(b) + g;\n        d -= b;\n        f && d && (--b, d += 1);\n        return {\n          x: a,\n          y: b,\n          width: c,\n          height: d\n        };\n      };\n\n      f.prototype.adjustForMissingColumns = function (a, b, c, d) {\n        var e = this,\n            g = this.options.stacking;\n\n        if (!c.isNull && 1 < d.columnCount) {\n          var f = this.yAxis.options.reversedStacks,\n              k = 0,\n              h = f ? 0 : -d.columnCount;\n          x(this.yAxis.stacking && this.yAxis.stacking.stacks, function (a) {\n            if (\"number\" === typeof c.x && (a = a[c.x.toString()])) {\n              var b = a.points[e.index],\n                  d = a.total;\n              g ? (b && (k = h), a.hasValidPoints && (f ? h++ : h--)) : n(b) && (k = b[1], h = d || 0);\n            }\n          });\n          a = (c.plotX || 0) + ((h - 1) * d.paddedWidth + b) / 2 - b - k * d.paddedWidth;\n        }\n\n        return a;\n      };\n\n      f.prototype.translate = function () {\n        var a = this,\n            b = a.chart,\n            c = a.options,\n            e = a.dense = 2 > a.closestPointRange * a.xAxis.transA;\n        e = a.borderWidth = z(c.borderWidth, e ? 0 : 1);\n        var f = a.xAxis,\n            k = a.yAxis,\n            h = c.threshold,\n            m = a.translatedThreshold = k.getThreshold(h),\n            l = z(c.minPointLength, 5),\n            n = a.getColumnMetrics(),\n            q = n.width,\n            r = a.pointXOffset = n.offset,\n            t = a.dataMin,\n            x = a.dataMax,\n            w = a.barW = Math.max(q, 1 + 2 * e);\n        b.inverted && (m -= .5);\n        c.pointPadding && (w = Math.ceil(w));\n        v.prototype.translate.apply(a);\n        a.points.forEach(function (e) {\n          var g = z(e.yBottom, m),\n              u = 999 + Math.abs(g),\n              A = e.plotX || 0;\n          u = d(e.plotY, -u, k.len + u);\n          var v = Math.min(u, g),\n              y = Math.max(u, g) - v,\n              D = q,\n              B = A + r,\n              C = w;\n          l && Math.abs(y) < l && (y = l, A = !k.reversed && !e.negative || k.reversed && e.negative, J(h) && J(x) && e.y === h && x <= h && (k.min || 0) < h && (t !== x || (k.max || 0) <= h) && (A = !A), v = Math.abs(v - m) > l ? g - l : m - (A ? l : 0));\n          p(e.options.pointWidth) && (D = C = Math.ceil(e.options.pointWidth), B -= Math.round((D - q) / 2));\n          c.centerInCategory && (B = a.adjustForMissingColumns(B, D, e, n));\n          e.barX = B;\n          e.pointWidth = D;\n          e.tooltipPos = b.inverted ? [d(k.len + k.pos - b.plotLeft - u, k.pos - b.plotLeft, k.len + k.pos - b.plotLeft), f.len + f.pos - b.plotTop - B - C / 2, y] : [f.left - b.plotLeft + B + C / 2, d(u + k.pos - b.plotTop, k.pos - b.plotTop, k.len + k.pos - b.plotTop), y];\n          e.shapeType = a.pointClass.prototype.shapeType || \"rect\";\n          e.shapeArgs = a.crispCol.apply(a, e.isNull ? [B, m, C, 0] : [B, v, C, y]);\n        });\n      };\n\n      f.prototype.drawGraph = function () {\n        this.group[this.dense ? \"addClass\" : \"removeClass\"](\"highcharts-dense-data\");\n      };\n\n      f.prototype.pointAttribs = function (a, b) {\n        var c = this.options,\n            d = this.pointAttrToOptions || {},\n            e = d.stroke || \"borderColor\",\n            g = d[\"stroke-width\"] || \"borderWidth\",\n            f = a && a.color || this.color,\n            k = a && a[e] || c[e] || f;\n        d = a && a.options.dashStyle || c.dashStyle;\n        var h = a && a[g] || c[g] || this[g] || 0,\n            m = z(a && a.opacity, c.opacity, 1);\n\n        if (a && this.zones.length) {\n          var l = a.getZone();\n          f = a.options.color || l && (l.color || a.nonZonedColor) || this.color;\n          l && (k = l.borderColor || k, d = l.dashStyle || d, h = l.borderWidth || h);\n        }\n\n        b && a && (a = w(c.states[b], a.options.states && a.options.states[b] || {}), b = a.brightness, f = a.color || \"undefined\" !== typeof b && t(f).brighten(a.brightness).get() || f, k = a[e] || k, h = a[g] || h, d = a.dashStyle || d, m = z(a.opacity, m));\n        e = {\n          fill: f,\n          stroke: k,\n          \"stroke-width\": h,\n          opacity: m\n        };\n        d && (e.dashstyle = d);\n        return e;\n      };\n\n      f.prototype.drawPoints = function () {\n        var a = this,\n            b = this.chart,\n            c = a.options,\n            d = b.renderer,\n            e = c.animationLimit || 250,\n            f;\n        a.points.forEach(function (g) {\n          var k = g.graphic,\n              h = !!k,\n              m = k && b.pointCount < e ? \"animate\" : \"attr\";\n\n          if (J(g.plotY) && null !== g.y) {\n            f = g.shapeArgs;\n            k && g.hasNewShapeType() && (k = k.destroy());\n            a.enabledDataSorting && (g.startXPos = a.xAxis.reversed ? -(f ? f.width || 0 : 0) : a.xAxis.width);\n            k || (g.graphic = k = d[g.shapeType](f).add(g.group || a.group)) && a.enabledDataSorting && b.hasRendered && b.pointCount < e && (k.attr({\n              x: g.startXPos\n            }), h = !0, m = \"animate\");\n            if (k && h) k[m](w(f));\n            if (c.borderRadius) k[m]({\n              r: c.borderRadius\n            });\n            b.styledMode || k[m](a.pointAttribs(g, g.selected && \"select\")).shadow(!1 !== g.allowShadow && c.shadow, null, c.stacking && !c.borderRadius);\n            k && (k.addClass(g.getClassName(), !0), k.attr({\n              visibility: g.visible ? \"inherit\" : \"hidden\"\n            }));\n          } else k && (g.graphic = k.destroy());\n        });\n      };\n\n      f.prototype.drawTracker = function () {\n        var a = this,\n            d = a.chart,\n            c = d.pointer,\n            e = function (a) {\n          var b = c.getPointFromEvent(a);\n          \"undefined\" !== typeof b && (c.isDirectTouch = !0, b.onMouseOver(a));\n        },\n            f;\n\n        a.points.forEach(function (a) {\n          f = n(a.dataLabels) ? a.dataLabels : a.dataLabel ? [a.dataLabel] : [];\n          a.graphic && (a.graphic.element.point = a);\n          f.forEach(function (b) {\n            b.div ? b.div.point = a : b.element.point = a;\n          });\n        });\n        a._hasTracking || (a.trackerGroups.forEach(function (g) {\n          if (a[g]) {\n            a[g].addClass(\"highcharts-tracker\").on(\"mouseover\", e).on(\"mouseout\", function (a) {\n              c.onTrackerMouseOut(a);\n            });\n            if (h) a[g].on(\"touchstart\", e);\n            !d.styledMode && a.options.cursor && a[g].css(b).css({\n              cursor: a.options.cursor\n            });\n          }\n        }), a._hasTracking = !0);\n        r(this, \"afterDrawTracker\");\n      };\n\n      f.prototype.remove = function () {\n        var a = this,\n            b = a.chart;\n        b.hasRendered && b.series.forEach(function (b) {\n          b.type === a.type && (b.isDirty = !0);\n        });\n        v.prototype.remove.apply(a, arguments);\n      };\n\n      f.defaultOptions = w(v.defaultOptions, {\n        borderRadius: 0,\n        centerInCategory: !1,\n        groupPadding: .2,\n        marker: null,\n        pointPadding: .1,\n        minPointLength: 0,\n        cropThreshold: 50,\n        pointRange: null,\n        states: {\n          hover: {\n            halo: !1,\n            brightness: .1\n          },\n          select: {\n            color: \"#cccccc\",\n            borderColor: \"#000000\"\n          }\n        },\n        dataLabels: {\n          align: void 0,\n          verticalAlign: void 0,\n          y: void 0\n        },\n        startFromThreshold: !0,\n        stickyTracking: !1,\n        tooltip: {\n          distance: 6\n        },\n        threshold: 0,\n        borderColor: \"#ffffff\"\n      });\n      return f;\n    }(v);\n\n    q(G.prototype, {\n      cropShoulder: 0,\n      directTouch: !0,\n      drawLegendSymbol: C.drawRectangle,\n      getSymbol: f,\n      negStacks: !0,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    E.registerSeriesType(\"column\", G);\n    \"\";\n    \"\";\n    return G;\n  });\n  K(l, \"Core/Series/DataLabel.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/FormatUtilities.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = f.getDeferredAnimation,\n        v = e.format,\n        E = l.defined,\n        G = l.extend,\n        B = l.fireEvent,\n        y = l.isArray,\n        t = l.merge,\n        h = l.objectEach,\n        d = l.pick,\n        b = l.splat,\n        p;\n\n    (function (e) {\n      function f(b, a, e, c, f) {\n        var g = this,\n            k = this.chart,\n            h = this.isCartesian && k.inverted,\n            m = this.enabledDataSorting,\n            l = d(b.dlBox && b.dlBox.centerX, b.plotX),\n            p = b.plotY,\n            n = e.rotation,\n            q = e.align,\n            r = E(l) && E(p) && k.isInsidePlot(l, Math.round(p), {\n          inverted: h,\n          paneCoordinates: !0,\n          series: g\n        }),\n            t = function (c) {\n          m && g.xAxis && !x && g.setDataLabelStartPos(b, a, f, r, c);\n        },\n            x = \"justify\" === d(e.overflow, m ? \"none\" : \"justify\"),\n            z = this.visible && !1 !== b.visible && (b.series.forceDL || m && !x || r || d(e.inside, !!this.options.stacking) && c && k.isInsidePlot(l, h ? c.x + 1 : c.y + c.height - 1, {\n          inverted: h,\n          paneCoordinates: !0,\n          series: g\n        }));\n\n        if (z && E(l) && E(p)) {\n          n && a.attr({\n            align: q\n          });\n          q = a.getBBox(!0);\n          var w = [0, 0];\n          var v = k.renderer.fontMetrics(k.styledMode ? void 0 : e.style.fontSize, a).b;\n          c = G({\n            x: h ? this.yAxis.len - p : l,\n            y: Math.round(h ? this.xAxis.len - l : p),\n            width: 0,\n            height: 0\n          }, c);\n          G(e, {\n            width: q.width,\n            height: q.height\n          });\n          n ? (x = !1, w = k.renderer.rotCorr(v, n), l = {\n            x: c.x + (e.x || 0) + c.width / 2 + w.x,\n            y: c.y + (e.y || 0) + {\n              top: 0,\n              middle: .5,\n              bottom: 1\n            }[e.verticalAlign] * c.height\n          }, w = [q.x - Number(a.attr(\"x\")), q.y - Number(a.attr(\"y\"))], t(l), a[f ? \"attr\" : \"animate\"](l)) : (t(c), a.align(e, void 0, c), l = a.alignAttr);\n          x && 0 <= c.height ? this.justifyDataLabel(a, e, l, q, c, f) : d(e.crop, !0) && (c = l.x, t = l.y, c += w[0], t += w[1], z = k.isInsidePlot(c, t, {\n            paneCoordinates: !0,\n            series: g\n          }) && k.isInsidePlot(c + q.width, t + q.height, {\n            paneCoordinates: !0,\n            series: g\n          }));\n          if (e.shape && !n) a[f ? \"attr\" : \"animate\"]({\n            anchorX: h ? k.plotWidth - b.plotY : b.plotX,\n            anchorY: h ? k.plotHeight - b.plotX : b.plotY\n          });\n        }\n\n        f && m && (a.placed = !1);\n        z || m && !x ? a.show() : (a.hide(), a.placed = !1);\n      }\n\n      function l(b, a) {\n        var d = a.filter;\n        return d ? (a = d.operator, b = b[d.property], d = d.value, \">\" === a && b > d || \"<\" === a && b < d || \">=\" === a && b >= d || \"<=\" === a && b <= d || \"==\" === a && b == d || \"===\" === a && b === d ? !0 : !1) : !0;\n      }\n\n      function p() {\n        var e = this,\n            a = e.chart,\n            g = e.options,\n            c = e.points,\n            f = e.hasRendered || 0,\n            m = a.renderer,\n            p = g.dataLabels,\n            n,\n            q = p.animation;\n        q = p.defer ? C(a, q, e) : {\n          defer: 0,\n          duration: 0\n        };\n        p = z(z(a.options.plotOptions && a.options.plotOptions.series && a.options.plotOptions.series.dataLabels, a.options.plotOptions && a.options.plotOptions[e.type] && a.options.plotOptions[e.type].dataLabels), p);\n        B(this, \"drawDataLabels\");\n\n        if (y(p) || p.enabled || e._hasPointLabels) {\n          var r = e.plotGroup(\"dataLabelsGroup\", \"data-labels\", f ? \"inherit\" : \"hidden\", p.zIndex || 6);\n          r.attr({\n            opacity: +f\n          });\n          !f && (f = e.dataLabelsGroup) && (e.visible && r.show(), f[g.animation ? \"animate\" : \"attr\"]({\n            opacity: 1\n          }, q));\n          c.forEach(function (c) {\n            n = b(z(p, c.dlOptions || c.options && c.options.dataLabels));\n            n.forEach(function (b, f) {\n              var k = b.enabled && (!c.isNull || c.dataLabelOnNull) && l(c, b),\n                  p = c.connectors ? c.connectors[f] : c.connector,\n                  n = c.dataLabels ? c.dataLabels[f] : c.dataLabel,\n                  q = !n,\n                  t = d(b.distance, c.labelDistance);\n\n              if (k) {\n                var u = c.getLabelConfig();\n                var x = d(b[c.formatPrefix + \"Format\"], b.format);\n                u = E(x) ? v(x, u, a) : (b[c.formatPrefix + \"Formatter\"] || b.formatter).call(u, b);\n                x = b.style;\n                var z = b.rotation;\n                a.styledMode || (x.color = d(b.color, x.color, e.color, \"#000000\"), \"contrast\" === x.color ? (c.contrastColor = m.getContrast(c.color || e.color), x.color = !E(t) && b.inside || 0 > t || g.stacking ? c.contrastColor : \"#000000\") : delete c.contrastColor, g.cursor && (x.cursor = g.cursor));\n                var w = {\n                  r: b.borderRadius || 0,\n                  rotation: z,\n                  padding: b.padding,\n                  zIndex: 1\n                };\n                a.styledMode || (w.fill = b.backgroundColor, w.stroke = b.borderColor, w[\"stroke-width\"] = b.borderWidth);\n                h(w, function (a, b) {\n                  \"undefined\" === typeof a && delete w[b];\n                });\n              }\n\n              !n || k && E(u) && !!n.div === !!b.useHTML && (n.rotation && b.rotation || n.rotation === b.rotation) || (q = !0, c.dataLabel = n = c.dataLabel && c.dataLabel.destroy(), c.dataLabels && (1 === c.dataLabels.length ? delete c.dataLabels : delete c.dataLabels[f]), f || delete c.dataLabel, p && (c.connector = c.connector.destroy(), c.connectors && (1 === c.connectors.length ? delete c.connectors : delete c.connectors[f])));\n              k && E(u) ? (n ? w.text = u : (c.dataLabels = c.dataLabels || [], n = c.dataLabels[f] = z ? m.text(u, 0, 0, b.useHTML).addClass(\"highcharts-data-label\") : m.label(u, 0, 0, b.shape, null, null, b.useHTML, null, \"data-label\"), f || (c.dataLabel = n), n.addClass(\" highcharts-data-label-color-\" + c.colorIndex + \" \" + (b.className || \"\") + (b.useHTML ? \" highcharts-tracker\" : \"\"))), n.options = b, n.attr(w), a.styledMode || n.css(x).shadow(b.shadow), n.added || n.add(r), b.textPath && !b.useHTML && (n.setTextPath(c.getDataLabelPath && c.getDataLabelPath(n) || c.graphic, b.textPath), c.dataLabelPath && !b.textPath.enabled && (c.dataLabelPath = c.dataLabelPath.destroy())), e.alignDataLabel(c, n, b, null, q)) : n && n.hide();\n            });\n          });\n        }\n\n        B(this, \"afterDrawDataLabels\");\n      }\n\n      function q(b, a, d, c, e, f) {\n        var g = this.chart,\n            k = a.align,\n            h = a.verticalAlign,\n            m = b.box ? 0 : b.padding || 0,\n            l = a.x;\n        l = void 0 === l ? 0 : l;\n        var n = a.y;\n        n = void 0 === n ? 0 : n;\n        var p = (d.x || 0) + m;\n\n        if (0 > p) {\n          \"right\" === k && 0 <= l ? (a.align = \"left\", a.inside = !0) : l -= p;\n          var q = !0;\n        }\n\n        p = (d.x || 0) + c.width - m;\n        p > g.plotWidth && (\"left\" === k && 0 >= l ? (a.align = \"right\", a.inside = !0) : l += g.plotWidth - p, q = !0);\n        p = d.y + m;\n        0 > p && (\"bottom\" === h && 0 <= n ? (a.verticalAlign = \"top\", a.inside = !0) : n -= p, q = !0);\n        p = (d.y || 0) + c.height - m;\n        p > g.plotHeight && (\"top\" === h && 0 >= n ? (a.verticalAlign = \"bottom\", a.inside = !0) : n += g.plotHeight - p, q = !0);\n        q && (a.x = l, a.y = n, b.placed = !f, b.align(a, void 0, e));\n        return q;\n      }\n\n      function z(b, a) {\n        var d = [],\n            c;\n        if (y(b) && !y(a)) d = b.map(function (b) {\n          return t(b, a);\n        });else if (y(a) && !y(b)) d = a.map(function (a) {\n          return t(b, a);\n        });else if (y(b) || y(a)) for (c = Math.max(b.length, a.length); c--;) d[c] = t(b[c], a[c]);else d = t(b, a);\n        return d;\n      }\n\n      function x(b, a, d, c, e) {\n        var g = this.chart,\n            f = g.inverted,\n            h = this.xAxis,\n            k = h.reversed,\n            m = f ? a.height / 2 : a.width / 2;\n        b = (b = b.pointWidth) ? b / 2 : 0;\n        a.startXPos = f ? e.x : k ? -m - b : h.width - m + b;\n        a.startYPos = f ? k ? this.yAxis.height - m + b : -m - b : e.y;\n        c ? \"hidden\" === a.visibility && (a.show(), a.attr({\n          opacity: 0\n        }).animate({\n          opacity: 1\n        })) : a.attr({\n          opacity: 1\n        }).animate({\n          opacity: 0\n        }, void 0, a.hide);\n        g.hasRendered && (d && a.attr({\n          x: a.startXPos,\n          y: a.startYPos\n        }), a.placed = !0);\n      }\n\n      var m = [];\n\n      e.compose = function (b) {\n        if (-1 === m.indexOf(b)) {\n          var a = b.prototype;\n          m.push(b);\n          a.alignDataLabel = f;\n          a.drawDataLabels = p;\n          a.justifyDataLabel = q;\n          a.setDataLabelStartPos = x;\n        }\n      };\n    })(p || (p = {}));\n\n    \"\";\n    return p;\n  });\n  K(l, \"Series/Column/ColumnDataLabel.js\", [l[\"Core/Series/DataLabel.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = e.series,\n        v = l.merge,\n        E = l.pick,\n        G;\n\n    (function (e) {\n      function l(e, d, b, f, l) {\n        var h = this.chart.inverted,\n            n = e.series,\n            p = (n.xAxis ? n.xAxis.len : this.chart.plotSizeX) || 0;\n        n = (n.yAxis ? n.yAxis.len : this.chart.plotSizeY) || 0;\n        var q = e.dlBox || e.shapeArgs,\n            t = E(e.below, e.plotY > E(this.translatedThreshold, n)),\n            x = E(b.inside, !!this.options.stacking);\n        q && (f = v(q), 0 > f.y && (f.height += f.y, f.y = 0), q = f.y + f.height - n, 0 < q && q < f.height && (f.height -= q), h && (f = {\n          x: n - f.y - f.height,\n          y: p - f.x - f.width,\n          width: f.height,\n          height: f.width\n        }), x || (h ? (f.x += t ? 0 : f.width, f.width = 0) : (f.y += t ? f.height : 0, f.height = 0)));\n        b.align = E(b.align, !h || x ? \"center\" : t ? \"right\" : \"left\");\n        b.verticalAlign = E(b.verticalAlign, h || x ? \"middle\" : t ? \"top\" : \"bottom\");\n        C.prototype.alignDataLabel.call(this, e, d, b, f, l);\n        b.inside && e.contrastColor && d.css({\n          color: e.contrastColor\n        });\n      }\n\n      var t = [];\n\n      e.compose = function (e) {\n        f.compose(C);\n        -1 === t.indexOf(e) && (t.push(e), e.prototype.alignDataLabel = l);\n      };\n    })(G || (G = {}));\n\n    return G;\n  });\n  K(l, \"Series/Bar/BarSeries.js\", [l[\"Series/Column/ColumnSeries.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = this && this.__extends || function () {\n      var e = function (f, l) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (e, f) {\n          e.__proto__ = f;\n        } || function (e, f) {\n          for (var d in f) f.hasOwnProperty(d) && (e[d] = f[d]);\n        };\n\n        return e(f, l);\n      };\n\n      return function (f, l) {\n        function t() {\n          this.constructor = f;\n        }\n\n        e(f, l);\n        f.prototype = null === l ? Object.create(l) : (t.prototype = l.prototype, new t());\n      };\n    }(),\n        v = l.extend,\n        E = l.merge;\n\n    l = function (e) {\n      function l() {\n        var f = null !== e && e.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      C(l, e);\n      l.defaultOptions = E(f.defaultOptions, {});\n      return l;\n    }(f);\n\n    v(l.prototype, {\n      inverted: !0\n    });\n    e.registerSeriesType(\"bar\", l);\n    \"\";\n    return l;\n  });\n  K(l, \"Series/Scatter/ScatterSeries.js\", [l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    var l = this && this.__extends || function () {\n      var e = function (f, h) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (d, b) {\n          d.__proto__ = b;\n        } || function (d, b) {\n          for (var e in b) b.hasOwnProperty(e) && (d[e] = b[e]);\n        };\n\n        return e(f, h);\n      };\n\n      return function (f, h) {\n        function d() {\n          this.constructor = f;\n        }\n\n        e(f, h);\n        f.prototype = null === h ? Object.create(h) : (d.prototype = h.prototype, new d());\n      };\n    }(),\n        C = f.seriesTypes,\n        v = C.column,\n        E = C.line;\n\n    C = e.addEvent;\n    var G = e.extend,\n        B = e.merge;\n\n    e = function (e) {\n      function f() {\n        var f = null !== e && e.apply(this, arguments) || this;\n        f.data = void 0;\n        f.options = void 0;\n        f.points = void 0;\n        return f;\n      }\n\n      l(f, e);\n\n      f.prototype.applyJitter = function () {\n        var e = this,\n            d = this.options.jitter,\n            b = this.points.length;\n        d && this.points.forEach(function (f, h) {\n          [\"x\", \"y\"].forEach(function (l, n) {\n            var p = \"plot\" + l.toUpperCase();\n\n            if (d[l] && !f.isNull) {\n              var q = e[l + \"Axis\"];\n              var r = d[l] * q.transA;\n\n              if (q && !q.isLog) {\n                var t = Math.max(0, f[p] - r);\n                q = Math.min(q.len, f[p] + r);\n                n = 1E4 * Math.sin(h + n * b);\n                f[p] = t + (q - t) * (n - Math.floor(n));\n                \"x\" === l && (f.clientX = f.plotX);\n              }\n            }\n          });\n        });\n      };\n\n      f.prototype.drawGraph = function () {\n        this.options.lineWidth ? e.prototype.drawGraph.call(this) : this.graph && (this.graph = this.graph.destroy());\n      };\n\n      f.defaultOptions = B(E.defaultOptions, {\n        lineWidth: 0,\n        findNearestPointBy: \"xy\",\n        jitter: {\n          x: 0,\n          y: 0\n        },\n        marker: {\n          enabled: !0\n        },\n        tooltip: {\n          headerFormat: '<span style=\"color:{point.color}\">\\u25cf</span> <span style=\"font-size: 10px\"> {series.name}</span><br/>',\n          pointFormat: \"x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>\"\n        }\n      });\n      return f;\n    }(E);\n\n    G(e.prototype, {\n      drawTracker: v.prototype.drawTracker,\n      sorted: !1,\n      requireSorting: !1,\n      noSharedTooltip: !0,\n      trackerGroups: [\"group\", \"markerGroup\", \"dataLabelsGroup\"],\n      takeOrdinalPosition: !1\n    });\n    C(e, \"afterTranslate\", function () {\n      this.applyJitter();\n    });\n    f.registerSeriesType(\"scatter\", e);\n    \"\";\n    return e;\n  });\n  K(l, \"Series/CenteredUtilities.js\", [l[\"Core/Globals.js\"], l[\"Core/Series/Series.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = f.deg2rad,\n        v = l.fireEvent,\n        E = l.isNumber,\n        G = l.pick,\n        B = l.relativeLength,\n        y;\n\n    (function (f) {\n      f.getCenter = function () {\n        var f = this.options,\n            d = this.chart,\n            b = 2 * (f.slicedOffset || 0),\n            l = d.plotWidth - 2 * b,\n            q = d.plotHeight - 2 * b,\n            r = f.center,\n            n = Math.min(l, q),\n            t = f.thickness,\n            w = f.size,\n            z = f.innerSize || 0;\n        \"string\" === typeof w && (w = parseFloat(w));\n        \"string\" === typeof z && (z = parseFloat(z));\n        f = [G(r[0], \"50%\"), G(r[1], \"50%\"), G(w && 0 > w ? void 0 : f.size, \"100%\"), G(z && 0 > z ? void 0 : f.innerSize || 0, \"0%\")];\n        !d.angular || this instanceof e || (f[3] = 0);\n\n        for (r = 0; 4 > r; ++r) w = f[r], d = 2 > r || 2 === r && /%$/.test(w), f[r] = B(w, [l, q, n, f[2]][r]) + (d ? b : 0);\n\n        f[3] > f[2] && (f[3] = f[2]);\n        E(t) && 2 * t < f[2] && 0 < t && (f[3] = f[2] - 2 * t);\n        v(this, \"afterGetCenter\", {\n          positions: f\n        });\n        return f;\n      };\n\n      f.getStartAndEndRadians = function (e, d) {\n        e = E(e) ? e : 0;\n        d = E(d) && d > e && 360 > d - e ? d : e + 360;\n        return {\n          start: C * (e + -90),\n          end: C * (d + -90)\n        };\n      };\n    })(y || (y = {}));\n\n    \"\";\n    return y;\n  });\n  K(l, \"Series/Pie/PiePoint.js\", [l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/Series/Point.js\"], l[\"Core/Utilities.js\"]], function (f, e, l) {\n    var C = this && this.__extends || function () {\n      var e = function (d, b) {\n        e = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var e in d) d.hasOwnProperty(e) && (b[e] = d[e]);\n        };\n\n        return e(d, b);\n      };\n\n      return function (d, b) {\n        function f() {\n          this.constructor = d;\n        }\n\n        e(d, b);\n        d.prototype = null === b ? Object.create(b) : (f.prototype = b.prototype, new f());\n      };\n    }(),\n        v = f.setAnimation,\n        E = l.addEvent,\n        G = l.defined;\n\n    f = l.extend;\n    var B = l.isNumber,\n        y = l.pick,\n        t = l.relativeLength;\n\n    e = function (e) {\n      function d() {\n        var b = null !== e && e.apply(this, arguments) || this;\n        b.labelDistance = void 0;\n        b.options = void 0;\n        b.series = void 0;\n        return b;\n      }\n\n      C(d, e);\n\n      d.prototype.getConnectorPath = function () {\n        var b = this.labelPosition,\n            d = this.series.options.dataLabels,\n            e = this.connectorShapes,\n            f = d.connectorShape;\n        e[f] && (f = e[f]);\n        return f.call(this, {\n          x: b.final.x,\n          y: b.final.y,\n          alignment: b.alignment\n        }, b.connectorPosition, d);\n      };\n\n      d.prototype.getTranslate = function () {\n        return this.sliced ? this.slicedTranslation : {\n          translateX: 0,\n          translateY: 0\n        };\n      };\n\n      d.prototype.haloPath = function (b) {\n        var d = this.shapeArgs;\n        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(d.x, d.y, d.r + b, d.r + b, {\n          innerR: d.r - 1,\n          start: d.start,\n          end: d.end\n        });\n      };\n\n      d.prototype.init = function () {\n        var b = this;\n        e.prototype.init.apply(this, arguments);\n        this.name = y(this.name, \"Slice\");\n\n        var d = function (d) {\n          b.slice(\"select\" === d.type);\n        };\n\n        E(this, \"select\", d);\n        E(this, \"unselect\", d);\n        return this;\n      };\n\n      d.prototype.isValid = function () {\n        return B(this.y) && 0 <= this.y;\n      };\n\n      d.prototype.setVisible = function (b, d) {\n        var e = this,\n            f = this.series,\n            h = f.chart,\n            l = f.options.ignoreHiddenPoint;\n        d = y(d, l);\n        b !== this.visible && (this.visible = this.options.visible = b = \"undefined\" === typeof b ? !this.visible : b, f.options.data[f.data.indexOf(this)] = this.options, [\"graphic\", \"dataLabel\", \"connector\", \"shadowGroup\"].forEach(function (d) {\n          if (e[d]) e[d][b ? \"show\" : \"hide\"](b);\n        }), this.legendItem && h.legend.colorizeItem(this, b), b || \"hover\" !== this.state || this.setState(\"\"), l && (f.isDirty = !0), d && h.redraw());\n      };\n\n      d.prototype.slice = function (b, d, e) {\n        var f = this.series;\n        v(e, f.chart);\n        y(d, !0);\n        this.sliced = this.options.sliced = G(b) ? b : !this.sliced;\n        f.options.data[f.data.indexOf(this)] = this.options;\n        this.graphic && this.graphic.animate(this.getTranslate());\n        this.shadowGroup && this.shadowGroup.animate(this.getTranslate());\n      };\n\n      return d;\n    }(e);\n\n    f(e.prototype, {\n      connectorShapes: {\n        fixedOffset: function (e, d, b) {\n          var f = d.breakAt;\n          d = d.touchingSliceAt;\n          return [[\"M\", e.x, e.y], b.softConnector ? [\"C\", e.x + (\"left\" === e.alignment ? -5 : 5), e.y, 2 * f.x - d.x, 2 * f.y - d.y, f.x, f.y] : [\"L\", f.x, f.y], [\"L\", d.x, d.y]];\n        },\n        straight: function (e, d) {\n          d = d.touchingSliceAt;\n          return [[\"M\", e.x, e.y], [\"L\", d.x, d.y]];\n        },\n        crookedLine: function (e, d, b) {\n          d = d.touchingSliceAt;\n          var f = this.series,\n              h = f.center[0],\n              l = f.chart.plotWidth,\n              n = f.chart.plotLeft;\n          f = e.alignment;\n          var v = this.shapeArgs.r;\n          b = t(b.crookDistance, 1);\n          l = \"left\" === f ? h + v + (l + n - h - v) * (1 - b) : n + (h - v) * b;\n          b = [\"L\", l, e.y];\n          h = !0;\n          if (\"left\" === f ? l > e.x || l < d.x : l < e.x || l > d.x) h = !1;\n          e = [[\"M\", e.x, e.y]];\n          h && e.push(b);\n          e.push([\"L\", d.x, d.y]);\n          return e;\n        }\n      }\n    });\n    return e;\n  });\n  K(l, \"Series/Pie/PieSeries.js\", [l[\"Series/CenteredUtilities.js\"], l[\"Series/Column/ColumnSeries.js\"], l[\"Core/Globals.js\"], l[\"Core/Legend/LegendSymbol.js\"], l[\"Series/Pie/PiePoint.js\"], l[\"Core/Series/Series.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Renderer/SVG/Symbols.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v, E, G, B, y) {\n    var t = this && this.__extends || function () {\n      var b = function (d, e) {\n        b = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (b, d) {\n          b.__proto__ = d;\n        } || function (b, d) {\n          for (var e in d) d.hasOwnProperty(e) && (b[e] = d[e]);\n        };\n\n        return b(d, e);\n      };\n\n      return function (d, e) {\n        function f() {\n          this.constructor = d;\n        }\n\n        b(d, e);\n        d.prototype = null === e ? Object.create(e) : (f.prototype = e.prototype, new f());\n      };\n    }(),\n        h = f.getStartAndEndRadians;\n\n    l = l.noop;\n    var d = y.clamp,\n        b = y.extend,\n        p = y.fireEvent,\n        q = y.merge,\n        r = y.pick,\n        n = y.relativeLength;\n\n    y = function (b) {\n      function e() {\n        var d = null !== b && b.apply(this, arguments) || this;\n        d.center = void 0;\n        d.data = void 0;\n        d.maxLabelDistance = void 0;\n        d.options = void 0;\n        d.points = void 0;\n        return d;\n      }\n\n      t(e, b);\n\n      e.prototype.animate = function (b) {\n        var d = this,\n            e = d.points,\n            f = d.startAngleRad;\n        b || e.forEach(function (a) {\n          var b = a.graphic,\n              c = a.shapeArgs;\n          b && c && (b.attr({\n            r: r(a.startR, d.center && d.center[3] / 2),\n            start: f,\n            end: f\n          }), b.animate({\n            r: c.r,\n            start: c.start,\n            end: c.end\n          }, d.options.animation));\n        });\n      };\n\n      e.prototype.drawEmpty = function () {\n        var b = this.startAngleRad,\n            d = this.endAngleRad,\n            e = this.options;\n\n        if (0 === this.total && this.center) {\n          var f = this.center[0];\n          var a = this.center[1];\n          this.graph || (this.graph = this.chart.renderer.arc(f, a, this.center[1] / 2, 0, b, d).addClass(\"highcharts-empty-series\").add(this.group));\n          this.graph.attr({\n            d: B.arc(f, a, this.center[2] / 2, 0, {\n              start: b,\n              end: d,\n              innerR: this.center[3] / 2\n            })\n          });\n          this.chart.styledMode || this.graph.attr({\n            \"stroke-width\": e.borderWidth,\n            fill: e.fillColor || \"none\",\n            stroke: e.color || \"#cccccc\"\n          });\n        } else this.graph && (this.graph = this.graph.destroy());\n      };\n\n      e.prototype.drawPoints = function () {\n        var b = this.chart.renderer;\n        this.points.forEach(function (d) {\n          d.graphic && d.hasNewShapeType() && (d.graphic = d.graphic.destroy());\n          d.graphic || (d.graphic = b[d.shapeType](d.shapeArgs).add(d.series.group), d.delayedRendering = !0);\n        });\n      };\n\n      e.prototype.generatePoints = function () {\n        b.prototype.generatePoints.call(this);\n        this.updateTotals();\n      };\n\n      e.prototype.getX = function (b, e, f) {\n        var k = this.center,\n            a = this.radii ? this.radii[f.index] || 0 : k[2] / 2;\n        b = Math.asin(d((b - k[1]) / (a + f.labelDistance), -1, 1));\n        return k[0] + (e ? -1 : 1) * Math.cos(b) * (a + f.labelDistance) + (0 < f.labelDistance ? (e ? -1 : 1) * this.options.dataLabels.padding : 0);\n      };\n\n      e.prototype.hasData = function () {\n        return !!this.processedXData.length;\n      };\n\n      e.prototype.redrawPoints = function () {\n        var b = this,\n            d = b.chart,\n            e = d.renderer,\n            f = b.options.shadow,\n            a,\n            g,\n            c,\n            h;\n        this.drawEmpty();\n        !f || b.shadowGroup || d.styledMode || (b.shadowGroup = e.g(\"shadow\").attr({\n          zIndex: -1\n        }).add(b.group));\n        b.points.forEach(function (k) {\n          var l = {};\n          g = k.graphic;\n\n          if (!k.isNull && g) {\n            var m = void 0;\n            h = k.shapeArgs;\n            a = k.getTranslate();\n            d.styledMode || (m = k.shadowGroup, f && !m && (m = k.shadowGroup = e.g(\"shadow\").add(b.shadowGroup)), m && m.attr(a), c = b.pointAttribs(k, k.selected && \"select\"));\n            k.delayedRendering ? (g.setRadialReference(b.center).attr(h).attr(a), d.styledMode || g.attr(c).attr({\n              \"stroke-linejoin\": \"round\"\n            }).shadow(f, m), k.delayedRendering = !1) : (g.setRadialReference(b.center), d.styledMode || q(!0, l, c), q(!0, l, h, a), g.animate(l));\n            g.attr({\n              visibility: k.visible ? \"inherit\" : \"hidden\"\n            });\n            g.addClass(k.getClassName(), !0);\n          } else g && (k.graphic = g.destroy());\n        });\n      };\n\n      e.prototype.sortByAngle = function (b, d) {\n        b.sort(function (b, e) {\n          return \"undefined\" !== typeof b.angle && (e.angle - b.angle) * d;\n        });\n      };\n\n      e.prototype.translate = function (b) {\n        p(this, \"translate\");\n        this.generatePoints();\n        var d = this.options,\n            e = d.slicedOffset,\n            f = e + (d.borderWidth || 0),\n            a = h(d.startAngle, d.endAngle),\n            g = this.startAngleRad = a.start;\n        a = (this.endAngleRad = a.end) - g;\n        var c = this.points,\n            l = d.dataLabels.distance;\n        d = d.ignoreHiddenPoint;\n        var q = c.length,\n            t,\n            v = 0;\n        b || (this.center = b = this.getCenter());\n\n        for (t = 0; t < q; t++) {\n          var w = c[t];\n          var z = g + v * a;\n          !w.isValid() || d && !w.visible || (v += w.percentage / 100);\n          var y = g + v * a;\n          var B = {\n            x: b[0],\n            y: b[1],\n            r: b[2] / 2,\n            innerR: b[3] / 2,\n            start: Math.round(1E3 * z) / 1E3,\n            end: Math.round(1E3 * y) / 1E3\n          };\n          w.shapeType = \"arc\";\n          w.shapeArgs = B;\n          w.labelDistance = r(w.options.dataLabels && w.options.dataLabels.distance, l);\n          w.labelDistance = n(w.labelDistance, B.r);\n          this.maxLabelDistance = Math.max(this.maxLabelDistance || 0, w.labelDistance);\n          y = (y + z) / 2;\n          y > 1.5 * Math.PI ? y -= 2 * Math.PI : y < -Math.PI / 2 && (y += 2 * Math.PI);\n          w.slicedTranslation = {\n            translateX: Math.round(Math.cos(y) * e),\n            translateY: Math.round(Math.sin(y) * e)\n          };\n          B = Math.cos(y) * b[2] / 2;\n          var C = Math.sin(y) * b[2] / 2;\n          w.tooltipPos = [b[0] + .7 * B, b[1] + .7 * C];\n          w.half = y < -Math.PI / 2 || y > Math.PI / 2 ? 1 : 0;\n          w.angle = y;\n          z = Math.min(f, w.labelDistance / 5);\n          w.labelPosition = {\n            natural: {\n              x: b[0] + B + Math.cos(y) * w.labelDistance,\n              y: b[1] + C + Math.sin(y) * w.labelDistance\n            },\n            \"final\": {},\n            alignment: 0 > w.labelDistance ? \"center\" : w.half ? \"right\" : \"left\",\n            connectorPosition: {\n              breakAt: {\n                x: b[0] + B + Math.cos(y) * z,\n                y: b[1] + C + Math.sin(y) * z\n              },\n              touchingSliceAt: {\n                x: b[0] + B,\n                y: b[1] + C\n              }\n            }\n          };\n        }\n\n        p(this, \"afterTranslate\");\n      };\n\n      e.prototype.updateTotals = function () {\n        var b = this.points,\n            d = b.length,\n            e = this.options.ignoreHiddenPoint,\n            f,\n            a = 0;\n\n        for (f = 0; f < d; f++) {\n          var g = b[f];\n          !g.isValid() || e && !g.visible || (a += g.y);\n        }\n\n        this.total = a;\n\n        for (f = 0; f < d; f++) g = b[f], g.percentage = 0 < a && (g.visible || !e) ? g.y / a * 100 : 0, g.total = a;\n      };\n\n      e.defaultOptions = q(E.defaultOptions, {\n        center: [null, null],\n        clip: !1,\n        colorByPoint: !0,\n        dataLabels: {\n          allowOverlap: !0,\n          connectorPadding: 5,\n          connectorShape: \"fixedOffset\",\n          crookDistance: \"70%\",\n          distance: 30,\n          enabled: !0,\n          formatter: function () {\n            return this.point.isNull ? void 0 : this.point.name;\n          },\n          softConnector: !0,\n          x: 0\n        },\n        fillColor: void 0,\n        ignoreHiddenPoint: !0,\n        inactiveOtherPoints: !0,\n        legendType: \"point\",\n        marker: null,\n        size: null,\n        showInLegend: !1,\n        slicedOffset: 10,\n        stickyTracking: !1,\n        tooltip: {\n          followPointer: !0\n        },\n        borderColor: \"#ffffff\",\n        borderWidth: 1,\n        lineWidth: void 0,\n        states: {\n          hover: {\n            brightness: .1\n          }\n        }\n      });\n      return e;\n    }(E);\n\n    b(y.prototype, {\n      axisTypes: [],\n      directTouch: !0,\n      drawGraph: void 0,\n      drawLegendSymbol: C.drawRectangle,\n      drawTracker: e.prototype.drawTracker,\n      getCenter: f.getCenter,\n      getSymbol: l,\n      isCartesian: !1,\n      noSharedTooltip: !0,\n      pointAttribs: e.prototype.pointAttribs,\n      pointClass: v,\n      requireSorting: !1,\n      searchPoint: l,\n      trackerGroups: [\"group\", \"dataLabelsGroup\"]\n    });\n    G.registerSeriesType(\"pie\", y);\n    \"\";\n    return y;\n  });\n  K(l, \"Series/Pie/PieDataLabel.js\", [l[\"Core/Series/DataLabel.js\"], l[\"Core/Globals.js\"], l[\"Core/Renderer/RendererUtilities.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Core/Utilities.js\"]], function (f, e, l, C, v) {\n    var E = e.noop,\n        G = l.distribute,\n        B = C.series,\n        y = v.arrayMax,\n        t = v.clamp,\n        h = v.defined,\n        d = v.merge,\n        b = v.pick,\n        p = v.relativeLength,\n        q;\n\n    (function (e) {\n      function l() {\n        var e = this,\n            f = e.data,\n            a = e.chart,\n            g = e.options.dataLabels || {},\n            c = g.connectorPadding,\n            l = a.plotWidth,\n            n = a.plotHeight,\n            p = a.plotLeft,\n            q = Math.round(a.chartWidth / 3),\n            r = e.center,\n            t = r[2] / 2,\n            x = r[1],\n            v = [[], []],\n            w = [0, 0, 0, 0],\n            z = e.dataLabelPositioners,\n            C,\n            E,\n            J,\n            K,\n            P,\n            F,\n            T,\n            N,\n            V,\n            W,\n            X,\n            Q;\n        e.visible && (g.enabled || e._hasPointLabels) && (f.forEach(function (a) {\n          a.dataLabel && a.visible && a.dataLabel.shortened && (a.dataLabel.attr({\n            width: \"auto\"\n          }).css({\n            width: \"auto\",\n            textOverflow: \"clip\"\n          }), a.dataLabel.shortened = !1);\n        }), B.prototype.drawDataLabels.apply(e), f.forEach(function (a) {\n          a.dataLabel && (a.visible ? (v[a.half].push(a), a.dataLabel._pos = null, !h(g.style.width) && !h(a.options.dataLabels && a.options.dataLabels.style && a.options.dataLabels.style.width) && a.dataLabel.getBBox().width > q && (a.dataLabel.css({\n            width: Math.round(.7 * q) + \"px\"\n          }), a.dataLabel.shortened = !0)) : (a.dataLabel = a.dataLabel.destroy(), a.dataLabels && 1 === a.dataLabels.length && delete a.dataLabels));\n        }), v.forEach(function (d, f) {\n          var k = d.length,\n              m = [],\n              q;\n\n          if (k) {\n            e.sortByAngle(d, f - .5);\n\n            if (0 < e.maxLabelDistance) {\n              var u = Math.max(0, x - t - e.maxLabelDistance);\n              var v = Math.min(x + t + e.maxLabelDistance, a.plotHeight);\n              d.forEach(function (b) {\n                0 < b.labelDistance && b.dataLabel && (b.top = Math.max(0, x - t - b.labelDistance), b.bottom = Math.min(x + t + b.labelDistance, a.plotHeight), q = b.dataLabel.getBBox().height || 21, b.distributeBox = {\n                  target: b.labelPosition.natural.y - b.top + q / 2,\n                  size: q,\n                  rank: b.y\n                }, m.push(b.distributeBox));\n              });\n              u = v + q - u;\n              G(m, u, u / 5);\n            }\n\n            for (X = 0; X < k; X++) {\n              C = d[X];\n              F = C.labelPosition;\n              K = C.dataLabel;\n              W = !1 === C.visible ? \"hidden\" : \"inherit\";\n              V = u = F.natural.y;\n              m && h(C.distributeBox) && (\"undefined\" === typeof C.distributeBox.pos ? W = \"hidden\" : (T = C.distributeBox.size, V = z.radialDistributionY(C)));\n              delete C.positionIndex;\n              if (g.justify) N = z.justify(C, t, r);else switch (g.alignTo) {\n                case \"connectors\":\n                  N = z.alignToConnectors(d, f, l, p);\n                  break;\n\n                case \"plotEdges\":\n                  N = z.alignToPlotEdges(K, f, l, p);\n                  break;\n\n                default:\n                  N = z.radialDistributionX(e, C, V, u);\n              }\n              K._attr = {\n                visibility: W,\n                align: F.alignment\n              };\n              Q = C.options.dataLabels || {};\n              K._pos = {\n                x: N + b(Q.x, g.x) + ({\n                  left: c,\n                  right: -c\n                }[F.alignment] || 0),\n                y: V + b(Q.y, g.y) - 10\n              };\n              F.final.x = N;\n              F.final.y = V;\n              b(g.crop, !0) && (P = K.getBBox().width, u = null, N - P < c && 1 === f ? (u = Math.round(P - N + c), w[3] = Math.max(u, w[3])) : N + P > l - c && 0 === f && (u = Math.round(N + P - l + c), w[1] = Math.max(u, w[1])), 0 > V - T / 2 ? w[0] = Math.max(Math.round(-V + T / 2), w[0]) : V + T / 2 > n && (w[2] = Math.max(Math.round(V + T / 2 - n), w[2])), K.sideOverflow = u);\n            }\n          }\n        }), 0 === y(w) || this.verifyDataLabelOverflow(w)) && (this.placeDataLabels(), this.points.forEach(function (c) {\n          Q = d(g, c.options.dataLabels);\n\n          if (E = b(Q.connectorWidth, 1)) {\n            var f;\n            J = c.connector;\n\n            if ((K = c.dataLabel) && K._pos && c.visible && 0 < c.labelDistance) {\n              W = K._attr.visibility;\n              if (f = !J) c.connector = J = a.renderer.path().addClass(\"highcharts-data-label-connector  highcharts-color-\" + c.colorIndex + (c.className ? \" \" + c.className : \"\")).add(e.dataLabelsGroup), a.styledMode || J.attr({\n                \"stroke-width\": E,\n                stroke: Q.connectorColor || c.color || \"#666666\"\n              });\n              J[f ? \"attr\" : \"animate\"]({\n                d: c.getConnectorPath()\n              });\n              J.attr(\"visibility\", W);\n            } else J && (c.connector = J.destroy());\n          }\n        }));\n      }\n\n      function q() {\n        this.points.forEach(function (b) {\n          var d = b.dataLabel,\n              a;\n          d && b.visible && ((a = d._pos) ? (d.sideOverflow && (d._attr.width = Math.max(d.getBBox().width - d.sideOverflow, 0), d.css({\n            width: d._attr.width + \"px\",\n            textOverflow: (this.options.dataLabels.style || {}).textOverflow || \"ellipsis\"\n          }), d.shortened = !0), d.attr(d._attr), d[d.moved ? \"animate\" : \"attr\"](a), d.moved = !0) : d && d.attr({\n            y: -9999\n          }));\n          delete b.distributeBox;\n        }, this);\n      }\n\n      function r(b) {\n        var d = this.center,\n            a = this.options,\n            e = a.center,\n            c = a.minSize || 80,\n            f = null !== a.size;\n\n        if (!f) {\n          if (null !== e[0]) var h = Math.max(d[2] - Math.max(b[1], b[3]), c);else h = Math.max(d[2] - b[1] - b[3], c), d[0] += (b[3] - b[1]) / 2;\n          null !== e[1] ? h = t(h, c, d[2] - Math.max(b[0], b[2])) : (h = t(h, c, d[2] - b[0] - b[2]), d[1] += (b[0] - b[2]) / 2);\n          h < d[2] ? (d[2] = h, d[3] = Math.min(a.thickness ? Math.max(0, h - 2 * a.thickness) : Math.max(0, p(a.innerSize || 0, h)), h), this.translate(d), this.drawDataLabels && this.drawDataLabels()) : f = !0;\n        }\n\n        return f;\n      }\n\n      var v = [],\n          x = {\n        radialDistributionY: function (b) {\n          return b.top + b.distributeBox.pos;\n        },\n        radialDistributionX: function (b, d, a, e) {\n          return b.getX(a < d.top + 2 || a > d.bottom - 2 ? e : a, d.half, d);\n        },\n        justify: function (b, d, a) {\n          return a[0] + (b.half ? -1 : 1) * (d + b.labelDistance);\n        },\n        alignToPlotEdges: function (b, d, a, e) {\n          b = b.getBBox().width;\n          return d ? b + e : a - b - e;\n        },\n        alignToConnectors: function (b, d, a, e) {\n          var c = 0,\n              f;\n          b.forEach(function (a) {\n            f = a.dataLabel.getBBox().width;\n            f > c && (c = f);\n          });\n          return d ? c + e : a - c - e;\n        }\n      };\n\n      e.compose = function (b) {\n        f.compose(B);\n        -1 === v.indexOf(b) && (v.push(b), b = b.prototype, b.dataLabelPositioners = x, b.alignDataLabel = E, b.drawDataLabels = l, b.placeDataLabels = q, b.verifyDataLabelOverflow = r);\n      };\n    })(q || (q = {}));\n\n    return q;\n  });\n  K(l, \"Extensions/OverlappingDataLabels.js\", [l[\"Core/Chart/Chart.js\"], l[\"Core/Utilities.js\"]], function (f, e) {\n    function l(e, f) {\n      var d = !1;\n\n      if (e) {\n        var b = e.newOpacity;\n        e.oldOpacity !== b && (e.alignAttr && e.placed ? (e[b ? \"removeClass\" : \"addClass\"](\"highcharts-data-label-hidden\"), d = !0, e.alignAttr.opacity = b, e[e.isOld ? \"animate\" : \"attr\"](e.alignAttr, null, function () {\n          f.styledMode || e.css({\n            pointerEvents: b ? \"auto\" : \"none\"\n          });\n        }), v(f, \"afterHideOverlappingLabel\")) : e.attr({\n          opacity: b\n        }));\n        e.isOld = !0;\n      }\n\n      return d;\n    }\n\n    var C = e.addEvent,\n        v = e.fireEvent,\n        E = e.isArray,\n        G = e.isNumber,\n        B = e.objectEach,\n        y = e.pick;\n    C(f, \"render\", function () {\n      var e = this,\n          f = [];\n      (this.labelCollectors || []).forEach(function (d) {\n        f = f.concat(d());\n      });\n      (this.yAxis || []).forEach(function (d) {\n        d.stacking && d.options.stackLabels && !d.options.stackLabels.allowOverlap && B(d.stacking.stacks, function (b) {\n          B(b, function (b) {\n            b.label && f.push(b.label);\n          });\n        });\n      });\n      (this.series || []).forEach(function (d) {\n        var b = d.options.dataLabels;\n        d.visible && (!1 !== b.enabled || d._hasPointLabels) && (b = function (b) {\n          return b.forEach(function (b) {\n            b.visible && (E(b.dataLabels) ? b.dataLabels : b.dataLabel ? [b.dataLabel] : []).forEach(function (d) {\n              var h = d.options;\n              d.labelrank = y(h.labelrank, b.labelrank, b.shapeArgs && b.shapeArgs.height);\n              h.allowOverlap ? (d.oldOpacity = d.opacity, d.newOpacity = 1, l(d, e)) : f.push(d);\n            });\n          });\n        }, b(d.nodes || []), b(d.points));\n      });\n      this.hideOverlappingLabels(f);\n    });\n\n    f.prototype.hideOverlappingLabels = function (e) {\n      var f = this,\n          d = e.length,\n          b = f.renderer,\n          p,\n          q,\n          r,\n          n = !1;\n\n      var t = function (d) {\n        var e,\n            f = d.box ? 0 : d.padding || 0,\n            a = e = 0,\n            g;\n\n        if (d && (!d.alignAttr || d.placed)) {\n          var c = d.alignAttr || {\n            x: d.attr(\"x\"),\n            y: d.attr(\"y\")\n          };\n          var h = d.parentGroup;\n          d.width || (e = d.getBBox(), d.width = e.width, d.height = e.height, e = b.fontMetrics(null, d.element).h);\n          var l = d.width - 2 * f;\n          (g = {\n            left: \"0\",\n            center: \"0.5\",\n            right: \"1\"\n          }[d.alignValue]) ? a = +g * l : G(d.x) && Math.round(d.x) !== d.translateX && (a = d.x - d.translateX);\n          return {\n            x: c.x + (h.translateX || 0) + f - (a || 0),\n            y: c.y + (h.translateY || 0) + f - e,\n            width: d.width - 2 * f,\n            height: d.height - 2 * f\n          };\n        }\n      };\n\n      for (q = 0; q < d; q++) if (p = e[q]) p.oldOpacity = p.opacity, p.newOpacity = 1, p.absoluteBox = t(p);\n\n      e.sort(function (b, d) {\n        return (d.labelrank || 0) - (b.labelrank || 0);\n      });\n\n      for (q = 0; q < d; q++) {\n        var w = (t = e[q]) && t.absoluteBox;\n\n        for (p = q + 1; p < d; ++p) {\n          var z = (r = e[p]) && r.absoluteBox;\n          !w || !z || t === r || 0 === t.newOpacity || 0 === r.newOpacity || \"hidden\" === t.visibility || \"hidden\" === r.visibility || z.x >= w.x + w.width || z.x + z.width <= w.x || z.y >= w.y + w.height || z.y + z.height <= w.y || ((t.labelrank < r.labelrank ? t : r).newOpacity = 0);\n        }\n      }\n\n      e.forEach(function (b) {\n        l(b, f) && (n = !0);\n      });\n      n && v(f, \"afterHideAllOverlappingLabels\");\n    };\n  });\n  K(l, \"Core/Responsive.js\", [l[\"Core/Utilities.js\"]], function (f) {\n    var e = f.extend,\n        l = f.find,\n        C = f.isArray,\n        v = f.isObject,\n        E = f.merge,\n        G = f.objectEach,\n        B = f.pick,\n        y = f.splat,\n        t = f.uniqueKey,\n        h;\n\n    (function (d) {\n      var b = [];\n\n      d.compose = function (d) {\n        -1 === b.indexOf(d) && (b.push(d), e(d.prototype, f.prototype));\n        return d;\n      };\n\n      var f = function () {\n        function b() {}\n\n        b.prototype.currentOptions = function (b) {\n          function d(b, f, h, k) {\n            var a;\n            G(b, function (b, c) {\n              if (!k && -1 < e.collectionsWithUpdate.indexOf(c) && f[c]) for (b = y(b), h[c] = [], a = 0; a < Math.max(b.length, f[c].length); a++) f[c][a] && (void 0 === b[a] ? h[c][a] = f[c][a] : (h[c][a] = {}, d(b[a], f[c][a], h[c][a], k + 1)));else v(b) ? (h[c] = C(b) ? [] : {}, d(b, f[c] || {}, h[c], k + 1)) : h[c] = \"undefined\" === typeof f[c] ? null : f[c];\n            });\n          }\n\n          var e = this,\n              f = {};\n          d(b, this.options, f, 0);\n          return f;\n        };\n\n        b.prototype.matchResponsiveRule = function (b, d) {\n          var e = b.condition;\n          (e.callback || function () {\n            return this.chartWidth <= B(e.maxWidth, Number.MAX_VALUE) && this.chartHeight <= B(e.maxHeight, Number.MAX_VALUE) && this.chartWidth >= B(e.minWidth, 0) && this.chartHeight >= B(e.minHeight, 0);\n          }).call(this) && d.push(b._id);\n        };\n\n        b.prototype.setResponsive = function (b, d) {\n          var e = this,\n              f = this.options.responsive,\n              h = this.currentResponsive,\n              n = [];\n          !d && f && f.rules && f.rules.forEach(function (b) {\n            \"undefined\" === typeof b._id && (b._id = t());\n            e.matchResponsiveRule(b, n);\n          }, this);\n          d = E.apply(void 0, n.map(function (b) {\n            return l((f || {}).rules || [], function (d) {\n              return d._id === b;\n            });\n          }).map(function (b) {\n            return b && b.chartOptions;\n          }));\n          d.isResponsiveOptions = !0;\n          n = n.toString() || void 0;\n          n !== (h && h.ruleIds) && (h && this.update(h.undoOptions, b, !0), n ? (h = this.currentOptions(d), h.isResponsiveOptions = !0, this.currentResponsive = {\n            ruleIds: n,\n            mergedOptions: d,\n            undoOptions: h\n          }, this.update(d, b, !0)) : this.currentResponsive = void 0);\n        };\n\n        return b;\n      }();\n    })(h || (h = {}));\n\n    \"\";\n    \"\";\n    return h;\n  });\n  K(l, \"masters/highcharts.src.js\", [l[\"Core/Globals.js\"], l[\"Core/Utilities.js\"], l[\"Core/DefaultOptions.js\"], l[\"Core/Animation/Fx.js\"], l[\"Core/Animation/AnimationUtilities.js\"], l[\"Core/Renderer/HTML/AST.js\"], l[\"Core/FormatUtilities.js\"], l[\"Core/Renderer/RendererUtilities.js\"], l[\"Core/Renderer/SVG/SVGElement.js\"], l[\"Core/Renderer/SVG/SVGRenderer.js\"], l[\"Core/Renderer/HTML/HTMLElement.js\"], l[\"Core/Renderer/HTML/HTMLRenderer.js\"], l[\"Core/Axis/Axis.js\"], l[\"Core/Axis/DateTimeAxis.js\"], l[\"Core/Axis/LogarithmicAxis.js\"], l[\"Core/Axis/PlotLineOrBand/PlotLineOrBand.js\"], l[\"Core/Axis/Tick.js\"], l[\"Core/Tooltip.js\"], l[\"Core/Series/Point.js\"], l[\"Core/Pointer.js\"], l[\"Core/MSPointer.js\"], l[\"Core/Legend/Legend.js\"], l[\"Core/Chart/Chart.js\"], l[\"Core/Series/Series.js\"], l[\"Core/Series/SeriesRegistry.js\"], l[\"Series/Column/ColumnSeries.js\"], l[\"Series/Column/ColumnDataLabel.js\"], l[\"Series/Pie/PieSeries.js\"], l[\"Series/Pie/PieDataLabel.js\"], l[\"Core/Series/DataLabel.js\"], l[\"Core/Responsive.js\"], l[\"Core/Color/Color.js\"], l[\"Core/Time.js\"]], function (f, e, l, C, v, E, G, B, y, t, h, d, b, p, q, r, n, J, w, z, x, m, k, a, g, c, D, A, u, K, S, R, M) {\n    f.animate = v.animate;\n    f.animObject = v.animObject;\n    f.getDeferredAnimation = v.getDeferredAnimation;\n    f.setAnimation = v.setAnimation;\n    f.stop = v.stop;\n    f.timers = C.timers;\n    f.AST = E;\n    f.Axis = b;\n    f.Chart = k;\n    f.chart = k.chart;\n    f.Fx = C;\n    f.Legend = m;\n    f.PlotLineOrBand = r;\n    f.Point = w;\n    f.Pointer = x.isRequired() ? x : z;\n    f.Series = a;\n    f.SVGElement = y;\n    f.SVGRenderer = t;\n    f.Tick = n;\n    f.Time = M;\n    f.Tooltip = J;\n    f.Color = R;\n    f.color = R.parse;\n    d.compose(t);\n    h.compose(y);\n    f.defaultOptions = l.defaultOptions;\n    f.getOptions = l.getOptions;\n    f.time = l.defaultTime;\n    f.setOptions = l.setOptions;\n    f.dateFormat = G.dateFormat;\n    f.format = G.format;\n    f.numberFormat = G.numberFormat;\n    f.addEvent = e.addEvent;\n    f.arrayMax = e.arrayMax;\n    f.arrayMin = e.arrayMin;\n    f.attr = e.attr;\n    f.clearTimeout = e.clearTimeout;\n    f.correctFloat = e.correctFloat;\n    f.createElement = e.createElement;\n    f.css = e.css;\n    f.defined = e.defined;\n    f.destroyObjectProperties = e.destroyObjectProperties;\n    f.discardElement = e.discardElement;\n    f.distribute = B.distribute;\n    f.erase = e.erase;\n    f.error = e.error;\n    f.extend = e.extend;\n    f.extendClass = e.extendClass;\n    f.find = e.find;\n    f.fireEvent = e.fireEvent;\n    f.getMagnitude = e.getMagnitude;\n    f.getStyle = e.getStyle;\n    f.inArray = e.inArray;\n    f.isArray = e.isArray;\n    f.isClass = e.isClass;\n    f.isDOMElement = e.isDOMElement;\n    f.isFunction = e.isFunction;\n    f.isNumber = e.isNumber;\n    f.isObject = e.isObject;\n    f.isString = e.isString;\n    f.keys = e.keys;\n    f.merge = e.merge;\n    f.normalizeTickInterval = e.normalizeTickInterval;\n    f.objectEach = e.objectEach;\n    f.offset = e.offset;\n    f.pad = e.pad;\n    f.pick = e.pick;\n    f.pInt = e.pInt;\n    f.relativeLength = e.relativeLength;\n    f.removeEvent = e.removeEvent;\n    f.seriesType = g.seriesType;\n    f.splat = e.splat;\n    f.stableSort = e.stableSort;\n    f.syncTimeout = e.syncTimeout;\n    f.timeUnits = e.timeUnits;\n    f.uniqueKey = e.uniqueKey;\n    f.useSerialIds = e.useSerialIds;\n    f.wrap = e.wrap;\n    D.compose(c);\n    K.compose(a);\n    p.compose(b);\n    q.compose(b);\n    u.compose(A);\n    r.compose(b);\n    S.compose(k);\n    return f;\n  });\n  l[\"masters/highcharts.src.js\"]._modules = l;\n  return l[\"masters/highcharts.src.js\"];\n}); //# sourceMappingURL=highcharts.js.map","map":null,"metadata":{},"sourceType":"script"}