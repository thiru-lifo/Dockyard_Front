{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { DateAxis } from \"./DateAxis\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $time from \"../../../core/util/Time\";\nimport * as $type from \"../../../core/util/Type\";\n/**\r\n * A version of a [[DateAxis]] which removes intervals that don't have any data\r\n * items in them.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/gapless-date-axis/} for more info\r\n * @important\r\n */\n\nvar GaplessDateAxis =\n/** @class */\nfunction (_super) {\n  __extends(GaplessDateAxis, _super);\n\n  function GaplessDateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_frequency\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_dates\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    return _this;\n  }\n\n  Object.defineProperty(GaplessDateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.valueFields.push(\"date\");\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(GaplessDateAxis.prototype, \"_updateDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (date) {\n      var dates = this._dates;\n      var result = $array.getSortedIndex(dates, function (x) {\n        return $order.compare(x, date);\n      });\n\n      if (!result.found) {\n        $array.insertIndex(dates, result.index, date);\n      }\n    }\n  });\n  Object.defineProperty(GaplessDateAxis.prototype, \"_updateAllDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._dates.length = 0;\n      $array.each(this.series, function (series) {\n        var field = \"valueX\";\n\n        if (series.get(\"yAxis\") == _this) {\n          field = \"valueY\";\n        }\n\n        $array.each(series.dataItems, function (dataItem) {\n          var value = dataItem.get(field);\n\n          if ($type.isNumber(value)) {\n            if (dataItem.open) {\n              _this._updateDates(dataItem.open[field]);\n            }\n          }\n        });\n      });\n    }\n  });\n  /**\r\n   * Convers value to a relative position on axis.\r\n   *\r\n   * @param   value  Value\r\n   * @return         Relative position\r\n   */\n\n  Object.defineProperty(GaplessDateAxis.prototype, \"valueToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var dates = this._dates;\n      var startLocation = this.get(\"startLocation\", 0);\n      var endLocation = this.get(\"endLocation\", 1);\n      var len = dates.length - startLocation - (1 - endLocation);\n      var result = $array.getSortedIndex(dates, function (x) {\n        return $order.compare(x, value);\n      });\n      var index = result.index;\n\n      if (result.found) {\n        return (index - startLocation) / len;\n      } else {\n        if (index > 0) {\n          index -= 1;\n        }\n\n        var itemValue = dates[index];\n        var d = 0;\n\n        if (itemValue > value) {\n          d = itemValue - value;\n        } else {\n          d = value - itemValue;\n        }\n\n        return (index - startLocation) / len + d / this.baseDuration() / len;\n      }\n    }\n  });\n  /**\r\n   * Converts numeric value from axis scale to index.\r\n   *\r\n   * @param  value  Value\r\n   * @return        Index\r\n   */\n\n  Object.defineProperty(GaplessDateAxis.prototype, \"valueToIndex\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var dates = this._dates;\n      var result = $array.getSortedIndex(dates, function (x) {\n        return $order.compare(x, value);\n      });\n      var index = result.index;\n\n      if (result.found) {\n        return index;\n      } else {\n        if (index > 0) {\n          index -= 1;\n        }\n\n        return index;\n      }\n    }\n  });\n  /**\r\n   * Converts a relative position to a corresponding numeric value from axis\r\n   * scale.\r\n   *\r\n   * @param   position  Relative position\r\n   * @return            Value\r\n   */\n\n  Object.defineProperty(GaplessDateAxis.prototype, \"positionToValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var startLocation = this.get(\"startLocation\", 0);\n      var endLocation = this.get(\"endLocation\", 1);\n      var len = Math.round(this._dates.length - startLocation - (1 - endLocation));\n      var index = position * len;\n      var findex = Math.floor(index);\n\n      if (findex < 0) {\n        findex = 0;\n      }\n\n      if (findex > len - 1) {\n        findex = len - 1;\n      }\n\n      return this._dates[findex] + (index - findex + startLocation) * this.baseDuration();\n    }\n  });\n  Object.defineProperty(GaplessDateAxis.prototype, \"_fixZoomFactor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivateRaw(\"maxZoomFactor\", this._dates.length - this.get(\"startLocation\", 0) - (1 - this.get(\"endLocation\", 1)));\n    }\n  });\n  Object.defineProperty(GaplessDateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var startTime = this.getPrivate(\"selectionMin\", 0);\n      var endTime = this.getPrivate(\"selectionMax\", 0);\n\n      if ($type.isNumber(startTime) && $type.isNumber(endTime)) {\n        if (this._seriesValuesDirty) {\n          this._seriesValuesDirty = false;\n\n          this._updateAllDates();\n        }\n\n        var dates_1 = this._dates;\n        var renderer = this.get(\"renderer\");\n        var len = dates_1.length;\n        var startIndex_1 = this.valueToIndex(startTime);\n\n        if (startIndex_1 > 0) {\n          startIndex_1--;\n        }\n\n        var endIndex_1 = this.valueToIndex(endTime);\n\n        if (endIndex_1 < len - 1) {\n          endIndex_1++;\n        }\n\n        var maxCount = renderer.axisLength() / Math.max(renderer.get(\"minGridDistance\"), 1 / Number.MAX_SAFE_INTEGER);\n        var frequency = Math.min(len, Math.ceil((endIndex_1 - startIndex_1) / maxCount));\n        frequency = Math.max(1, frequency);\n        startIndex_1 = Math.floor(startIndex_1 / frequency) * frequency;\n        this._frequency = frequency;\n\n        for (var j = 0, length_1 = this.dataItems.length; j < length_1; j++) {\n          this.dataItems[j].hide();\n        }\n\n        var realDuration = endTime - startTime - ((endTime - startTime) / this.baseDuration() - (endIndex_1 - startIndex_1)) * this.baseDuration(); // if all items are on axis\n\n        var gridInterval_1 = $time.chooseInterval(0, realDuration, maxCount, this.get(\"gridIntervals\"));\n        var baseInterval = this.getPrivate(\"baseInterval\");\n        var intervalDuration_1 = $time.getIntervalDuration(gridInterval_1);\n\n        if (intervalDuration_1 < this.baseDuration()) {\n          gridInterval_1 = __assign({}, baseInterval);\n          intervalDuration_1 = $time.getIntervalDuration(gridInterval_1);\n        }\n\n        this._intervalDuration = intervalDuration_1;\n        var formats_1 = this.get(\"dateFormats\");\n        var selectedItems_1 = [];\n        var firstDate = new Date();\n\n        if (this._dates[0]) {\n          firstDate = new Date(this._dates[0]);\n        }\n\n        var startDate = $time.round(new Date(this.getPrivate(\"min\", 0)), gridInterval_1.timeUnit, gridInterval_1.count, this._root.locale.firstDayOfWeek, this._root.utc, firstDate, this._root.timezone);\n        var value = $time.add(startDate, gridInterval_1.timeUnit, -1, this._root.utc, this._root.timezone).getTime();\n        var selectionMax = this.getPrivate(\"selectionMax\");\n        var previousPosition = -Infinity;\n        var minDifference = (this.get(\"end\", 1) - this.get(\"start\", 0)) / maxCount;\n\n        while (value <= selectionMax) {\n          var index = this.valueToIndex(value);\n          var realValue = this._dates[index];\n\n          if (realValue < value) {\n            for (var i = index, len_1 = this._dates.length; i < len_1; i++) {\n              var realValue_1 = this._dates[i];\n\n              if (realValue_1 >= value) {\n                index = i;\n                break;\n              }\n            }\n          }\n\n          var position = this.valueToPosition(realValue);\n\n          if (position - previousPosition >= minDifference * 0.95) {\n            $array.move(selectedItems_1, index);\n            previousPosition = position;\n          }\n\n          var previousValue = value;\n          value += $time.getDuration(gridInterval_1.timeUnit, gridInterval_1.count * 1.05);\n          value = $time.round(new Date(value), gridInterval_1.timeUnit, gridInterval_1.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n\n          if (value == previousValue) {\n            break;\n          }\n        }\n\n        if (selectedItems_1.length > 0) {\n          var i_1 = 0;\n          var previousValue_1 = value - intervalDuration_1 * 10;\n          var nextGridUnit_1 = $time.getNextUnit(gridInterval_1.timeUnit);\n          $array.each(selectedItems_1, function (index) {\n            var dataItem;\n\n            if (_this.dataItems.length < i_1 + 1) {\n              dataItem = new DataItem(_this, undefined, {});\n\n              _this._dataItems.push(dataItem);\n\n              _this.processDataItem(dataItem);\n            } else {\n              dataItem = _this.dataItems[i_1];\n            }\n\n            var value = dates_1[index];\n            var date = new Date(value);\n            var endValue = value;\n\n            if (i_1 < selectedItems_1.length - 1) {\n              endValue = dates_1[selectedItems_1[i_1 + 1]];\n            } else {\n              endValue += intervalDuration_1;\n            }\n\n            dataItem.setRaw(\"value\", value);\n            dataItem.setRaw(\"endValue\", endValue);\n            dataItem.setRaw(\"index\", i_1);\n\n            if (index > startIndex_1 - 100 && index < endIndex_1 + 100) {\n              var format = formats_1[gridInterval_1.timeUnit];\n              format = formats_1[gridInterval_1.timeUnit];\n\n              if (nextGridUnit_1 && _this.get(\"markUnitChange\") && $type.isNumber(previousValue_1)) {\n                if (gridInterval_1.timeUnit != \"year\") {\n                  if ($time.checkChange(value, previousValue_1, nextGridUnit_1, _this._root.utc, _this._root.timezone)) {\n                    format = _this.get(\"periodChangeDateFormats\")[gridInterval_1.timeUnit];\n                  }\n                }\n              }\n\n              _this._createAssets(dataItem, []);\n\n              var label = dataItem.get(\"label\");\n\n              if (label) {\n                label.set(\"text\", _this._root.dateFormatter.format(date, format));\n              }\n\n              if (dataItem.isHidden()) {\n                dataItem.show();\n              }\n\n              _this._prepareDataItem(dataItem, gridInterval_1.count);\n            }\n\n            i_1++;\n            previousValue_1 = value;\n          });\n        }\n\n        $array.each(this.series, function (series) {\n          if (series.inited) {\n            series._markDirtyAxes();\n          }\n        });\n      }\n\n      this._updateGhost();\n    }\n  });\n  Object.defineProperty(GaplessDateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"GaplessDateAxis\"\n  });\n  Object.defineProperty(GaplessDateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: DateAxis.classNames.concat([GaplessDateAxis.className])\n  });\n  return GaplessDateAxis;\n}(DateAxis);\n\nexport { GaplessDateAxis }; //# sourceMappingURL=GaplessDateAxis.js.map","map":null,"metadata":{},"sourceType":"module"}