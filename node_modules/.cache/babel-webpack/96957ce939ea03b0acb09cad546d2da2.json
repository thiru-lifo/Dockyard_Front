{"ast":null,"code":"import { isNumber } from \"./Type\";\n/**\r\n * ============================================================================\r\n * CONSTANTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nexport var PI = Math.PI;\nexport var HALFPI = PI / 2;\nexport var RADIANS = PI / 180;\nexport var DEGREES = 180 / PI;\n/**\r\n * Rounds the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @param floor  In case value ends with 0.5 and precision is 0, we might need to floor the value instead of ceiling it.\r\n * @return Rounded value\r\n */\n\nexport function round(value, precision, floor) {\n  if (!isNumber(precision) || precision <= 0) {\n    var rounded = Math.round(value);\n\n    if (floor) {\n      if (rounded - value == 0.5) {\n        rounded--;\n      }\n    }\n\n    return rounded;\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.round(value * d) / d;\n  }\n}\n/**\r\n * Ceils the numeric value to whole number or specific precision of set.\r\n *\r\n * @param value      Value\r\n * @param precision  Precision (number of decimal points)\r\n * @return Rounded value\r\n */\n\nexport function ceil(value, precision) {\n  if (!isNumber(precision) || precision <= 0) {\n    return Math.ceil(value);\n  } else {\n    var d = Math.pow(10, precision);\n    return Math.ceil(value * d) / d;\n  }\n}\n/**\r\n * [getCubicControlPointA description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointA(p0, p1, p2, tensionX, tensionY) {\n  return {\n    x: (-p0.x + p1.x / tensionX + p2.x) * tensionX,\n    y: (-p0.y + p1.y / tensionY + p2.y) * tensionY\n  };\n}\n/**\r\n * [getCubicControlPointB description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param p0        [description]\r\n * @param p1        [description]\r\n * @param p2        [description]\r\n * @param p3        [description]\r\n * @param tensionX  [description]\r\n * @param tensionY  [description]\r\n * @return [description]\r\n */\n\nexport function getCubicControlPointB(p1, p2, p3, tensionX, tensionY) {\n  return {\n    x: (p1.x + p2.x / tensionX - p3.x) * tensionX,\n    y: (p1.y + p2.y / tensionY - p3.y) * tensionY\n  };\n}\nexport function fitToRange(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n/**\r\n * Returns sine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function sin(angle) {\n  return Math.sin(RADIANS * angle);\n}\n/**\r\n * Returns tan of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Sine\r\n */\n\nexport function tan(angle) {\n  return Math.tan(RADIANS * angle);\n}\n/**\r\n * Returns cosine of an angle specified in degrees.\r\n *\r\n * @param value  Value\r\n * @return Cosine\r\n */\n\nexport function cos(angle) {\n  return Math.cos(RADIANS * angle);\n} // 0 to 360\n\nexport function normalizeAngle(value) {\n  value = value % 360;\n\n  if (value < 0) {\n    value += 360;\n  }\n\n  return value;\n} // TODO this doesn't work properly for skewing, and it's probably broken for rotation too\n\nexport function getArcBounds(cx, cy, startAngle, endAngle, radius) {\n  var minX = Number.MAX_VALUE;\n  var minY = Number.MAX_VALUE;\n  var maxX = -Number.MAX_VALUE;\n  var maxY = -Number.MAX_VALUE;\n  var bpoints = [];\n  bpoints.push(getArcPoint(radius, startAngle));\n  bpoints.push(getArcPoint(radius, endAngle));\n  var fromAngle = Math.min(Math.floor(startAngle / 90) * 90, Math.floor(endAngle / 90) * 90);\n  var toAngle = Math.max(Math.ceil(startAngle / 90) * 90, Math.ceil(endAngle / 90) * 90);\n\n  for (var angle = fromAngle; angle <= toAngle; angle += 90) {\n    if (angle >= startAngle && angle <= endAngle) {\n      bpoints.push(getArcPoint(radius, angle));\n    }\n  }\n\n  for (var i = 0; i < bpoints.length; i++) {\n    var pt = bpoints[i];\n\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n\n  return {\n    left: cx + minX,\n    top: cy + minY,\n    right: cx + maxX,\n    bottom: cy + maxY\n  };\n}\n/**\r\n * Returns point on arc\r\n *\r\n * @param center point\r\n * @param radius\r\n * @param arc\r\n * @return {boolean}\r\n */\n\nexport function getArcPoint(radius, arc) {\n  return {\n    x: radius * cos(arc),\n    y: radius * sin(arc)\n  };\n}\nexport function mergeBounds(bounds) {\n  var len = bounds.length;\n\n  if (len > 0) {\n    var bound = bounds[0];\n    var left = bound.left;\n    var top_1 = bound.top;\n    var right = bound.right;\n    var bottom = bound.bottom;\n\n    if (len > 1) {\n      for (var i = 1; i < len; i++) {\n        bound = bounds[i];\n        left = Math.min(bound.left, left);\n        right = Math.max(bound.right, right);\n        top_1 = Math.min(bound.top, top_1);\n        bottom = Math.max(bound.bottom, bottom);\n      }\n    }\n\n    return {\n      left: left,\n      right: right,\n      top: top_1,\n      bottom: bottom\n    };\n  }\n\n  return {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n}\nexport function fitAngleToRange(value, startAngle, endAngle) {\n  if (startAngle > endAngle) {\n    var temp = startAngle;\n    startAngle = endAngle;\n    endAngle = temp;\n  }\n\n  value = normalizeAngle(value);\n  var count = (startAngle - normalizeAngle(startAngle)) / 360;\n\n  if (value < startAngle) {\n    value += 360 * (count + 1);\n  }\n\n  var maxEnd = startAngle + (endAngle - startAngle) / 2 + 180;\n  var maxStart = startAngle + (endAngle - startAngle) / 2 - 180;\n\n  if (value > endAngle) {\n    if (value - 360 > startAngle) {\n      value -= 360;\n    } else {\n      if (value < maxEnd) {\n        value = endAngle;\n      } else {\n        value = startAngle;\n      }\n    }\n  }\n\n  if (value < startAngle) {\n    if (value > maxStart) {\n      value = startAngle;\n    } else {\n      value = endAngle;\n    }\n  }\n\n  return value;\n}\nexport function inBounds(point, bounds) {\n  if (point.x >= bounds.left && point.y >= bounds.top && point.x <= bounds.right && point.y <= bounds.bottom) {\n    return true;\n  }\n\n  return false;\n}\nexport function getAngle(point1, point2) {\n  if (!point2) {\n    point2 = {\n      x: point1.x * 2,\n      y: point1.y * 2\n    };\n  }\n\n  var diffX = point2.x - point1.x;\n  var diffY = point2.y - point1.y;\n  var angle = Math.atan2(diffY, diffX) * DEGREES;\n\n  if (angle < 0) {\n    angle += 360;\n  }\n\n  return normalizeAngle(angle);\n}\n/**\r\n * [getPointOnQuadraticCurve description]\r\n *\r\n * @ignore Exclude from docs\r\n * @todo Description\r\n * @param pointA        [description]\r\n * @param pointB        [description]\r\n * @param controlPoint  [description]\r\n * @param position      [description]\r\n * @return [description]\r\n */\n\nexport function getPointOnQuadraticCurve(pointA, pointB, controlPoint, position) {\n  var x = (1 - position) * (1 - position) * pointA.x + 2 * (1 - position) * position * controlPoint.x + position * position * pointB.x;\n  var y = (1 - position) * (1 - position) * pointA.y + 2 * (1 - position) * position * controlPoint.y + position * position * pointB.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nexport function getPointOnLine(pointA, pointB, position) {\n  return {\n    x: pointA.x + (pointB.x - pointA.x) * position,\n    y: pointA.y + (pointB.y - pointA.y) * position\n  };\n}\n/**\r\n * Returns the closest value from the array of values to the reference value.\r\n *\r\n * @param values  Array of values\r\n * @param value   Reference value\r\n * @return Closes value from the array\r\n */\n\nexport function closest(values, referenceValue) {\n  return values.reduce(function (prev, curr) {\n    return Math.abs(curr - referenceValue) < Math.abs(prev - referenceValue) ? curr : prev;\n  });\n}\nexport function boundsOverlap(bounds1, bounds2) {\n  return !(bounds1.bottom < bounds2.top || bounds2.bottom < bounds1.top || bounds1.right < bounds2.left || bounds2.right < bounds1.left);\n} //# sourceMappingURL=Math.js.map","map":null,"metadata":{},"sourceType":"module"}