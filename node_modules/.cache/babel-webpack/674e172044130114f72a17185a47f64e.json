{"ast":null,"code":"/** @ignore */\n\n/** */\nimport * as $type from \"./Type\";\nimport * as $utils from \"./Utils\";\nimport { Sprite } from \"../render/Sprite\";\nimport { TextFormatter } from \"./TextFormatter\";\n/**\r\n * @ignore\r\n */\n\nexport function populateString(target, string) {\n  if (string != null) {\n    string = \"\" + string;\n    string = TextFormatter.escape(string);\n    var tags = string.match(/\\{([^}]+)\\}/g);\n    var i = void 0;\n\n    if (tags) {\n      for (i = 0; i < tags.length; i++) {\n        var tag = tags[i].replace(/\\{([^}]+)\\}/, \"$1\");\n        var value = getTagValue(target, tag, \"\");\n\n        if (value == null) {\n          value = \"\";\n        }\n\n        string = string.split(tags[i]).join(value);\n      }\n    }\n\n    string = TextFormatter.unescape(string);\n  } else {\n    string = \"\";\n  } // TODO: apply adapter?\n\n\n  return string;\n}\n/**\r\n * @ignore\r\n */\n\nfunction getTagValue(target, tagName, format) {\n  var value;\n  var dataItem = target.dataItem; // Parse parts\n\n  var parts = [];\n  var reg = /([^.]+)\\(([^)]*)\\)|([^.]+)/g;\n  ;\n  var matches;\n\n  while (true) {\n    matches = reg.exec(tagName);\n\n    if (matches === null) {\n      break;\n    }\n\n    if (matches[3]) {\n      // Simple property\n      parts.push({\n        prop: matches[3]\n      }); // Check if maybe we should force a formatter on this value\n\n      var dateFields = target.getDateFormatter().get(\"dateFields\", []);\n      var numericFields = target.getNumberFormatter().get(\"numericFields\", []);\n      var durationFields = target.getDurationFormatter().get(\"durationFields\", []);\n\n      if (dateFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatDate\",\n          params: []\n        });\n      } else if (numericFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatNumber\",\n          params: []\n        });\n      } else if (durationFields.indexOf(matches[3]) !== -1) {\n        parts.push({\n          method: \"formatDuration\",\n          params: []\n        });\n      }\n    } else {\n      // Method\n      // Parse parameters\n      var params = [];\n\n      if ($utils.trim(matches[2]) != \"\") {\n        var reg2 = /'([^']*)'|\"([^\"]*)\"|([0-9\\-]+)/g;\n        var matches2 = void 0;\n\n        while (true) {\n          matches2 = reg2.exec(matches[2]);\n\n          if (matches2 === null) {\n            break;\n          }\n\n          params.push(matches2[1] || matches2[2] || matches2[3]);\n        }\n      }\n\n      parts.push({\n        method: matches[1],\n        params: params\n      });\n    }\n  } // Check if we can retrieve the value from data item\n\n\n  if (dataItem) {\n    // Check values\n    value = getTagValueFromObject(target, parts, dataItem._settings); // Check properties\n\n    if (value == null || $type.isObject(value)) {\n      // isObject helps to solve problem with date axis, as for example dateX will get dateX from values object and won't get to the dateX date.\n      value = getTagValueFromObject(target, parts, dataItem);\n    } // Check data context\n\n\n    var dataContext = dataItem.dataContext;\n\n    if (value == null && dataContext) {\n      value = getTagValueFromObject(target, parts, dataContext); // Maybe it's a literal dot-separated name of the key in dataContext?\n\n      if (value == null) {\n        value = getTagValueFromObject(target, [{\n          prop: tagName\n        }], dataContext);\n      } // scond data context level sometimes exist (tree map)\n\n\n      if (value == null && dataContext.dataContext) {\n        value = getTagValueFromObject(target, parts, dataContext.dataContext);\n      }\n    } // Check component's data item\n\n\n    if (value == null && dataItem.component && dataItem.component.dataItem !== dataItem) {\n      value = getTagValue(dataItem.component, tagName, format);\n    }\n  } // Check sprite's properties\n\n\n  if (value == null) {\n    value = getTagValueFromObject(target, parts, target);\n  } // Finally, check the parent\n\n\n  if (value == null && target.parent) {\n    value = getTagValue(target.parent, tagName, format);\n  }\n\n  return value;\n}\n/**\r\n * @ignore\r\n */\n\n\nfunction getCustomDataValue(target, prop) {\n  var customData = target.getPrivate(\"customData\");\n\n  if ($type.isObject(customData)) {\n    return customData[prop];\n  }\n}\n/**\r\n * @ignore\r\n */\n\n\nexport function getTagValueFromObject(target, parts, object, format) {\n  var current = object;\n  var formatApplied = false;\n\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n\n    if (part.prop) {\n      // Regular property\n      if (current instanceof Sprite) {\n        var tmp = current.get(part.prop);\n        if (tmp == null) tmp = current.getPrivate(part.prop);\n        if (tmp == null) tmp = getCustomDataValue(current, part.prop);\n        if (tmp == null) tmp = current[part.prop];\n        current = tmp;\n      } else if (current.get) {\n        var tmp = current.get(part.prop);\n        if (tmp == null) tmp = current[part.prop];\n        current = tmp;\n      } else {\n        current = current[part.prop];\n      }\n\n      if (current == null) {\n        // Not set, return undefined\n        return;\n      }\n    } else {\n      // Method\n      switch (part.method) {\n        case \"formatNumber\":\n          var numberValue = $type.toNumber(current);\n\n          if (numberValue != null) {\n            current = target.getNumberFormatter().format(numberValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"formatDate\":\n          var dateValue = $type.toDate(current);\n\n          if (!$type.isDate(dateValue) || $type.isNaN(dateValue.getTime())) {\n            // Was not able to get date out of value, quitting and letting\n            // calling method try another value\n            return;\n          }\n\n          if (dateValue != null) {\n            current = target.getDateFormatter().format(dateValue, format || part.params[0] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"formatDuration\":\n          var durationValue = $type.toNumber(current);\n\n          if (durationValue != null) {\n            current = target.getDurationFormatter().format(durationValue, format || part.params[0] || undefined, part.params[1] || undefined);\n            formatApplied = true;\n          }\n\n          break;\n\n        case \"urlEncode\":\n        case \"encodeURIComponent\":\n          current = encodeURIComponent(current);\n          break;\n\n        default:\n          if (current[part.method]) {\n            current[part.method].apply(object, part.params);\n          }\n\n          break;\n      }\n    }\n  } // Apply default format if it wasn't applied explicitly\n\n\n  if (!formatApplied) {\n    var formatParts = [{\n      method: \"\",\n      params: format\n    }];\n\n    if (format == null) {\n      // Format is not set\n      // Determine from the type of the value\n      if ($type.isNumber(current)) {\n        formatParts[0].method = \"formatNumber\";\n        formatParts[0].params = \"\";\n      } else if ($type.isDate(current)) {\n        formatParts[0].method = \"formatDate\";\n        formatParts[0].params = \"\";\n      }\n    } else {\n      // Format set\n      // Try to determine formatter based on the format\n      var formatterType = $utils.getFormat(format); // format\n\n      if (formatterType === \"number\") {\n        formatParts[0].method = \"formatNumber\";\n      } else if (formatterType === \"date\") {\n        formatParts[0].method = \"formatDate\";\n      } else if (formatterType === \"duration\") {\n        formatParts[0].method = \"formatDuration\";\n      }\n    } // Apply format\n\n\n    if (formatParts[0].method) {\n      current = getTagValueFromObject(target, formatParts, current);\n    }\n  }\n\n  return current;\n} //# sourceMappingURL=PopulateString.js.map","map":null,"metadata":{},"sourceType":"module"}