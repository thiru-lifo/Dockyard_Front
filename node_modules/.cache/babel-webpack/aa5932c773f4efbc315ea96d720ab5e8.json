{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Pattern } from \"./Pattern\";\n/**\r\n * A pattern that uses an SVG path.\r\n *\r\n * @since 5.2.33\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\r\n */\n\nvar PathPattern =\n/** @class */\nfunction (_super) {\n  __extends(PathPattern, _super);\n\n  function PathPattern() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(PathPattern.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n\n      if (this.isDirty(\"svgPath\")) {\n        this._clear = true;\n      }\n    }\n  });\n  Object.defineProperty(PathPattern.prototype, \"_draw\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._draw.call(this); // const checkered = this.get(\"checkered\", false);\n      // const centered = this.get(\"centered\", true);\n      // const gap = this.get(\"gap\", 0);\n      // const rotation = this.get(\"rotation\", 0);\n      // let w = this.get(\"width\", 100);\n      // let h = this.get(\"height\", 100);\n      // let rectW = this.get(\"maxWidth\", 5);\n      // let rectH = this.get(\"maxHeight\", 5);\n      // let cellW = rectW + gap;\n      // let cellH = rectH + gap;\n      // let cols = Math.round(w / cellW);\n      // let rows = Math.round(h / cellH);\n      // cellW = w / cols;\n      // cellH = h / rows;\n      // if (rotation != 0) {\n      // \t// @todo this is probably not right\n      // \tthis._display.x = cellW / 2 * $math.cos(rotation);\n      // \tthis._display.y = -cellH / 2 * $math.sin(rotation);\n      // }\n      // for (let r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n      // \tfor (let c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n      // \t\tif (!checkered || ((r & 1) != 1 && (c & 1) != 1) || ((r & 1) == 1 && (c & 1) == 1)) {\n      // \t\t\tlet x = c * cellW;\n      // \t\t\tlet y = r * cellH;\n      // \t\t\tif (centered) {\n      // \t\t\t\tx += (cellW - rectW) / 2;\n      // \t\t\t\ty += (cellH - rectH) / 2;\n      // \t\t\t}\n      // \t\t\tthis._display.drawRect(x, y, rectW, rectH);\n      // \t\t}\n      // \t}\n      // }\n      // if (checkered) {\n      // \tw = w / 2 - gap * 2;\n      // \th = h / 2 - gap * 2;\n      // }\n      // else {\n      // \tw -= gap;\n      // \th -= gap;\n      // }\n\n\n      var svgPath = this.get(\"svgPath\");\n\n      if (svgPath != null) {\n        this._display.svgPath(svgPath);\n      }\n\n      var color = this.get(\"color\");\n      var colorOpacity = this.get(\"colorOpacity\");\n\n      if (color || colorOpacity) {\n        // this._display.lineStyle(strokeWidth, stroke, colorOpacity);\n        // this._display.endStroke();\n        this._display.beginFill(color, colorOpacity);\n\n        this._display.endFill();\n      }\n    }\n  });\n  Object.defineProperty(PathPattern, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"PathPattern\"\n  });\n  Object.defineProperty(PathPattern, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Pattern.classNames.concat([PathPattern.className])\n  });\n  return PathPattern;\n}(Pattern);\n\nexport { PathPattern }; //# sourceMappingURL=PathPattern.js.map","map":null,"metadata":{},"sourceType":"module"}