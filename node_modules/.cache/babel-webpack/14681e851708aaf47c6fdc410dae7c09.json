{"ast":null,"code":"import { Container } from \"./render/Container\";\nimport { Text } from \"./render/Text\";\nimport { HorizontalLayout } from \"./render/HorizontalLayout\";\nimport { VerticalLayout } from \"./render/VerticalLayout\";\nimport { GridLayout } from \"./render/GridLayout\";\nimport { Disposer } from \"./util/Disposer\";\nimport { ResizeSensor } from \"./util/ResizeSensor\";\nimport { InterfaceColors } from \"./util/InterfaceColors\";\nimport { Graphics } from \"./render/Graphics\";\nimport { Rectangle } from \"./render/Rectangle\";\nimport { Tooltip } from \"./render/Tooltip\";\nimport { NumberFormatter } from \"./util/NumberFormatter\";\nimport { DateFormatter } from \"./util/DateFormatter\";\nimport { DurationFormatter } from \"./util/DurationFormatter\";\nimport { Language } from \"./util/Language\";\nimport { EventDispatcher } from \"./util/EventDispatcher\";\nimport { DefaultTheme } from \"../themes/DefaultTheme\";\nimport { CanvasRenderer } from \"./render/backend/CanvasRenderer\";\nimport { p100, percent } from \"./util/Percent\";\nimport { color } from \"./util/Color\";\nimport { populateString } from \"./util/PopulateString\";\nimport { registry } from \"./Registry\";\nimport * as $order from \"./util/Order\";\nimport * as $array from \"./util/Array\";\nimport * as $object from \"./util/Object\";\nimport * as $utils from \"./util/Utils\";\nimport * as $type from \"./util/Type\";\nimport en from \"../../locales/en\";\n\nfunction rAF(fps, callback) {\n  if (fps == null) {\n    requestAnimationFrame(callback);\n  } else {\n    setTimeout(function () {\n      requestAnimationFrame(callback);\n    }, 1000 / fps);\n  }\n} // TODO implement Disposer\n\n/**\r\n * Root element of the chart.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/getting-started/#Root_element} for more info\r\n */\n\n\nvar Root =\n/** @class */\nfunction () {\n  function Root(id, settings, isReal) {\n    if (settings === void 0) {\n      settings = {};\n    }\n    /**\r\n     * A reference to original chart container (div element).\r\n     */\n\n\n    Object.defineProperty(this, \"dom\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_inner\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_isDirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_isDirtyParents\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_dirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_dirtyParents\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_dirtyBounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_dirtyPositions\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"_ticker\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"_tickers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    /**\r\n     * Root's event dispatcher.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n     */\n\n    Object.defineProperty(this, \"events\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new EventDispatcher()\n    });\n    /**\r\n     * @ignore\r\n     * @todo needs description\r\n     */\n\n    Object.defineProperty(this, \"animationTime\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(this, \"_animations\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_renderer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_rootContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Main content container.\r\n     */\n\n    Object.defineProperty(this, \"container\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A [[Container]] used to display tooltips in.\r\n     */\n\n    Object.defineProperty(this, \"tooltipContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tooltipContainerSettings\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tooltip\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // Locale-related\n\n    /**\r\n     * @ignore\r\n     */\n\n    Object.defineProperty(this, \"language\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Language.new(this, {})\n    });\n    /**\r\n     * Locale used by the chart.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/locales/}\r\n     */\n\n    Object.defineProperty(this, \"locale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: en\n    }); // Date-time related\n\n    /**\r\n     * Use UTC when formatting date/time.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/#UTC_and_time_zones} for more info\r\n     */\n\n    Object.defineProperty(this, \"utc\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * If set, will format date/time in specific time zone.\r\n     *\r\n     * The value should be named time zone, e.g.:\r\n     * `\"America/Vancouver\"`, `\"Australia/Sydney\"`, `\"UTC\"`.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Time_zone} for more info\r\n     * @since 5.1.0\r\n     */\n\n    Object.defineProperty(this, \"timezone\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * The maximum FPS that the Root will run at.\r\n     *\r\n     * If `undefined` it will run at the highest FPS.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Performance} for more info\r\n     */\n\n    Object.defineProperty(this, \"fps\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Number formatter.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info\r\n     */\n\n    Object.defineProperty(this, \"numberFormatter\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: NumberFormatter.new(this, {})\n    });\n    /**\r\n     * Date/time formatter.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\r\n     */\n\n    Object.defineProperty(this, \"dateFormatter\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: DateFormatter.new(this, {})\n    });\n    /**\r\n     * Duration formatter.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-dates/} for more info\r\n     */\n\n    Object.defineProperty(this, \"durationFormatter\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: DurationFormatter.new(this, {})\n    }); // Accessibility\n\n    /**\r\n     * Global tab index for using for the whole chart\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info\r\n     */\n\n    Object.defineProperty(this, \"tabindex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    }); //@todo maybe make this better\n\n    Object.defineProperty(this, \"_tabindexes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_focusElementDirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_focusElementContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_focusedSprite\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_isShift\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_keyboardDragPoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tooltipElementContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_readerAlertElement\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_logo\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tooltipDiv\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Used for dynamically-created CSS and JavaScript with strict source policies.\r\n     */\n\n    Object.defineProperty(this, \"nonce\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * Special color set to be used for various controls.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/#Interface_colors} for more info\r\n     */\n\n    Object.defineProperty(this, \"interfaceColors\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * An instance of vertical layout object that can be used to set `layout` setting\r\n     * of a [[Container]].\r\n     *\r\n     * @default VerticalLayout.new()\r\n     */\n\n    Object.defineProperty(this, \"verticalLayout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: VerticalLayout.new(this, {})\n    });\n    /**\r\n     * An instance of horizontal layout object that can be used to set `layout` setting\r\n     * of a [[Container]].\r\n     *\r\n     * @default HorizontalLayout.new()\r\n     */\n\n    Object.defineProperty(this, \"horizontalLayout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: HorizontalLayout.new(this, {})\n    });\n    /**\r\n     * An instance of grid layout object that can be used to set `layout` setting\r\n     * of a [[Container]].\r\n     *\r\n     * @default VerticalLayout.new()\r\n     */\n\n    Object.defineProperty(this, \"gridLayout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: GridLayout.new(this, {})\n    });\n    /**\r\n     * Indicates whether chart should resized automatically when parent container\r\n     * width and/or height changes.\r\n     *\r\n     * If disabled (`autoResize = false`) you can make the chart resize manually\r\n     * by calling root element's `resize()` method.\r\n     */\n\n    Object.defineProperty(this, \"autoResize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"_fontHash\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"\"\n    });\n    Object.defineProperty(this, \"_isDisposed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"_disposers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_resizeSensorDisposer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_tooltips\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"_htmlElementContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_htmlEnabledContainers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n\n    if (!isReal) {\n      throw new Error(\"You cannot use `new Class()`, instead use `Class.new()`\");\n    }\n\n    if (settings.useSafeResolution == null) {\n      settings.useSafeResolution = true;\n    }\n\n    var resolution;\n\n    if (settings.useSafeResolution) {\n      resolution = $utils.getSafeResolution();\n    }\n\n    this._renderer = new CanvasRenderer(resolution);\n    var dom;\n\n    if (id instanceof HTMLElement) {\n      dom = id;\n    } else {\n      dom = document.getElementById(id);\n    }\n\n    $array.each(registry.rootElements, function (root) {\n      if (root.dom === dom) {\n        throw new Error(\"You cannot have multiple Roots on the same DOM node\");\n      }\n    });\n    this.interfaceColors = InterfaceColors.new(this, {});\n\n    if (dom === null) {\n      throw new Error(\"Could not find HTML element with id `\" + id + \"`\");\n    }\n\n    this.dom = dom;\n    var inner = document.createElement(\"div\");\n    inner.style.position = \"relative\";\n    inner.style.height = \"100%\";\n    dom.appendChild(inner);\n    var tooltipContainerBounds = settings.tooltipContainerBounds;\n\n    if (tooltipContainerBounds) {\n      this._tooltipContainerSettings = tooltipContainerBounds;\n    }\n\n    this._inner = inner;\n\n    this._updateComputedStyles();\n\n    registry.rootElements.push(this);\n  }\n\n  Object.defineProperty(Root, \"new\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (id, settings) {\n      var root = new Root(id, settings, true);\n\n      root._init();\n\n      return root;\n    }\n  });\n  Object.defineProperty(Root.prototype, \"moveDOM\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (id) {\n      var dom;\n\n      if (id instanceof HTMLElement) {\n        dom = id;\n      } else {\n        dom = document.getElementById(id);\n      }\n\n      if (dom) {\n        while (this.dom.childNodes.length > 0) {\n          dom.appendChild(this.dom.childNodes[0]);\n        }\n\n        this.dom = dom;\n\n        this._initResizeSensor();\n\n        this.resize();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_handleLogo\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this._logo) {\n        var w = this.dom.offsetWidth;\n        var h = this.dom.offsetHeight;\n\n        if (w <= 150 || h <= 60) {\n          this._logo.hide();\n        } else {\n          this._logo.show();\n        }\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_showBranding\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._logo) {\n        var logo = this.tooltipContainer.children.push(Container.new(this, {\n          interactive: true,\n          interactiveChildren: false,\n          position: \"absolute\",\n          setStateOnChildren: true,\n          paddingTop: 9,\n          paddingRight: 9,\n          paddingBottom: 9,\n          paddingLeft: 9,\n          scale: .6,\n          y: percent(100),\n          centerY: p100,\n          tooltipText: \"Created using amCharts 5\",\n          tooltipX: p100,\n          cursorOverStyle: \"pointer\",\n          background: Rectangle.new(this, {\n            fill: color(0x474758),\n            fillOpacity: 0,\n            tooltipY: 5\n          })\n        }));\n        var tooltip = Tooltip.new(this, {\n          pointerOrientation: \"horizontal\",\n          paddingTop: 4,\n          paddingRight: 7,\n          paddingBottom: 4,\n          paddingLeft: 7\n        });\n        tooltip.label.setAll({\n          fontSize: 12\n        });\n        tooltip.get(\"background\").setAll({\n          fill: this.interfaceColors.get(\"background\"),\n          stroke: this.interfaceColors.get(\"grid\"),\n          strokeOpacity: 0.3\n        });\n        logo.set(\"tooltip\", tooltip);\n        logo.events.on(\"click\", function () {\n          window.open(\"https://www.amcharts.com/\", \"_blank\");\n        });\n        logo.states.create(\"hover\", {});\n        var m = logo.children.push(Graphics.new(this, {\n          stroke: color(0xcccccc),\n          strokeWidth: 3,\n          svgPath: \"M5 25 L13 25h13.6c3.4 0 6 0 10.3-4.3s5.2-12 8.6-12c3.4 0 4.3 8.6 7.7 8.6M83.4 25H79.8c-3.4 0-6 0-10.3-4.3s-5.2-12-8.6-12-4.3 8.6-7.7 8.6\"\n        }));\n        m.states.create(\"hover\", {\n          stroke: color(0x3CABFF)\n        });\n        var a = logo.children.push(Graphics.new(this, {\n          stroke: color(0x888888),\n          strokeWidth: 3,\n          svgPath: \"M83.4 25h-31C37 25 39.5 4.4 28.4 4.4S18.9 24.2 4.3 25H0\"\n        }));\n        a.states.create(\"hover\", {\n          stroke: color(0x474758)\n        }); //logo.set(\"tooltip\", this._tooltip);\n        //logo.setPrivate(\"tooltipTarget\", logo.get(\"background\"));\n\n        this._logo = logo;\n\n        this._handleLogo();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_init\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var renderer = this._renderer;\n      var rect = this.dom.getBoundingClientRect();\n      var width = Math.floor(rect.width);\n      var height = Math.floor(rect.height);\n      var rootContainer = Container.new(this, {\n        visible: true,\n        width: width,\n        height: height\n      });\n      this._rootContainer = rootContainer;\n\n      this._rootContainer._defaultThemes.push(DefaultTheme.new(this));\n\n      var container = rootContainer.children.push(Container.new(this, {\n        visible: true,\n        width: p100,\n        height: p100\n      }));\n      this.container = container;\n      renderer.resize(width, height); //@todo: better appendChild - refer\n\n      this._inner.appendChild(renderer.view); // TODO: TMP TMP TMP for testing only, remove\n      //renderer.debugGhostView = true;\n\n\n      this._initResizeSensor(); // HTML content holder\n\n\n      this._htmlElementContainer = document.createElement(\"div\");\n      this._htmlElementContainer.className = \"am5-html-container\";\n      this._htmlElementContainer.style.position = \"absolute\";\n      this._htmlElementContainer.style.pointerEvents = \"none\";\n\n      if (!this._tooltipContainerSettings) {\n        this._htmlElementContainer.style.overflow = \"hidden\";\n      }\n\n      this._inner.appendChild(this._htmlElementContainer); // Create element which is used to make announcements to screen reader\n\n\n      var readerAlertElement = document.createElement(\"div\");\n      readerAlertElement.className = \"am5-reader-container\";\n      readerAlertElement.setAttribute(\"role\", \"alert\");\n      readerAlertElement.style.zIndex = \"-100000\";\n      readerAlertElement.style.opacity = \"0\";\n      readerAlertElement.style.position = \"absolute\";\n      readerAlertElement.style.top = \"0\";\n      this._readerAlertElement = readerAlertElement;\n\n      this._inner.appendChild(this._readerAlertElement);\n\n      var focusElementContainer = document.createElement(\"div\");\n      focusElementContainer.className = \"am5-focus-container\";\n      focusElementContainer.style.position = \"absolute\";\n      focusElementContainer.style.pointerEvents = \"none\";\n      focusElementContainer.style.top = \"0px\";\n      focusElementContainer.style.left = \"0px\";\n      focusElementContainer.style.overflow = \"hidden\";\n      focusElementContainer.style.width = width + \"px\";\n      focusElementContainer.style.height = height + \"px\";\n      focusElementContainer.setAttribute(\"role\", \"application\");\n      $utils.setInteractive(focusElementContainer, false);\n      this._focusElementContainer = focusElementContainer;\n\n      this._inner.appendChild(this._focusElementContainer);\n\n      this._tooltipElementContainer = document.createElement(\"div\");\n      this._tooltipElementContainer.className = \"am5-tooltip-container\";\n\n      this._inner.appendChild(this._tooltipElementContainer); // Add keyboard events for accessibility, e.g. simulating drag with arrow\n      // keys and click with ENTER\n\n\n      if ($utils.supports(\"keyboardevents\")) {\n        this._disposers.push($utils.addEventListener(window, \"keydown\", function (ev) {\n          if (ev.keyCode == 16) {\n            _this._isShift = true;\n          }\n        }));\n\n        this._disposers.push($utils.addEventListener(window, \"keyup\", function (ev) {\n          if (ev.keyCode == 16) {\n            _this._isShift = false;\n          }\n        }));\n\n        this._disposers.push($utils.addEventListener(focusElementContainer, \"keydown\", function (ev) {\n          var focusedSprite = _this._focusedSprite;\n\n          if (focusedSprite) {\n            if (ev.keyCode == 27) {\n              // ESC pressed - lose current focus\n              $utils.blur();\n              _this._focusedSprite = undefined;\n            }\n\n            var dragOffsetX = 0;\n            var dragOffsetY = 0; // TODO: figure out if using bogus MouseEvent is fine, or it will\n            // fail on some platforms\n\n            switch (ev.keyCode) {\n              case 13:\n                ev.preventDefault();\n                var downEvent = renderer.getEvent(new MouseEvent(\"click\"));\n                focusedSprite.events.dispatch(\"click\", {\n                  type: \"click\",\n                  originalEvent: downEvent.event,\n                  point: downEvent.point,\n                  simulated: true,\n                  target: focusedSprite\n                });\n                return;\n\n              case 37:\n                dragOffsetX = -6;\n                break;\n\n              case 39:\n                dragOffsetX = 6;\n                break;\n\n              case 38:\n                dragOffsetY = -6;\n                break;\n\n              case 40:\n                dragOffsetY = 6;\n                break;\n\n              default:\n                return;\n            }\n\n            if (dragOffsetX != 0 || dragOffsetY != 0) {\n              ev.preventDefault();\n\n              if (!focusedSprite.isDragging()) {\n                // Start dragging\n                _this._keyboardDragPoint = {\n                  x: 0,\n                  y: 0\n                };\n                var downEvent = renderer.getEvent(new MouseEvent(\"mousedown\", {\n                  clientX: 0,\n                  clientY: 0\n                }));\n\n                if (focusedSprite.events.isEnabled(\"pointerdown\")) {\n                  focusedSprite.events.dispatch(\"pointerdown\", {\n                    type: \"pointerdown\",\n                    originalEvent: downEvent.event,\n                    point: downEvent.point,\n                    simulated: true,\n                    target: focusedSprite\n                  });\n                }\n              } else {// Move focus marker\n                //this._positionFocusElement(focusedSprite);\n              } // Move incrementally\n\n\n              var dragPoint = _this._keyboardDragPoint;\n              dragPoint.x += dragOffsetX;\n              dragPoint.y += dragOffsetY;\n              var moveEvent = renderer.getEvent(new MouseEvent(\"mousemove\", {\n                clientX: dragPoint.x,\n                clientY: dragPoint.y\n              }), false);\n\n              if (focusedSprite.events.isEnabled(\"globalpointermove\")) {\n                focusedSprite.events.dispatch(\"globalpointermove\", {\n                  type: \"globalpointermove\",\n                  originalEvent: moveEvent.event,\n                  point: moveEvent.point,\n                  simulated: true,\n                  target: focusedSprite\n                });\n              }\n            }\n          }\n        }));\n\n        this._disposers.push($utils.addEventListener(focusElementContainer, \"keyup\", function (ev) {\n          if (_this._focusedSprite) {\n            var focusedSprite = _this._focusedSprite;\n            var keyCode = ev.keyCode;\n\n            switch (keyCode) {\n              case 37:\n              case 39:\n              case 38:\n              case 40:\n                if (focusedSprite.isDragging()) {\n                  // Simulate drag stop\n                  var dragPoint = _this._keyboardDragPoint;\n                  var upEvent = renderer.getEvent(new MouseEvent(\"mouseup\", {\n                    clientX: dragPoint.x,\n                    clientY: dragPoint.y\n                  }));\n\n                  if (focusedSprite.events.isEnabled(\"globalpointerup\")) {\n                    focusedSprite.events.dispatch(\"globalpointerup\", {\n                      type: \"globalpointerup\",\n                      originalEvent: upEvent.event,\n                      point: upEvent.point,\n                      simulated: true,\n                      target: focusedSprite\n                    });\n                  } //this._positionFocusElement(focusedSprite);\n\n\n                  _this._keyboardDragPoint = undefined; // @todo dispatch mouseup event instead of calling dragStop?\n                  // this._dispatchEvent(\"globalpointerup\", target, upEvent);\n\n                  return;\n                } else if (focusedSprite.get(\"focusableGroup\")) {\n                  // Find next item in focusable group\n                  var group_1 = focusedSprite.get(\"focusableGroup\");\n\n                  var items = _this._tabindexes.filter(function (item) {\n                    return item.get(\"focusableGroup\") == group_1;\n                  });\n\n                  var index = items.indexOf(focusedSprite);\n                  var lastIndex = items.length - 1;\n                  index += keyCode == 39 || keyCode == 40 ? 1 : -1;\n\n                  if (index < 0) {\n                    index = lastIndex;\n                  } else if (index > lastIndex) {\n                    index = 0;\n                  }\n\n                  $utils.focus(items[index].getPrivate(\"focusElement\").dom);\n                }\n\n                break;\n            }\n          }\n        }));\n      }\n\n      this._startTicker();\n\n      this.setThemes([]);\n\n      this._addTooltip();\n\n      if (!this._hasLicense()) {\n        this._showBranding();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_initResizeSensor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      if (this._resizeSensorDisposer) {\n        this._resizeSensorDisposer.dispose();\n      }\n\n      this._resizeSensorDisposer = new ResizeSensor(this.dom, function () {\n        if (_this.autoResize) {\n          _this.resize();\n        }\n      });\n\n      this._disposers.push(this._resizeSensorDisposer);\n    }\n  });\n  /**\r\n   * If automatic resizing of char is disabled (`root.autoResize = false`), it\r\n   * can be resized manually by calling this method.\r\n   */\n\n  Object.defineProperty(Root.prototype, \"resize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var dom = this.dom;\n      var rect = dom.getBoundingClientRect();\n      var w = Math.floor(rect.width);\n      var h = Math.floor(rect.height);\n\n      if (w > 0 && h > 0) {\n        var htmlElementContainer = this._htmlElementContainer;\n        htmlElementContainer.style.width = w + \"px\";\n        htmlElementContainer.style.height = h + \"px\";\n        var focusElementContainer = this._focusElementContainer;\n        focusElementContainer.style.width = w + \"px\";\n        focusElementContainer.style.height = h + \"px\";\n\n        this._renderer.resize(w, h);\n\n        var rootContainer = this._rootContainer;\n        rootContainer.setPrivate(\"width\", w);\n        rootContainer.setPrivate(\"height\", h);\n\n        this._render();\n\n        this._handleLogo();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._renderer.render(this._rootContainer._display);\n\n      if (this._focusElementDirty) {\n        this._updateCurrentFocus();\n\n        this._focusElementDirty = false;\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_runTickers\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (currentTime) {\n      $array.each(this._tickers, function (f) {\n        f(currentTime);\n      });\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_runAnimations\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (currentTime) {\n      $array.keepIf(this._animations, function (animation) {\n        return animation._runAnimation(currentTime);\n      });\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_runDirties\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this; //console.log(\"tick **************************************************************\");\n\n\n      var allParents = {};\n\n      while (this._isDirtyParents) {\n        // This must be before calling _prepareChildren\n        this._isDirtyParents = false;\n        $object.keys(this._dirtyParents).forEach(function (key) {\n          var parent = _this._dirtyParents[key];\n          delete _this._dirtyParents[key];\n\n          if (!parent.isDisposed()) {\n            allParents[parent.uid] = parent;\n\n            parent._prepareChildren();\n          }\n        });\n      }\n\n      $object.keys(allParents).forEach(function (key) {\n        allParents[key]._updateChildren();\n      });\n      var objects = []; //\t\tconsole.log(\"_beforeChanged\")\n\n      $object.keys(this._dirty).forEach(function (key) {\n        var entity = _this._dirty[key];\n\n        if (entity.isDisposed()) {\n          delete _this._dirty[entity.uid];\n        } else {\n          objects.push(entity);\n\n          entity._beforeChanged();\n        }\n      }); //\t\tconsole.log(\"_changed\")\n\n      objects.forEach(function (entity) {\n        entity._changed();\n\n        delete _this._dirty[entity.uid];\n\n        entity._clearDirty();\n      });\n      this._isDirty = false;\n      var depths = {};\n      var bounds = [];\n      $object.keys(this._dirtyBounds).forEach(function (key) {\n        var entity = _this._dirtyBounds[key];\n        delete _this._dirtyBounds[key];\n\n        if (!entity.isDisposed()) {\n          depths[entity.uid] = entity.depth();\n          bounds.push(entity);\n        }\n      }); // High depth -> low depth\n\n      bounds.sort(function (x, y) {\n        return $order.compare(depths[y.uid], depths[x.uid]);\n      }); //\t\tconsole.log(\"_updateBounds\")\n\n      bounds.forEach(function (entity) {\n        entity._updateBounds();\n      }); //\t\tconsole.log(\"_updatePosition\")\n\n      var dirtyPositions = this._dirtyPositions;\n      $object.keys(dirtyPositions).forEach(function (key) {\n        var sprite = dirtyPositions[key];\n        delete dirtyPositions[key];\n\n        if (!sprite.isDisposed()) {\n          sprite._updatePosition();\n        }\n      }); //\t\tconsole.log(\"_afterChanged\")\n\n      objects.forEach(function (entity) {\n        entity._afterChanged();\n      });\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_renderFrame\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (currentTime) {\n      if (this.events.isEnabled(\"framestarted\")) {\n        this.events.dispatch(\"framestarted\", {\n          type: \"framestarted\",\n          target: this,\n          timestamp: currentTime\n        });\n      }\n\n      this._checkComputedStyles();\n\n      this._runTickers(currentTime);\n\n      this._runAnimations(currentTime);\n\n      this._runDirties();\n\n      this._render();\n\n      this._positionHTMLElements();\n\n      if (this.events.isEnabled(\"frameended\")) {\n        this.events.dispatch(\"frameended\", {\n          type: \"frameended\",\n          target: this,\n          timestamp: currentTime\n        });\n      }\n\n      return this._tickers.length === 0 && this._animations.length === 0 && !this._isDirty;\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_runTicker\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (currentTime) {\n      if (!this.isDisposed()) {\n        this.animationTime = currentTime;\n\n        var done = this._renderFrame(currentTime); // No more work to do\n\n\n        if (done) {\n          this._ticker = null;\n          this.animationTime = null;\n        } else {\n          rAF(this.fps, this._ticker);\n        }\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_runTickerNow\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this.isDisposed()) {\n        for (;;) {\n          var currentTime = performance.now();\n          this.animationTime = currentTime;\n\n          var done = this._renderFrame(currentTime);\n\n          if (done) {\n            this.animationTime = null;\n            break;\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_startTicker\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      if (this._ticker === null) {\n        this.animationTime = null;\n\n        this._ticker = function (currentTime) {\n          _this._runTicker(currentTime);\n        };\n\n        rAF(this.fps, this._ticker);\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_addDirtyEntity\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (entity) {\n      if (this._dirty[entity.uid] === undefined) {\n        this._isDirty = true;\n        this._dirty[entity.uid] = entity;\n\n        this._startTicker();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_addDirtyParent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parent) {\n      if (this._dirtyParents[parent.uid] === undefined) {\n        this._isDirty = true;\n        this._isDirtyParents = true;\n        this._dirtyParents[parent.uid] = parent;\n\n        this._startTicker();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_addDirtyBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (entity) {\n      if (this._dirtyBounds[entity.uid] === undefined) {\n        this._isDirty = true;\n        this._dirtyBounds[entity.uid] = entity;\n\n        this._startTicker();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_addDirtyPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (sprite) {\n      if (this._dirtyPositions[sprite.uid] === undefined) {\n        this._isDirty = true;\n        this._dirtyPositions[sprite.uid] = sprite;\n\n        this._startTicker();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_addAnimation\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (animation) {\n      // TODO use numeric id instead\n      if (this._animations.indexOf(animation) === -1) {\n        this._animations.push(animation);\n\n        this._startTicker();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_markDirty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._isDirty = true;\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_markDirtyRedraw\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this.events.once(\"frameended\", function () {\n        _this._isDirty = true;\n\n        _this._startTicker();\n      });\n    }\n  });\n  Object.defineProperty(Root.prototype, \"eachFrame\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (f) {\n      var _this = this;\n\n      this._tickers.push(f);\n\n      this._startTicker();\n\n      return new Disposer(function () {\n        $array.removeFirst(_this._tickers, f);\n      });\n    }\n  });\n  Object.defineProperty(Root.prototype, \"markDirtyGlobal\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (container) {\n      var _this = this;\n\n      if (!container) {\n        container = this.container;\n      }\n\n      console.log(this.width());\n      container.walkChildren(function (child) {\n        if (child instanceof Container) {\n          _this.markDirtyGlobal(child);\n        }\n\n        child.markDirty();\n        child.markDirtyBounds();\n      });\n    }\n  });\n  /**\r\n   * Returns width of the target container, in pixels.\r\n   *\r\n   * @return Width\r\n   */\n\n  Object.defineProperty(Root.prototype, \"width\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // TODO make this more efficient, maybe just return the renderer's width ?\n      return Math.floor(this.dom.getBoundingClientRect().width);\n    }\n  });\n  /**\r\n   * Returns height of the target container, in pixels.\r\n   *\r\n   * @return Height\r\n   */\n\n  Object.defineProperty(Root.prototype, \"height\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // TODO make this more efficient, maybe just return the renderer's height ?\n      return Math.floor(this.dom.getBoundingClientRect().height);\n    }\n  });\n  /**\r\n   * Disposes root and all the content in it.\r\n   */\n\n  Object.defineProperty(Root.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._isDisposed) {\n        this._isDisposed = true;\n\n        this._rootContainer.dispose();\n\n        this._renderer.dispose();\n\n        this.horizontalLayout.dispose();\n        this.verticalLayout.dispose();\n        this.interfaceColors.dispose();\n        $array.each(this._disposers, function (x) {\n          x.dispose();\n        });\n\n        if (this._inner) {\n          $utils.removeElement(this._inner);\n        }\n\n        $array.remove(registry.rootElements, this);\n      }\n    }\n  });\n  /**\r\n   * Returns `true` if root element is disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n\n  Object.defineProperty(Root.prototype, \"isDisposed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._isDisposed;\n    }\n  });\n  /**\r\n   * Triggers screen reader read out a message.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/accessibility/} for more info\r\n   * @param  text  Alert text\r\n   */\n\n  Object.defineProperty(Root.prototype, \"readerAlert\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      this._readerAlertElement.innerHTML = $utils.stripTags(text);\n    }\n  });\n  /**\r\n   * Sets themes to be used for the chart.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/themes/} for more info\r\n   * @param  themes  A list of themes\r\n   */\n\n  Object.defineProperty(Root.prototype, \"setThemes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (themes) {\n      this._rootContainer.set(\"themes\", themes); // otherwise new themes are not applied\n\n\n      var tooltipContainer = this.tooltipContainer;\n\n      if (tooltipContainer) {\n        tooltipContainer._applyThemes();\n      } // @todo review this\n\n\n      var interfaceColors = this.interfaceColors;\n\n      if (interfaceColors) {\n        interfaceColors._applyThemes();\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_addTooltip\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this.tooltipContainer) {\n        var tooltipContainer = this._rootContainer.children.push(Container.new(this, {\n          position: \"absolute\",\n          isMeasured: false,\n          width: p100,\n          height: p100,\n          layer: this._tooltipContainerSettings ? 35 : 30,\n          layerMargin: this._tooltipContainerSettings ? this._tooltipContainerSettings : undefined\n        }));\n\n        this.tooltipContainer = tooltipContainer;\n        var tooltip = Tooltip.new(this, {});\n        this.container.set(\"tooltip\", tooltip);\n        tooltip.hide(0);\n        this._tooltip = tooltip;\n      }\n    }\n  });\n  /**\r\n   * Accesibility\r\n   */\n\n  Object.defineProperty(Root.prototype, \"_registerTabindexOrder\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      if (target.get(\"focusable\")) {\n        $array.pushOne(this._tabindexes, target);\n      } else {\n        $array.remove(this._tabindexes, target);\n      }\n\n      this._invalidateTabindexes();\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_unregisterTabindexOrder\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      $array.remove(this._tabindexes, target);\n\n      this._invalidateTabindexes();\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_invalidateTabindexes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._tabindexes.sort(function (a, b) {\n        var aindex = a.get(\"tabindexOrder\", 0);\n        var bindex = b.get(\"tabindexOrder\", 0);\n\n        if (aindex == bindex) {\n          return 0;\n        } else if (aindex > bindex) {\n          return 1;\n        } else {\n          return -1;\n        }\n      });\n\n      var groups = [];\n      $array.each(this._tabindexes, function (item, index) {\n        if (!item.getPrivate(\"focusElement\")) {\n          _this._makeFocusElement(index, item);\n        } else {\n          _this._moveFocusElement(index, item);\n        }\n\n        var group = item.get(\"focusableGroup\");\n\n        if (group) {\n          if (groups.indexOf(group) !== -1) {\n            // Non-first element in the group, make it not directly focusable\n            item.getPrivate(\"focusElement\").dom.setAttribute(\"tabindex\", \"-1\");\n          } else {\n            groups.push(group);\n          }\n        }\n      });\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_updateCurrentFocus\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this._focusedSprite) {\n        this._decorateFocusElement(this._focusedSprite);\n\n        this._positionFocusElement(this._focusedSprite);\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_decorateFocusElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target, focusElement) {\n      // Decorate with proper accessibility attributes\n      if (!focusElement) {\n        focusElement = target.getPrivate(\"focusElement\").dom;\n      }\n\n      if (!focusElement) {\n        return;\n      }\n\n      if (target.get(\"visible\") && target.get(\"role\") != \"tooltip\" && !target.isHidden()) {\n        if (focusElement.getAttribute(\"tabindex\") != \"-1\") {\n          focusElement.setAttribute(\"tabindex\", \"\" + this.tabindex);\n        }\n      } else {\n        focusElement.removeAttribute(\"tabindex\");\n      }\n\n      var role = target.get(\"role\");\n\n      if (role) {\n        focusElement.setAttribute(\"role\", role);\n      } else {\n        focusElement.removeAttribute(\"role\");\n      }\n\n      var ariaLabel = target.get(\"ariaLabel\");\n\n      if (ariaLabel) {\n        var label = populateString(target, ariaLabel);\n        focusElement.setAttribute(\"aria-label\", label);\n      } else {\n        focusElement.removeAttribute(\"aria-label\");\n      }\n\n      var ariaLive = target.get(\"ariaLive\");\n\n      if (ariaLive) {\n        focusElement.setAttribute(\"aria-live\", ariaLive);\n      } else {\n        focusElement.removeAttribute(\"aria-live\");\n      }\n\n      var ariaChecked = target.get(\"ariaChecked\");\n\n      if (ariaChecked != null) {\n        focusElement.setAttribute(\"aria-checked\", ariaChecked ? \"true\" : \"false\");\n      } else {\n        focusElement.removeAttribute(\"aria-checked\");\n      }\n\n      if (target.get(\"ariaHidden\")) {\n        focusElement.setAttribute(\"aria-hidden\", \"hidden\");\n      } else {\n        focusElement.removeAttribute(\"aria-hidden\");\n      }\n\n      var ariaOrientation = target.get(\"ariaOrientation\");\n\n      if (ariaOrientation) {\n        focusElement.setAttribute(\"aria-orientation\", ariaOrientation);\n      } else {\n        focusElement.removeAttribute(\"aria-orientation\");\n      }\n\n      var ariaValueNow = target.get(\"ariaValueNow\");\n\n      if (ariaValueNow) {\n        focusElement.setAttribute(\"aria-valuenow\", ariaValueNow);\n      } else {\n        focusElement.removeAttribute(\"aria-valuenow\");\n      }\n\n      var ariaValueMin = target.get(\"ariaValueMin\");\n\n      if (ariaValueMin) {\n        focusElement.setAttribute(\"aria-valuemin\", ariaValueMin);\n      } else {\n        focusElement.removeAttribute(\"aria-valuemin\");\n      }\n\n      var ariaValueMax = target.get(\"ariaValueMax\");\n\n      if (ariaValueMax) {\n        focusElement.setAttribute(\"aria-valuemax\", ariaValueMax);\n      } else {\n        focusElement.removeAttribute(\"aria-valuemax\");\n      }\n\n      var ariaValueText = target.get(\"ariaValueText\");\n\n      if (ariaValueText) {\n        focusElement.setAttribute(\"aria-valuetext\", ariaValueText);\n      } else {\n        focusElement.removeAttribute(\"aria-valuetext\");\n      }\n\n      var ariaControls = target.get(\"ariaControls\");\n\n      if (ariaControls) {\n        focusElement.setAttribute(\"aria-controls\", ariaControls);\n      } else {\n        focusElement.removeAttribute(\"aria-controls\");\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_makeFocusElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index, target) {\n      var _this = this;\n\n      if (target.getPrivate(\"focusElement\")) {\n        return;\n      } // Init\n\n\n      var focusElement = document.createElement(\"div\");\n\n      if (target.get(\"role\") != \"tooltip\") {\n        focusElement.tabIndex = this.tabindex;\n      }\n\n      focusElement.style.position = \"absolute\";\n      $utils.setInteractive(focusElement, false);\n      var disposers = [];\n      target.setPrivate(\"focusElement\", {\n        dom: focusElement,\n        disposers: disposers\n      });\n\n      this._decorateFocusElement(target);\n\n      disposers.push($utils.addEventListener(focusElement, \"focus\", function (ev) {\n        _this._handleFocus(ev, index);\n      }));\n      disposers.push($utils.addEventListener(focusElement, \"blur\", function (ev) {\n        _this._handleBlur(ev, index);\n      }));\n\n      this._moveFocusElement(index, target);\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_removeFocusElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      $array.remove(this._tabindexes, target);\n      var focusElement = target.getPrivate(\"focusElement\");\n\n      if (focusElement) {\n        var container = this._focusElementContainer;\n        container.removeChild(focusElement.dom);\n        $array.each(focusElement.disposers, function (x) {\n          x.dispose();\n        });\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_hideFocusElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      var focusElement = target.getPrivate(\"focusElement\");\n      focusElement.dom.style.display = \"none\";\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_moveFocusElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (index, target) {\n      // Get container\n      var container = this._focusElementContainer;\n      var focusElement = target.getPrivate(\"focusElement\").dom;\n\n      if (focusElement === this._focusElementContainer.children[index]) {\n        // Nothing to do\n        return;\n      }\n\n      var next = this._focusElementContainer.children[index + 1];\n\n      if (next) {\n        container.insertBefore(focusElement, next);\n      } else {\n        container.append(focusElement);\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_positionFocusElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      var bounds = target.globalBounds();\n      var width = bounds.right == bounds.left ? target.width() : bounds.right - bounds.left;\n      var height = bounds.top == bounds.bottom ? target.height() : bounds.bottom - bounds.top;\n      var focusElement = target.getPrivate(\"focusElement\").dom;\n      focusElement.style.top = bounds.top - 2 + \"px\";\n      focusElement.style.left = bounds.left - 2 + \"px\";\n      focusElement.style.width = width + 4 + \"px\";\n      focusElement.style.height = height + 4 + \"px\";\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_handleFocus\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (ev, index) {\n      // Get element\n      var focused = this._tabindexes[index]; // Jump over hidden elements\n\n      if (!focused.isVisibleDeep()) {\n        this._focusNext(ev.target, this._isShift ? -1 : 1);\n\n        return;\n      } // Size and position\n\n\n      this._positionFocusElement(focused); //this._decorateFocusElement(focused);\n\n\n      this._focusedSprite = focused;\n\n      if (focused.events.isEnabled(\"focus\")) {\n        focused.events.dispatch(\"focus\", {\n          type: \"focus\",\n          originalEvent: ev,\n          target: focused\n        });\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_focusNext\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (el, direction) {\n      var focusableElements = Array.from(document.querySelectorAll(['a[href]', 'area[href]', 'button:not([disabled])', 'details', 'input:not([disabled])', 'iframe:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', '[contentEditable=\"\"]', '[contentEditable=\"true\"]', '[contentEditable=\"TRUE\"]', '[tabindex]:not([tabindex^=\"-\"])' //':not([disabled])'\n      ].join(',')));\n      var index = focusableElements.indexOf(el) + direction;\n\n      if (index < 0) {\n        index = focusableElements.length - 1;\n      } else if (index >= focusableElements.length) {\n        index = 0;\n      }\n\n      focusableElements[index].focus();\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_handleBlur\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (ev, _index) {\n      var focused = this._focusedSprite;\n\n      if (focused && focused.events.isEnabled(\"blur\")) {\n        focused.events.dispatch(\"blur\", {\n          type: \"blur\",\n          originalEvent: ev,\n          target: focused\n        });\n      }\n\n      this._focusedSprite = undefined;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Root.prototype, \"updateTooltip\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      var text = $utils.stripTags(target._getText());\n      var tooltipElement = target.getPrivate(\"tooltipElement\");\n\n      if (target.get(\"role\") == \"tooltip\" && text != \"\") {\n        if (!tooltipElement) {\n          tooltipElement = this._makeTooltipElement(target);\n        }\n\n        if (tooltipElement.innerHTML != text) {\n          tooltipElement.innerHTML = text;\n        }\n      } else if (tooltipElement) {\n        tooltipElement.remove();\n        target.removePrivate(\"tooltipElement\");\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_makeTooltipElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      var container = this._tooltipElementContainer;\n      var tooltipElement = document.createElement(\"div\");\n      tooltipElement.style.position = \"absolute\";\n      tooltipElement.style.top = \"-1000000px\";\n      tooltipElement.style.opacity = \"0.0000001\";\n      $utils.setInteractive(tooltipElement, false);\n\n      this._decorateFocusElement(target, tooltipElement);\n\n      container.append(tooltipElement);\n      target.setPrivate(\"tooltipElement\", tooltipElement);\n      return tooltipElement;\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_invalidateAccessibility\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      this._focusElementDirty = true;\n      var focusElement = target.getPrivate(\"focusElement\");\n\n      if (target.get(\"focusable\")) {\n        if (focusElement) {\n          this._decorateFocusElement(target);\n\n          this._positionFocusElement(target);\n        } // else {\n        // \tthis._renderer._makeFocusElement(0, this);\n        // }\n\n      } else if (focusElement) {\n        this._removeFocusElement(target);\n      } //this.updateCurrentFocus();\n\n    }\n  });\n  /**\r\n   * Returns `true` if `target` is currently focused.\r\n   *\r\n   * @param   target  Target\r\n   * @return          Focused?\r\n   */\n\n  Object.defineProperty(Root.prototype, \"focused\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      return this._focusedSprite === target;\n    }\n  });\n  /**\r\n   * Converts document coordinates to coordinates withing root element.\r\n   *\r\n   * @param   point  Document point\r\n   * @return         Root point\r\n   */\n\n  Object.defineProperty(Root.prototype, \"documentPointToRoot\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      var bbox = this.dom.getBoundingClientRect();\n      return {\n        x: point.x - bbox.left,\n        y: point.y - bbox.top\n      };\n    }\n  });\n  /**\r\n   * Converts root coordinates to document\r\n   *\r\n   * @param   point  Document point\r\n   * @return         Root point\r\n   */\n\n  Object.defineProperty(Root.prototype, \"rootPointToDocument\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      var bbox = this.dom.getBoundingClientRect();\n      return {\n        x: point.x + bbox.left,\n        y: point.y + bbox.top\n      };\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Root.prototype, \"addDisposer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (disposer) {\n      this._disposers.push(disposer);\n\n      return disposer;\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_updateComputedStyles\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var styles = window.getComputedStyle(this.dom);\n      var fontHash = \"\";\n      $object.each(styles, function (key, val) {\n        if ($type.isString(key) && key.match(/^font/)) {\n          fontHash += val;\n        }\n      });\n      var changed = fontHash != this._fontHash;\n\n      if (changed) {\n        this._fontHash = fontHash;\n      }\n\n      return changed;\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_checkComputedStyles\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this._updateComputedStyles()) {\n        this._invalidateLabelBounds(this.container);\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_invalidateLabelBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      var _this = this;\n\n      if (target instanceof Container) {\n        target.children.each(function (child) {\n          _this._invalidateLabelBounds(child);\n        });\n      } else if (target instanceof Text) {\n        target.markDirtyBounds();\n      }\n    }\n  });\n  /**\r\n   * To all the clever heads out there. Yes, we did not make any attempts to\r\n   * scramble this.\r\n   *\r\n   * This is a part of a tool meant for our users to manage their commercial\r\n   * licenses for removal of amCharts branding from charts.\r\n   *\r\n   * The only legit way to do so is to purchase a commercial license for amCharts:\r\n   * https://www.amcharts.com/online-store/\r\n   *\r\n   * Removing or altering this code, or disabling amCharts branding in any other\r\n   * way is against the license and thus illegal.\r\n   */\n\n  Object.defineProperty(Root.prototype, \"_hasLicense\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      for (var i = 0; i < registry.licenses.length; i++) {\n        if (registry.licenses[i].match(/^AM5C.{5,}/i)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_licenseApplied\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this._logo) {\n        this._logo.set(\"forceHidden\", true);\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"debugGhostView\", {\n    /**\r\n     * @ignore\r\n     */\n    get: function () {\n      return this._renderer.debugGhostView;\n    },\n\n    /**\r\n     * @ignore\r\n     */\n    set: function (value) {\n      this._renderer.debugGhostView = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Root.prototype, \"tapToActivate\", {\n    /**\r\n     * @return Needs a tap to activate touch functions\r\n     */\n    get: function () {\n      return this._renderer.tapToActivate;\n    },\n\n    /**\r\n     * Set this to `true` if you need chart to require first a tap onto it before\r\n     * touch gesture related functionality like zoom/pan is turned on.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info\r\n     * @default false\r\n     * @since 5.2.9\r\n     * @param  value  Needs a tap to activate touch functions\r\n     */\n    set: function (value) {\n      this._renderer.tapToActivate = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Root.prototype, \"tapToActivateTimeout\", {\n    /**\r\n     * @return Timeout\r\n     */\n    get: function () {\n      return this._renderer.tapToActivateTimeout;\n    },\n\n    /**\r\n     * If `tapToActivate` is set to `true`, this setting will determine number\r\n     * of milliseconds the chart will stay \"active\", before releasing the\r\n     * controls back to the page.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/getting-started/root-element/#Touch_related_options} for more info\r\n     * @default 3000\r\n     * @since 5.2.9\r\n     * @param  value  Timeout\r\n     */\n    set: function (value) {\n      this._renderer.tapToActivateTimeout = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Root.prototype, \"_makeHTMLElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      var _this = this; // Get container\n\n\n      var container = this._htmlElementContainer; // Init\n\n      var htmlElement = document.createElement(\"div\");\n      target.setPrivate(\"htmlElement\", htmlElement); //htmlElement.tabIndex = this.tabindex;\n\n      htmlElement.style.position = \"absolute\";\n      htmlElement.style.overflow = \"auto\";\n      htmlElement.style.boxSizing = \"border-box\";\n      $utils.setInteractive(htmlElement, true); // Translate events\n\n      if (target.events.isEnabled(\"click\")) {\n        this._disposers.push($utils.addEventListener(htmlElement, \"click\", function (ev) {\n          var downEvent = _this._renderer.getEvent(ev);\n\n          target.events.dispatch(\"click\", {\n            type: \"click\",\n            originalEvent: downEvent.event,\n            point: downEvent.point,\n            simulated: false,\n            target: target\n          });\n        }));\n      }\n\n      this._positionHTMLElement(target);\n\n      container.append(htmlElement);\n      $array.pushOne(this._htmlEnabledContainers, target);\n      return htmlElement;\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_positionHTMLElements\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      $array.each(this._htmlEnabledContainers, function (target) {\n        _this._positionHTMLElement(target);\n      });\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_positionHTMLElement\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      var htmlElement = target.getPrivate(\"htmlElement\");\n\n      if (htmlElement) {\n        // Translate settings\n        var visualSettings = [\"paddingTop\", \"paddingRight\", \"paddingBottom\", \"paddingLeft\", \"minWidth\", \"minHeight\", \"maxWidth\", \"maxHeight\"];\n        $array.each(visualSettings, function (setting) {\n          var value = target.get(setting);\n\n          if (value) {\n            htmlElement.style[setting] = value + \"px\";\n          } else {\n            htmlElement.style[setting] = \"\";\n          }\n        }); // Deal with opacity\n\n        var opacity_1 = target.compositeOpacity();\n        setTimeout(function () {\n          htmlElement.style.opacity = opacity_1 + \"\";\n        }, 10);\n        var visible = target.isVisibleDeep();\n\n        if (visible) {\n          htmlElement.style.display = \"block\";\n        } // Deal with position\n\n\n        var bounds = target.globalBounds();\n        htmlElement.style.top = bounds.top + \"px\";\n        htmlElement.style.left = bounds.left + \"px\"; // Use width/height if those are set\n\n        var width = target.get(\"width\");\n        var height = target.get(\"height\");\n        var w = 0;\n        var h = 0;\n\n        if (width) {\n          w = target.width();\n        }\n\n        if (height) {\n          h = target.height();\n        }\n\n        if (!width || !height) {\n          htmlElement.style.width = \"\";\n          htmlElement.style.height = \"\";\n          var bbox = htmlElement.getBoundingClientRect();\n          w = bbox.width;\n          h = bbox.height;\n          target._adjustedLocalBounds = {\n            left: 0,\n            right: 0,\n            top: 0,\n            bottom: 0\n          };\n          target.setPrivate(\"minWidth\", w);\n          target.setPrivate(\"minHeight\", h);\n        } else {\n          target.removePrivate(\"minWidth\");\n          target.removePrivate(\"minHeight\");\n        }\n\n        if (w > 0) {\n          htmlElement.style.minWidth = w + \"px\";\n        }\n\n        if (h > 0) {\n          htmlElement.style.minHeight = h + \"px\";\n        } // Hide or show\n\n\n        if (!visible || opacity_1 == 0) {\n          htmlElement.style.display = \"none\";\n        }\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_setHTMLContent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target, html) {\n      var htmlElement = target.getPrivate(\"htmlElement\");\n\n      if (!htmlElement) {\n        htmlElement = this._makeHTMLElement(target);\n      }\n\n      if (htmlElement.innerHTML != html) {\n        htmlElement.innerHTML = html;\n      }\n    }\n  });\n  Object.defineProperty(Root.prototype, \"_removeHTMLContent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (target) {\n      var htmlElement = target.getPrivate(\"htmlElement\");\n\n      if (htmlElement) {\n        this._htmlElementContainer.removeChild(htmlElement);\n      }\n\n      $array.remove(this._htmlEnabledContainers, target);\n    }\n  });\n  return Root;\n}();\n\nexport { Root }; //# sourceMappingURL=Root.js.map","map":null,"metadata":{},"sourceType":"module"}