{"ast":null,"code":"import { __extends, __read } from \"tslib\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { Component } from \"../../../core/render/Component\";\nimport { Container } from \"../../../core/render/Container\";\nimport { p100 } from \"../../../core/util/Percent\";\nimport { List } from \"../../../core/util/List\";\nimport { Rectangle } from \"../../../core/render/Rectangle\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * A base class for all axes.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/#Adding_axes} for more info\r\n */\n\nvar Axis =\n/** @class */\nfunction (_super) {\n  __extends(Axis, _super);\n\n  function Axis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_series\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_this, \"_isPanning\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * A [[Container]] that holds all the axis label elements.\r\n     *\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"labelsContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.children.push(Container.new(_this._root, {}))\n    });\n    /**\r\n     * A [[Container]] that holds all the axis grid and fill elements.\r\n     *\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"gridContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(_this._root, {\n        width: p100,\n        height: p100\n      })\n    });\n    /**\r\n     * A [[Container]] that holds axis grid elements which goes above the series.\r\n     *\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"topGridContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(_this._root, {\n        width: p100,\n        height: p100\n      })\n    });\n    /**\r\n     * A [[Container]] that holds all the axis bullet elements.\r\n     *\r\n     * @default new Container\r\n     */\n\n    Object.defineProperty(_this, \"bulletsContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.children.push(Container.new(_this._root, {\n        isMeasured: false,\n        width: p100,\n        height: p100,\n        position: \"absolute\"\n      }))\n    });\n    /**\r\n     * A referenece to the the chart the axis belongs to.\r\n     */\n\n    Object.defineProperty(_this, \"chart\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_rangesDirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_panStart\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_panEnd\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_sAnimation\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_eAnimation\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_skipSync\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * A list of axis ranges.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info\r\n     * @default new List()\r\n     */\n\n    Object.defineProperty(_this, \"axisRanges\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new List()\n    });\n    Object.defineProperty(_this, \"_seriesAxisRanges\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    /**\r\n     * A control label that is invisible but is used to keep width the width of\r\n     * the axis constant.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/#Ghost_label} for more info\r\n     */\n\n    Object.defineProperty(_this, \"ghostLabel\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_cursorPosition\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: -1\n    });\n    Object.defineProperty(_this, \"_snapToSeries\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_seriesValuesDirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\r\n     * A container above the axis that can be used to add additional stuff into\r\n     * it. For example a legend, label, or an icon.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info\r\n     * @default new Container\r\n     */\n\n    Object.defineProperty(_this, \"axisHeader\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.children.push(Container.new(_this._root, {\n        themeTags: [\"axis\", \"header\"],\n        position: \"absolute\",\n        background: Rectangle.new(_this._root, {\n          themeTags: [\"header\", \"background\"],\n          fill: _this._root.interfaceColors.get(\"background\")\n        })\n      }))\n    });\n    Object.defineProperty(_this, \"_bullets\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_crispX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_crispY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Axis.prototype, \"_dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // these could be in other parents, so disposing just in case\n      this.gridContainer.dispose();\n      this.topGridContainer.dispose();\n      this.bulletsContainer.dispose();\n      this.labelsContainer.dispose();\n      this.axisHeader.dispose();\n\n      _super.prototype._dispose.call(this);\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._afterNew.call(this);\n\n      this.setPrivate(\"updateScrollbar\", true);\n\n      this._disposers.push(this.axisRanges.events.onAll(function (change) {\n        if (change.type === \"clear\") {\n          $array.each(change.oldValues, function (dataItem) {\n            _this.disposeDataItem(dataItem);\n          });\n        } else if (change.type === \"push\") {\n          _this._processAxisRange(change.newValue, [\"range\"]);\n        } else if (change.type === \"setIndex\") {\n          _this._processAxisRange(change.newValue, [\"range\"]);\n        } else if (change.type === \"insertIndex\") {\n          _this._processAxisRange(change.newValue, [\"range\"]);\n        } else if (change.type === \"removeIndex\") {\n          _this.disposeDataItem(change.oldValue);\n        } else if (change.type === \"moveIndex\") {\n          _this._processAxisRange(change.value, [\"range\"]);\n        } else {\n          throw new Error(\"Unknown IStreamEvent type\");\n        }\n      }));\n\n      var renderer = this.get(\"renderer\");\n\n      if (renderer) {\n        renderer.axis = this;\n        renderer.processAxis();\n      }\n\n      this.children.push(renderer);\n      this.ghostLabel = renderer.makeLabel(new DataItem(this, undefined, {}), []);\n      this.ghostLabel.adapters.disable(\"text\");\n      this.ghostLabel.set(\"opacity\", 0);\n    }\n  });\n  /**\r\n   * Zooms the axis to relative locations.\r\n   *\r\n   * Both `start` and `end` are relative: 0 means start of the axis, 1 - end.\r\n   *\r\n   * @param   start     Relative start\r\n   * @param   end       Relative end\r\n   * @param   duration  Duration of the zoom animation in milliseconds\r\n   * @return            Zoom animation\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"zoom\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (start, end, duration, priority) {\n      var _a;\n\n      var _this = this;\n\n      if (this.get(\"start\") !== start || this.get(\"end\") != end) {\n        var sAnimation = this._sAnimation;\n        var eAnimation = this._eAnimation;\n        var maxDeviation = this.get(\"maxDeviation\", 0.5) * Math.min(1, end - start);\n\n        if (start < -maxDeviation) {\n          start = -maxDeviation;\n        }\n\n        if (end > 1 + maxDeviation) {\n          end = 1 + maxDeviation;\n        }\n\n        if (start > end) {\n          _a = __read([end, start], 2), start = _a[0], end = _a[1];\n        }\n\n        if (!$type.isNumber(duration)) {\n          duration = this.get(\"interpolationDuration\", 0);\n        }\n\n        if (!priority) {\n          priority = \"end\";\n        }\n\n        var maxZoomFactor = this.getPrivate(\"maxZoomFactor\", this.get(\"maxZoomFactor\", 100));\n        var maxZoomFactorReal = maxZoomFactor;\n\n        if (end === 1 && start !== 0) {\n          if (start < this.get(\"start\")) {\n            priority = \"start\";\n          } else {\n            priority = \"end\";\n          }\n        }\n\n        if (start === 0 && end !== 1) {\n          if (end > this.get(\"end\")) {\n            priority = \"end\";\n          } else {\n            priority = \"start\";\n          }\n        }\n\n        var minZoomCount = this.get(\"minZoomCount\");\n        var maxZoomCount = this.get(\"maxZoomCount\");\n\n        if ($type.isNumber(minZoomCount)) {\n          maxZoomFactor = maxZoomFactorReal / minZoomCount;\n        }\n\n        var minZoomFactor = 1;\n\n        if ($type.isNumber(maxZoomCount)) {\n          minZoomFactor = maxZoomFactorReal / maxZoomCount;\n        } // most likely we are dragging left scrollbar grip here, so we tend to modify end\n\n\n        if (priority === \"start\") {\n          if (maxZoomCount > 0) {\n            // add to the end\n            if (1 / (end - start) < minZoomFactor) {\n              end = start + 1 / minZoomFactor;\n            }\n          } // add to the end\n\n\n          if (1 / (end - start) > maxZoomFactor) {\n            end = start + 1 / maxZoomFactor;\n          } //unless end is > 0\n\n\n          if (end > 1 && end - start < 1 / maxZoomFactor) {\n            //end = 1;\n            start = end - 1 / maxZoomFactor;\n          }\n        } // most likely we are dragging right, so we modify left\n        else {\n          if (maxZoomCount > 0) {\n            // add to the end\n            if (1 / (end - start) < minZoomFactor) {\n              start = end - 1 / minZoomFactor;\n            }\n          } // remove from start\n\n\n          if (1 / (end - start) > maxZoomFactor) {\n            start = end - 1 / maxZoomFactor;\n          }\n\n          if (start < 0 && end - start < 1 / maxZoomFactor) {\n            //start = 0;\n            end = start + 1 / maxZoomFactor;\n          }\n        }\n\n        if (1 / (end - start) > maxZoomFactor) {\n          end = start + 1 / maxZoomFactor;\n        }\n\n        if (1 / (end - start) > maxZoomFactor) {\n          start = end - 1 / maxZoomFactor;\n        }\n\n        if (maxZoomCount != null && minZoomCount != null && start == this.get(\"start\") && end == this.get(\"end\")) {\n          var chart = this.chart;\n\n          if (chart) {\n            chart._handleAxisSelection(this, true);\n          }\n        }\n\n        if ((sAnimation && sAnimation.playing && sAnimation.to == start || this.get(\"start\") == start) && (eAnimation && eAnimation.playing && eAnimation.to == end || this.get(\"end\") == end)) {\n          return;\n        }\n\n        if (duration > 0) {\n          var easing = this.get(\"interpolationEasing\");\n          var sAnimation_1, eAnimation_1;\n\n          if (this.get(\"start\") != start) {\n            sAnimation_1 = this.animate({\n              key: \"start\",\n              to: start,\n              duration: duration,\n              easing: easing\n            });\n          }\n\n          if (this.get(\"end\") != end) {\n            eAnimation_1 = this.animate({\n              key: \"end\",\n              to: end,\n              duration: duration,\n              easing: easing\n            });\n          }\n\n          this._sAnimation = sAnimation_1;\n          this._eAnimation = eAnimation_1;\n\n          if (sAnimation_1) {\n            return sAnimation_1;\n          } else if (eAnimation_1) {\n            return eAnimation_1;\n          }\n        } else {\n          this.set(\"start\", start);\n          this.set(\"end\", end); // otherwise bullets and line out of sync, as series is not redrawn\n\n          this._root.events.once(\"frameended\", function () {\n            _this._markDirtyKey(\"start\");\n\n            _this._root._markDirty();\n          });\n        }\n      } else {\n        if (this._sAnimation) {\n          this._sAnimation.stop();\n        }\n\n        if (this._eAnimation) {\n          this._eAnimation.stop();\n        }\n      }\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"series\", {\n    /**\r\n     * A list of series using this axis.\r\n     *\r\n     * @return Series\r\n     */\n    get: function () {\n      return this._series;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Axis.prototype, \"_processAxisRange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, themeTags) {\n      dataItem.setRaw(\"isRange\", true);\n\n      this._createAssets(dataItem, themeTags);\n\n      this._rangesDirty = true;\n\n      this._prepareDataItem(dataItem);\n\n      var above = dataItem.get(\"above\");\n      var container = this.topGridContainer;\n      var grid = dataItem.get(\"grid\");\n\n      if (above && grid) {\n        container.children.moveValue(grid);\n      }\n\n      var fill = dataItem.get(\"axisFill\");\n\n      if (above && fill) {\n        container.children.moveValue(fill);\n      }\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_prepareDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_dataItem, _index) {}\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"markDirtyExtremes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {}\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"markDirtySelectionExtremes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {}\n  });\n  Object.defineProperty(Axis.prototype, \"_calculateTotals\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {}\n  });\n  Object.defineProperty(Axis.prototype, \"_updateAxisRanges\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._bullets = {};\n      this.axisRanges.each(function (axisRange) {\n        _this._prepareDataItem(axisRange);\n      });\n      $array.each(this._seriesAxisRanges, function (axisRange) {\n        _this._prepareDataItem(axisRange);\n      });\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_prepareChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._prepareChildren.call(this);\n      /*\r\n      const gridContainer = this.gridContainer;\r\n      const topGridContainer = this.topGridContainer;\r\n      let global = gridContainer._display.toGlobal({ x: 0, y: 0 });\r\n      this._crispX = global.x - Math.round(global.x);\r\n      this._crispY = global.y - Math.round(global.y);\r\n            gridContainer.setAll({ dx: this._crispX, dy: this._crispY });\r\n      topGridContainer.setAll({ dx: this._crispX, dy: this._crispY });\r\n      */\n\n\n      if (this.get(\"fixAxisSize\")) {\n        this.ghostLabel.set(\"visible\", true);\n      } else {\n        this.ghostLabel.set(\"visible\", false);\n      }\n\n      if (this.isDirty(\"start\") || this.isDirty(\"end\")) {\n        this.chart._updateCursor();\n\n        var start = this.get(\"start\", 0);\n        var end = this.get(\"end\", 1);\n        var maxDeviation = this.get(\"maxDeviation\", 0.5) * Math.min(1, end - start);\n\n        if (start < -maxDeviation) {\n          var delta = start + maxDeviation;\n          start = -maxDeviation;\n          this.setRaw(\"start\", start);\n\n          if (this.isDirty(\"end\")) {\n            this.setRaw(\"end\", end - delta);\n          }\n        }\n\n        if (end > 1 + maxDeviation) {\n          var delta = end - 1 - maxDeviation;\n          end = 1 + maxDeviation;\n          this.setRaw(\"end\", end);\n\n          if (this.isDirty(\"start\")) {\n            this.setRaw(\"start\", start - delta);\n          }\n        }\n      }\n\n      var renderer = this.get(\"renderer\");\n      renderer._start = this.get(\"start\");\n      renderer._end = this.get(\"end\");\n      renderer._inversed = renderer.get(\"inversed\", false);\n      renderer._axisLength = renderer.axisLength() / (renderer._end - renderer._start);\n\n      renderer._updateLC();\n\n      if (this.isDirty(\"tooltip\")) {\n        var tooltip = this.get(\"tooltip\");\n\n        if (tooltip) {\n          var rendererTags = renderer.get(\"themeTags\");\n          tooltip.addTag(\"axis\");\n          tooltip.addTag(this.className.toLowerCase());\n\n          tooltip._applyThemes();\n\n          if (rendererTags) {\n            tooltip.set(\"themeTags\", $utils.mergeTags(tooltip.get(\"themeTags\"), rendererTags));\n\n            tooltip.label._applyThemes();\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_updateTooltipBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var tooltip = this.get(\"tooltip\");\n\n      if (tooltip) {\n        this.get(\"renderer\").updateTooltipBounds(tooltip);\n      }\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_updateBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._updateBounds.call(this);\n\n      this._updateTooltipBounds();\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"processChart\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (chart) {\n      var _this = this;\n\n      this.chart = chart;\n      var renderer = this.get(\"renderer\");\n      renderer.chart = chart;\n      chart.gridContainer.children.push(this.gridContainer);\n      chart.topGridContainer.children.push(this.topGridContainer);\n      chart.axisHeadersContainer.children.push(this.axisHeader);\n      this.on(\"start\", function () {\n        chart._handleAxisSelection(_this);\n      });\n      this.on(\"end\", function () {\n        chart._handleAxisSelection(_this);\n      });\n      chart.plotContainer.onPrivate(\"width\", function () {\n        _this.markDirtySize();\n      });\n      chart.plotContainer.onPrivate(\"height\", function () {\n        _this.markDirtySize();\n      });\n      chart.processAxis(this);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"hideDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      this._toggleDataItem(dataItem, false);\n\n      return _super.prototype.hideDataItem.call(this, dataItem);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"showDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      this._toggleDataItem(dataItem, true);\n\n      return _super.prototype.showDataItem.call(this, dataItem);\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_toggleDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, visible) {\n      var label = dataItem.get(\"label\");\n\n      if (label) {\n        label.setPrivate(\"visible\", visible);\n      }\n\n      var grid = dataItem.get(\"grid\");\n\n      if (grid) {\n        grid.setPrivate(\"visible\", visible);\n      }\n\n      var tick = dataItem.get(\"tick\");\n\n      if (tick) {\n        tick.setPrivate(\"visible\", visible);\n      }\n\n      var axisFill = dataItem.get(\"axisFill\");\n\n      if (axisFill) {\n        axisFill.setPrivate(\"visible\", visible);\n      }\n\n      var bullet = dataItem.get(\"bullet\");\n\n      if (bullet) {\n        var sprite = bullet.get(\"sprite\");\n\n        if (sprite) {\n          sprite.setPrivate(\"visible\", visible);\n        }\n      }\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_createAssets\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, tags) {\n      var renderer = this.get(\"renderer\");\n\n      if (!dataItem.get(\"label\")) {\n        renderer.makeLabel(dataItem, tags);\n      }\n\n      if (!dataItem.get(\"grid\")) {\n        renderer.makeGrid(dataItem, tags);\n      }\n\n      if (!dataItem.get(\"tick\")) {\n        renderer.makeTick(dataItem, tags);\n      }\n\n      if (!dataItem.get(\"axisFill\")) {\n        renderer.makeAxisFill(dataItem, tags);\n      }\n\n      this._processBullet(dataItem);\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_processBullet\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      var bullet = dataItem.get(\"bullet\");\n      var axisBullet = this.get(\"bullet\");\n\n      if (!bullet && axisBullet && !dataItem.get(\"isRange\")) {\n        bullet = axisBullet(this._root, this, dataItem);\n      }\n\n      if (bullet) {\n        bullet.axis = this;\n        var sprite = bullet.get(\"sprite\");\n\n        if (sprite) {\n          sprite._setDataItem(dataItem);\n\n          dataItem.setRaw(\"bullet\", bullet);\n\n          if (!sprite.parent) {\n            this.bulletsContainer.children.push(sprite);\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_afterChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._afterChanged.call(this);\n\n      var chart = this.chart;\n\n      if (chart) {\n        chart._updateChartLayout();\n\n        chart.axisHeadersContainer.markDirtySize();\n      }\n\n      this.get(\"renderer\")._updatePositions();\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"disposeDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      _super.prototype.disposeDataItem.call(this, dataItem);\n\n      var renderer = this.get(\"renderer\");\n      var label = dataItem.get(\"label\");\n\n      if (label) {\n        renderer.labels.removeValue(label);\n        label.dispose();\n      }\n\n      var tick = dataItem.get(\"tick\");\n\n      if (tick) {\n        renderer.ticks.removeValue(tick);\n        tick.dispose();\n      }\n\n      var grid = dataItem.get(\"grid\");\n\n      if (grid) {\n        renderer.grid.removeValue(grid);\n        grid.dispose();\n      }\n\n      var axisFill = dataItem.get(\"axisFill\");\n\n      if (axisFill) {\n        renderer.axisFills.removeValue(axisFill);\n        axisFill.dispose();\n      }\n\n      var bullet = dataItem.get(\"bullet\");\n\n      if (bullet) {\n        bullet.dispose();\n      }\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_updateGhost\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var ghostLabel = this.ghostLabel;\n\n      if (!ghostLabel.isHidden()) {\n        var bounds = ghostLabel.localBounds();\n        var gWidth_1 = bounds.right - bounds.left;\n        var text_1 = ghostLabel.get(\"text\");\n        $array.each(this.dataItems, function (dataItem) {\n          var label = dataItem.get(\"label\");\n\n          if (label && !label.isHidden()) {\n            var bounds_1 = label.localBounds();\n            var w = bounds_1.right - bounds_1.left;\n\n            if (w > gWidth_1) {\n              text_1 = label.text._getText();\n            }\n          }\n        });\n        ghostLabel.set(\"text\", text_1);\n      }\n\n      var start = this.get(\"start\", 0);\n      var end = this.get(\"end\", 1);\n      this.get(\"renderer\").updateLabel(ghostLabel, start + (end - start) * 0.5);\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_handleCursorPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position, snapToSeries) {\n      var renderer = this.get(\"renderer\");\n      position = renderer.toAxisPosition(position);\n      this._cursorPosition = position;\n      this._snapToSeries = snapToSeries;\n      this.updateTooltip();\n    }\n  });\n  /**\r\n   * Can be called when axis zoom changes and you need to update tooltip\r\n   * position.\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"updateTooltip\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var snapToSeries = this._snapToSeries;\n      var position = this._cursorPosition;\n      var tooltip = this.get(\"tooltip\");\n      var renderer = this.get(\"renderer\");\n\n      if ($type.isNumber(position)) {\n        $array.each(this.series, function (series) {\n          if (series.get(\"baseAxis\") === _this) {\n            var dataItem = _this.getSeriesItem(series, position, _this.get(\"tooltipLocation\"));\n\n            series.setRaw(\"tooltipDataItem\", dataItem);\n\n            if (snapToSeries && snapToSeries.indexOf(series) != -1) {\n              series.updateLegendMarker(dataItem);\n              series.updateLegendValue(dataItem);\n            } else {\n              series.showDataItemTooltip(dataItem);\n            }\n          }\n        });\n\n        if (tooltip) {\n          renderer.updateTooltipBounds(tooltip);\n\n          if (this.get(\"snapTooltip\")) {\n            position = this.roundAxisPosition(position, this.get(\"tooltipLocation\", 0.5));\n          }\n\n          if (!$type.isNaN(position)) {\n            this.setPrivateRaw(\"tooltipPosition\", position);\n\n            this._updateTooltipText(tooltip, position);\n\n            renderer.positionTooltip(tooltip, position);\n\n            if (position < this.get(\"start\") || position > this.get(\"end\")) {\n              tooltip.hide(0);\n            } else {\n              tooltip.show(0);\n            }\n          } else {\n            tooltip.hide(0);\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Axis.prototype, \"_updateTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (tooltip, position) {\n      tooltip.label.set(\"text\", this.getTooltipText(position));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"roundAxisPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position, _location) {\n      return position;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"handleCursorShow\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var tooltip = this.get(\"tooltip\");\n\n      if (tooltip) {\n        tooltip.show();\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"handleCursorHide\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var tooltip = this.get(\"tooltip\");\n\n      if (tooltip) {\n        tooltip.hide();\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"processSeriesDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_dataItem, _fields) {}\n  });\n  Object.defineProperty(Axis.prototype, \"_clearDirty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._clearDirty.call(this);\n\n      this._sizeDirty = false;\n      this._rangesDirty = false;\n    }\n  });\n  /**\r\n   * Converts pixel coordinate to a relative position on axis.\r\n   *\r\n   * @param   coordinate  Coordinate\r\n   * @return              Relative position\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"coordinateToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (coordinate) {\n      var renderer = this.get(\"renderer\");\n      return renderer.toAxisPosition(coordinate / renderer.axisLength());\n    }\n  });\n  /**\r\n   * Converts relative position of the plot area to relative position of the\r\n   * axis with zoom taken into account.\r\n   *\r\n   * @param position Position\r\n   * @return Relative position\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"toAxisPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      return this.get(\"renderer\").toAxisPosition(position);\n    }\n  });\n  /**\r\n   * Adjusts position with inversed taken into account.\r\n   *\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"fixPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      return this.get(\"renderer\").fixPosition(position);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"shouldGap\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_dataItem, _nextItem, _autoGapCount, _fieldName) {\n      return false;\n    }\n  });\n  /**\r\n   * Creates and returns an axis range object.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-ranges/} for more info\r\n   * @param   axisDataItem  Axis data item\r\n   * @return                Axis range\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"createAxisRange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (axisDataItem) {\n      return this.axisRanges.push(axisDataItem);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"_groupSeriesData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_series) {}\n  });\n  /**\r\n   * Returns position span between start and end of a single cell in axis.\r\n   *\r\n   * @since 5.2.30\r\n   * @return Position\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Axis.prototype, \"getCellWidthPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return 0.05;\n    }\n  });\n  Object.defineProperty(Axis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Axis\"\n  });\n  Object.defineProperty(Axis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Component.classNames.concat([Axis.className])\n  });\n  return Axis;\n}(Component);\n\nexport { Axis }; //# sourceMappingURL=Axis.js.map","map":null,"metadata":{},"sourceType":"module"}