{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { MultiDisposer } from \"../util/Disposer\";\nimport { Label } from \"../render/Label\";\nimport { PointedRectangle } from \"../render/PointedRectangle\";\nimport { Container } from \"./Container\";\nimport { Percent } from \"../util/Percent\";\nimport { Color } from \"../util/Color\";\nimport * as $math from \"../util/Math\";\nimport * as $array from \"../util/Array\";\nimport * as $utils from \"../util/Utils\";\n/**\r\n * Creates a tooltip.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/common-elements/tooltips/} for more info\r\n * @important\r\n */\n\nvar Tooltip =\n/** @class */\nfunction (_super) {\n  __extends(Tooltip, _super);\n\n  function Tooltip(root, settings, isReal, templates) {\n    if (templates === void 0) {\n      templates = [];\n    }\n\n    var _this = _super.call(this, root, settings, isReal, templates) || this;\n\n    Object.defineProperty(_this, \"_arrangeDisposer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_fx\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_fy\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_label\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_fillDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_strokeDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_labelDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_w\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_h\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_keepHoverDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Tooltip.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"tooltip\"]);\n\n      _super.prototype._afterNew.call(this);\n\n      this.set(\"background\", PointedRectangle.new(this._root, {\n        themeTags: [\"tooltip\", \"background\"]\n      }));\n      this._label = this.children.push(Label.new(this._root, {}));\n\n      this._disposers.push(this._label.events.on(\"boundschanged\", function () {\n        _this._updateBackground();\n      }));\n\n      this.on(\"bounds\", function () {\n        _this._updateBackground();\n      });\n\n      this._updateTextColor();\n\n      this._root.tooltipContainer.children.push(this);\n\n      this.hide(0);\n\n      this._root._tooltips.push(this);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"label\", {\n    /**\r\n     * A [[Label]] element for the tooltip.\r\n     *\r\n     * @readonly\r\n     * @return Label\r\n     */\n    get: function () {\n      return this._label;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\r\n   * Permanently disposes the tooltip.\r\n   */\n\n  Object.defineProperty(Tooltip.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.dispose.call(this);\n\n      $array.remove(this._root._tooltips, this);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._updateChildren.call(this);\n\n      var labelText = this.get(\"labelText\");\n\n      if (labelText != null) {\n        this.label.set(\"text\", this.get(\"labelText\"));\n      }\n\n      var labelHTML = this.get(\"labelHTML\");\n\n      if (labelHTML != null) {\n        this.label.set(\"html\", this.get(\"labelHTML\"));\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_changed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._changed.call(this);\n\n      if (this.isDirty(\"pointTo\")) {\n        // can't compare to previous, as sometimes pointTo is set twice (when pointer moves, so the position won't be udpated)\n        this._updateBackground();\n      }\n\n      if (this.isDirty(\"tooltipTarget\")) {\n        this.updateBackgroundColor();\n      }\n\n      if (this.isDirty(\"keepTargetHover\")) {\n        var keephover = this.get(\"keepTargetHover\");\n\n        if (keephover) {\n          var bg = this.get(\"background\");\n          this._keepHoverDp = new MultiDisposer([bg.events.on(\"pointerover\", function (_ev) {\n            var target = _this.get(\"tooltipTarget\");\n\n            if (target) {\n              if (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n                target = target.parent;\n              }\n\n              target.hover();\n            }\n          }), bg.events.on(\"pointerout\", function (_ev) {\n            var target = _this.get(\"tooltipTarget\");\n\n            if (target) {\n              if (target.parent && target.parent.getPrivate(\"tooltipTarget\") == target) {\n                target = target.parent;\n              }\n\n              target.unhover();\n            }\n          })]);\n        } else {\n          if (this._keepHoverDp) {\n            this._keepHoverDp.dispose();\n\n            this._keepHoverDp = undefined;\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_onShow\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._onShow.call(this);\n\n      this.updateBackgroundColor();\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"updateBackgroundColor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var tooltipTarget = this.get(\"tooltipTarget\");\n      var background = this.get(\"background\");\n      var fill;\n      var stroke;\n\n      if (tooltipTarget && background) {\n        fill = tooltipTarget.get(\"fill\");\n        stroke = tooltipTarget.get(\"stroke\");\n\n        if (fill == null) {\n          fill = stroke;\n        }\n\n        if (this.get(\"getFillFromSprite\")) {\n          if (this._fillDp) {\n            this._fillDp.dispose();\n          }\n\n          if (fill != null) {\n            background.set(\"fill\", fill);\n          }\n\n          this._fillDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              background.set(\"fill\", fill);\n\n              _this._updateTextColor(fill);\n            }\n          });\n        }\n\n        if (this.get(\"getStrokeFromSprite\")) {\n          if (this._strokeDp) {\n            this._strokeDp.dispose();\n          }\n\n          if (fill != null) {\n            background.set(\"stroke\", fill);\n          }\n\n          this._strokeDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              background.set(\"stroke\", fill);\n            }\n          });\n        }\n\n        if (this.get(\"getLabelFillFromSprite\")) {\n          if (this._labelDp) {\n            this._labelDp.dispose();\n          }\n\n          if (fill != null) {\n            this.label.set(\"fill\", fill);\n          }\n\n          this._labelDp = tooltipTarget.on(\"fill\", function (fill) {\n            if (fill != null) {\n              _this.label.set(\"fill\", fill);\n            }\n          });\n        }\n      }\n\n      this._updateTextColor(fill);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateTextColor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (fill) {\n      if (this.get(\"autoTextColor\")) {\n        if (fill == null) {\n          fill = this.get(\"background\").get(\"fill\");\n        }\n\n        if (fill == null) {\n          fill = this._root.interfaceColors.get(\"background\");\n        }\n\n        if (fill instanceof Color) {\n          this.label.set(\"fill\", Color.alternative(fill, this._root.interfaceColors.get(\"alternativeText\"), this._root.interfaceColors.get(\"text\")));\n        }\n      }\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_setDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      _super.prototype._setDataItem.call(this, dataItem);\n\n      this.label._setDataItem(dataItem);\n    }\n  });\n  Object.defineProperty(Tooltip.prototype, \"_updateBackground\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.updateBackground.call(this);\n\n      var parent = this._root.container;\n\n      if (parent) {\n        var cw = 0.5;\n        var ch = 0.5;\n        var centerX = this.get(\"centerX\");\n\n        if (centerX instanceof Percent) {\n          cw = centerX.value;\n        }\n\n        var centerY = this.get(\"centerY\");\n\n        if (centerY instanceof Percent) {\n          ch = centerY.value;\n        }\n\n        var parentW = parent.width();\n        var parentH = parent.height();\n        var tooltipContainer = this.parent;\n        var xx = 0;\n        var yy = 0;\n\n        if (tooltipContainer) {\n          xx = tooltipContainer.x();\n          yy = tooltipContainer.y();\n          var layerMargin = tooltipContainer.get(\"layerMargin\");\n\n          if (layerMargin) {\n            xx += layerMargin.left || 0;\n            yy += layerMargin.top || 0;\n            parentW += (layerMargin.left || 0) + (layerMargin.right || 0);\n            parentH += (layerMargin.top || 0) + (layerMargin.bottom || 0);\n          }\n        }\n\n        var bounds = this.get(\"bounds\", {\n          left: -xx,\n          top: -yy,\n          right: parentW - xx,\n          bottom: parentH - yy\n        });\n\n        this._updateBounds();\n\n        var w = this.width();\n        var h = this.height(); // use old w and h,as when tooltip is hidden, these are 0 and unneeded animation happens\n\n        if (w === 0) {\n          w = this._w;\n        }\n\n        if (h === 0) {\n          h = this._h;\n        }\n\n        var pointTo = this.get(\"pointTo\", {\n          x: parentW / 2,\n          y: parentH / 2\n        });\n        var x = pointTo.x;\n        var y = pointTo.y;\n        var pointerOrientation = this.get(\"pointerOrientation\");\n        var background = this.get(\"background\");\n        var pointerLength = 0;\n        var bgStrokeSizeY = 0;\n        var bgStrokeSizeX = 0;\n\n        if (background instanceof PointedRectangle) {\n          pointerLength = background.get(\"pointerLength\", 0);\n          bgStrokeSizeY = background.get(\"strokeWidth\", 0) / 2;\n          bgStrokeSizeX = bgStrokeSizeY;\n        }\n\n        var pointerX = 0;\n        var pointerY = 0;\n        var boundsW = bounds.right - bounds.left;\n        var boundsH = bounds.bottom - bounds.top; // horizontal\n\n        if (pointerOrientation == \"horizontal\" || pointerOrientation == \"left\" || pointerOrientation == \"right\") {\n          bgStrokeSizeY = 0;\n\n          if (pointerOrientation == \"horizontal\") {\n            if (x > bounds.left + boundsW / 2) {\n              x -= w * (1 - cw) + pointerLength;\n              bgStrokeSizeX *= -1;\n            } else {\n              x += w * cw + pointerLength;\n            }\n          } else if (pointerOrientation == \"left\") {\n            x += w * (1 - cw) + pointerLength;\n          } else {\n            x -= w * cw + pointerLength;\n            bgStrokeSizeX *= -1;\n          }\n        } // vertical pointer\n        else {\n          bgStrokeSizeX = 0;\n\n          if (pointerOrientation == \"vertical\") {\n            if (y > bounds.top + h / 2 + pointerLength) {\n              y -= h * (1 - ch) + pointerLength;\n            } else {\n              y += h * ch + pointerLength;\n              bgStrokeSizeY *= -1;\n            }\n          } else if (pointerOrientation == \"down\") {\n            y -= h * (1 - ch) + pointerLength;\n          } else {\n            y += h * ch + pointerLength;\n            bgStrokeSizeY *= -1;\n          }\n        }\n\n        x = $math.fitToRange(x, bounds.left + w * cw, bounds.left + boundsW - w * (1 - cw)) + bgStrokeSizeX;\n        y = $math.fitToRange(y, bounds.top + h * ch, bounds.top + boundsH - h * (1 - ch)) - bgStrokeSizeY;\n        pointerX = pointTo.x - x + w * cw + bgStrokeSizeX;\n        pointerY = pointTo.y - y + h * ch - bgStrokeSizeY;\n        this._fx = x;\n        this._fy = y;\n        var animationDuration = this.get(\"animationDuration\", 0);\n\n        if (animationDuration > 0 && this.get(\"visible\") && this.get(\"opacity\") > 0.1) {\n          var animationEasing = this.get(\"animationEasing\");\n          this.animate({\n            key: \"x\",\n            to: x,\n            duration: animationDuration,\n            easing: animationEasing\n          });\n          this.animate({\n            key: \"y\",\n            to: y,\n            duration: animationDuration,\n            easing: animationEasing\n          });\n        } else {\n          this.set(\"x\", x);\n          this.set(\"y\", y);\n        }\n\n        if (background instanceof PointedRectangle) {\n          background.set(\"pointerX\", pointerX);\n          background.set(\"pointerY\", pointerY);\n        }\n\n        if (w > 0) {\n          this._w = w;\n        }\n\n        if (h > 0) {\n          this._h = h;\n        }\n      }\n    }\n  });\n  Object.defineProperty(Tooltip, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Tooltip\"\n  });\n  Object.defineProperty(Tooltip, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Container.classNames.concat([Tooltip.className])\n  });\n  return Tooltip;\n}(Container);\n\nexport { Tooltip }; //# sourceMappingURL=Tooltip.js.map","map":null,"metadata":{},"sourceType":"module"}