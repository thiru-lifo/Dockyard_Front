{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"./Entity\";\nimport { TextFormatter } from \"./TextFormatter\";\nimport * as $object from \"./Object\";\nimport * as $utils from \"./Utils\";\nimport * as $type from \"./Type\";\n/**\r\n * A class used to format numberic values as time duration.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-durations/} for more info\r\n */\n\nvar DurationFormatter =\n/** @class */\nfunction (_super) {\n  __extends(DurationFormatter, _super);\n\n  function DurationFormatter() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * Collection of aliases for units.\r\n     */\n\n\n    Object.defineProperty(_this, \"_unitAliases\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        \"Y\": \"y\",\n        \"D\": \"d\",\n        \"H\": \"h\",\n        \"K\": \"h\",\n        \"k\": \"h\",\n        \"n\": \"S\"\n      }\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DurationFormatter.prototype, \"_setDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var dmillisecond = \"_duration_millisecond\";\n      var dsecond = \"_duration_second\";\n      var dminute = \"_duration_minute\";\n      var dhour = \"_duration_hour\";\n      var dday = \"_duration_day\";\n      var dweek = \"_duration_week\";\n      var dmonth = \"_duration_month\";\n      var dyear = \"_duration_year\";\n      var asecond = \"_second\";\n      var aminute = \"_minute\";\n      var ahour = \"_hour\";\n      var aday = \"_day\";\n      var aweek = \"_week\";\n      var amonth = \"_week\";\n      var ayear = \"_year\"; // Defaults\n\n      this._setDefault(\"negativeBase\", 0);\n\n      this._setDefault(\"baseUnit\", \"second\");\n\n      this._setDefault(\"durationFormats\", {\n        \"millisecond\": {\n          \"millisecond\": this._t(dmillisecond),\n          \"second\": this._t(dmillisecond + asecond),\n          \"minute\": this._t(dmillisecond + aminute),\n          \"hour\": this._t(dmillisecond + ahour),\n          \"day\": this._t(dmillisecond + aday),\n          \"week\": this._t(dmillisecond + aweek),\n          \"month\": this._t(dmillisecond + amonth),\n          \"year\": this._t(dmillisecond + ayear)\n        },\n        \"second\": {\n          \"second\": this._t(dsecond),\n          \"minute\": this._t(dsecond + aminute),\n          \"hour\": this._t(dsecond + ahour),\n          \"day\": this._t(dsecond + aday),\n          \"week\": this._t(dsecond + aweek),\n          \"month\": this._t(dsecond + amonth),\n          \"year\": this._t(dsecond + ayear)\n        },\n        \"minute\": {\n          \"minute\": this._t(dminute),\n          \"hour\": this._t(dminute + ahour),\n          \"day\": this._t(dminute + aday),\n          \"week\": this._t(dminute + aweek),\n          \"month\": this._t(dminute + amonth),\n          \"year\": this._t(dminute + ayear)\n        },\n        \"hour\": {\n          \"hour\": this._t(dhour),\n          \"day\": this._t(dhour + aday),\n          \"week\": this._t(dhour + aweek),\n          \"month\": this._t(dhour + amonth),\n          \"year\": this._t(dhour + ayear)\n        },\n        \"day\": {\n          \"day\": this._t(dday),\n          \"week\": this._t(dday + aweek),\n          \"month\": this._t(dday + amonth),\n          \"year\": this._t(dday + ayear)\n        },\n        \"week\": {\n          \"week\": this._t(dweek),\n          \"month\": this._t(dweek + amonth),\n          \"year\": this._t(dweek + ayear)\n        },\n        \"month\": {\n          \"month\": this._t(dmonth),\n          \"year\": this._t(dmonth + ayear)\n        },\n        \"year\": {\n          \"year\": this._t(dyear)\n        }\n      });\n\n      _super.prototype._setDefaults.call(this);\n    }\n  });\n  Object.defineProperty(DurationFormatter.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n    }\n  });\n  /**\r\n   * Formats the number as duration.\r\n   *\r\n   * For example `1000` (base unit seconds) would be converted to `16:40` as in\r\n   * 16 minutes and 40 seconds.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @param base    Override base unit\r\n   * @return Formatted number\r\n   */\n\n  Object.defineProperty(DurationFormatter.prototype, \"format\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, format, base) {\n      // no base unit?\n      var baseUnit = base || this.get(\"baseUnit\"); // no format passed in or empty\n\n      if (typeof format === \"undefined\" || format === \"\") {\n        if (this.get(\"durationFormat\") != null) {\n          format = this.get(\"durationFormat\");\n        } else {\n          format = this.getFormat($type.toNumber(value), undefined, baseUnit);\n        }\n      } // Clean format\n\n\n      format = $utils.cleanFormat(format); // get format info (it will also deal with parser caching)\n\n      var info = this.parseFormat(format, baseUnit); // cast to number just in case\n      // TODO: maybe use better casting\n\n      var source = Number(value); // format and replace the number\n\n      var details;\n\n      if (source > this.get(\"negativeBase\")) {\n        details = info.positive;\n      } else if (source < this.get(\"negativeBase\")) {\n        details = info.negative;\n      } else {\n        details = info.zero;\n      } // Format\n\n\n      var formatted = this.applyFormat(source, details); // Apply color?\n\n      if (details.color !== \"\") {\n        formatted = \"[\" + details.color + \"]\" + formatted + \"[/]\";\n      }\n\n      return formatted;\n    }\n  });\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format  Format string, i.e. \"#,###.00\"\r\n   * @param base    Override base unit\r\n   * @return Parsed information\r\n   */\n\n  Object.defineProperty(DurationFormatter.prototype, \"parseFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (format, base) {\n      // Check cache\n      // TODO\n      // let cached = this.getCache(format);\n      // if (cached != null) {\n      // \treturn cached;\n      // }\n      var _this = this; // no base unit?\n\n\n      var baseUnit = base || this.get(\"baseUnit\"); // Initialize duration parsing info\n\n      var info = {\n        \"positive\": {\n          \"color\": \"\",\n          \"template\": \"\",\n          \"parts\": [],\n          \"source\": \"\",\n          \"baseUnit\": baseUnit,\n          \"parsed\": false,\n          \"absolute\": false\n        },\n        \"negative\": {\n          \"color\": \"\",\n          \"template\": \"\",\n          \"parts\": [],\n          \"source\": \"\",\n          \"baseUnit\": baseUnit,\n          \"parsed\": false,\n          \"absolute\": false\n        },\n        \"zero\": {\n          \"color\": \"\",\n          \"template\": \"\",\n          \"parts\": [],\n          \"source\": \"\",\n          \"baseUnit\": baseUnit,\n          \"parsed\": false,\n          \"absolute\": false\n        }\n      }; // Escape double vertical bars (that mean display one vertical bar)\n\n      format = format.replace(\"||\", $type.PLACEHOLDER2); // Split it up and deal with different formats\n\n      var parts = format.split(\"|\");\n      info.positive.source = parts[0];\n\n      if (typeof parts[2] === \"undefined\") {\n        info.zero = info.positive;\n      } else {\n        info.zero.source = parts[2];\n      }\n\n      if (typeof parts[1] === \"undefined\") {\n        info.negative = info.positive;\n      } else {\n        info.negative.source = parts[1];\n      } // Parse each\n\n\n      $object.each(info, function (_part, item) {\n        // Already parsed\n        if (item.parsed) {\n          return;\n        } // Check cached\n        // TODO\n        // if (typeof this.getCache(item.source) !== \"undefined\") {\n        // \tinfo[part] = this.getCache(item.source);\n        // \treturn;\n        // }\n        // Begin parsing\n\n\n        var partFormat = item.source; // Check for [] directives\n\n        var dirs = [];\n        dirs = item.source.match(/^\\[([^\\]]*)\\]/);\n\n        if (dirs && dirs.length && dirs[0] !== \"\") {\n          partFormat = item.source.substr(dirs[0].length);\n          item.color = dirs[1];\n        } // Let TextFormatter split into chunks\n\n\n        var chunks = TextFormatter.chunk(partFormat, true);\n\n        for (var i = 0; i < chunks.length; i++) {\n          var chunk = chunks[i]; // replace back double vertical bar\n\n          chunk.text = chunk.text.replace($type.PLACEHOLDER2, \"|\");\n\n          if (chunk.type === \"value\") {\n            // Just \"Duration\"?\n            // if (chunk.text.toLowerCase() === \"duration\") {\n            // \tchunk.text = durationFormat;\n            // }\n            // Check for \"a\" (absolute) modifier\n            if (chunk.text.match(/[yYMdDwhHKkmsSn]+a/)) {\n              item.absolute = true;\n              chunk.text = chunk.text.replace(/([yYMdDwhHKkmsSn]+)a/, \"$1\");\n            } // Find all possible parts\n\n\n            var matches = chunk.text.match(/y+|Y+|M+|d+|D+|w+|h+|H+|K+|k+|m+|s+|S+|n+/g);\n\n            if (matches) {\n              // Populate template\n              for (var x = 0; x < matches.length; x++) {\n                // Is it an alias?\n                if (matches[x] == null) {\n                  matches[x] = _this._unitAliases[matches[x]];\n                }\n\n                item.parts.push(matches[x]);\n                chunk.text = chunk.text.replace(matches[x], $type.PLACEHOLDER);\n              }\n            }\n          } // Apply to template\n\n\n          item.template += chunk.text;\n        } // Apply style formatting\n        //item.template = TextFormatter.format(item.template, this.outputFormat);\n        // Save cache\n        // TODO\n        //this.setCache(item.source, item);\n        // Mark this as parsed\n\n\n        item.parsed = true;\n      }); // Save cache (the whole thing)\n      // TODO\n      //this.setCache(format, info);\n\n      return info;\n    }\n  });\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by {parseFormat}\r\n   * @return Formatted duration\r\n   */\n\n  Object.defineProperty(DurationFormatter.prototype, \"applyFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, details) {\n      // Use absolute values\n      var negative = !details.absolute && value < this.get(\"negativeBase\");\n      value = Math.abs(value); // Recalculate to milliseconds\n\n      var tstamp = this.toTimeStamp(value, details.baseUnit); // Init return value\n\n      var res = details.template; // Iterate through duration parts\n\n      for (var i = 0, len = details.parts.length; i < len; i++) {\n        // Gather the part\n        var part = details.parts[i];\n\n        var unit = this._toTimeUnit(part.substr(0, 1));\n\n        var digits = part.length; // Calculate current unit value\n\n        var ints = Math.floor(tstamp / this._getUnitValue(unit));\n        res = res.replace($type.PLACEHOLDER, $utils.padString(ints, digits, \"0\")); // Reduce timestamp\n\n        tstamp -= ints * this._getUnitValue(unit);\n      } // Reapply negative sign\n\n\n      if (negative) {\n        res = \"-\" + res;\n      }\n\n      return res;\n    }\n  });\n  /**\r\n   * Converts numeric value to timestamp in milliseconds.\r\n   *\r\n   * @param value     A source value\r\n   * @param baseUnit  Base unit the source value is in: \"q\", \"s\", \"i\", \"h\", \"d\", \"w\", \"m\", \"y\"\r\n   * @return Value representation as a timestamp in milliseconds\r\n   */\n\n  Object.defineProperty(DurationFormatter.prototype, \"toTimeStamp\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, baseUnit) {\n      return value * this._getUnitValue(baseUnit);\n    }\n  });\n  Object.defineProperty(DurationFormatter.prototype, \"_toTimeUnit\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (code) {\n      switch (code) {\n        case \"S\":\n          return \"millisecond\";\n\n        case \"s\":\n          return \"second\";\n\n        case \"m\":\n          return \"minute\";\n\n        case \"h\":\n          return \"hour\";\n\n        case \"d\":\n          return \"day\";\n\n        case \"w\":\n          return \"week\";\n\n        case \"M\":\n          return \"month\";\n\n        case \"y\":\n          return \"year\";\n      }\n\n      ;\n    }\n  });\n  /**\r\n   * Returns appropriate default format for the value.\r\n   *\r\n   * If `maxValue` is sepcified, it will use that value to determine the time\r\n   * unit for the format.\r\n   *\r\n   * For example if your `baseUnit` is `\"second\"` and you pass in `10`, you\r\n   * will get `\"10\"`.\r\n   *\r\n   * However, you might want it to be formatted in the context of bigger scale,\r\n   * say 10 minutes (600 seconds). If you pass in `600` as `maxValue`, all\r\n   * values, including small ones will use format with minutes, e.g.:\r\n   * `00:10`, `00:50`, `12: 30`, etc.\r\n   *\r\n   * @param value     Value to format\r\n   * @param maxValue  Maximum value to be used to determine format\r\n   * @param baseUnit  Base unit of the value\r\n   * @return Format\r\n   */\n\n  Object.defineProperty(DurationFormatter.prototype, \"getFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, maxValue, baseUnit) {\n      // Is format override set?\n      if (this.get(\"durationFormat\") != null) {\n        return this.get(\"durationFormat\");\n      } // Get base unit\n\n\n      if (!baseUnit) {\n        baseUnit = this.get(\"baseUnit\");\n      }\n\n      if (maxValue != null && value != maxValue) {\n        value = Math.abs(value);\n        maxValue = Math.abs(maxValue);\n        var maxUnit = this.getValueUnit(Math.max(value, maxValue), baseUnit); //let diffUnit = this.getValueUnit(Math.abs(maxValue - value), baseUnit);\n        //console.log(maxUnit, diffUnit);\n\n        return this.get(\"durationFormats\")[baseUnit][maxUnit];\n      } else {\n        var unit = this.getValueUnit(value, baseUnit);\n        return this.get(\"durationFormats\")[baseUnit][unit];\n      }\n    }\n  });\n  /**\r\n   * Returns value's closest denominator time unit, e.g 100 seconds is\r\n   * `\"minute\"`, while 59 seconds would still be `second`.\r\n   *\r\n   * @param value     Source duration value\r\n   * @param baseUnit  Base unit\r\n   * @return Denominator\r\n   */\n\n  Object.defineProperty(DurationFormatter.prototype, \"getValueUnit\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, baseUnit) {\n      // Get base unit\n      if (!baseUnit) {\n        baseUnit = this.get(\"baseUnit\");\n      } // Convert to milliseconds\n\n\n      var currentUnit;\n      var ms = this.getMilliseconds(value, baseUnit);\n      $object.eachContinue(this._getUnitValues(), function (key, val) {\n        if (key == baseUnit || currentUnit) {\n          var num = ms / val;\n\n          if (num <= 1) {\n            if (!currentUnit) {\n              currentUnit = key;\n            }\n\n            return false;\n          }\n\n          currentUnit = key;\n        }\n\n        return true;\n      });\n      return currentUnit;\n    }\n  });\n  /**\r\n   * Converts value to milliseconds according to `baseUnit`.\r\n   *\r\n   * @param value     Source duration value\r\n   * @param baseUnit  Base unit\r\n   * @return Value in milliseconds\r\n   */\n\n  Object.defineProperty(DurationFormatter.prototype, \"getMilliseconds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, baseUnit) {\n      // Get base unit\n      if (!baseUnit) {\n        baseUnit = this.get(\"baseUnit\");\n      }\n\n      return value * this._getUnitValue(baseUnit);\n    }\n  });\n  Object.defineProperty(DurationFormatter.prototype, \"_getUnitValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (timeUnit) {\n      return this._getUnitValues()[timeUnit];\n    }\n  });\n  Object.defineProperty(DurationFormatter.prototype, \"_getUnitValues\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return {\n        \"millisecond\": 1,\n        \"second\": 1000,\n        \"minute\": 60000,\n        \"hour\": 3600000,\n        \"day\": 86400000,\n        \"week\": 604800000,\n        \"month\": 2592000000,\n        \"year\": 31536000000\n      };\n    }\n  });\n  return DurationFormatter;\n}(Entity);\n\nexport { DurationFormatter }; //# sourceMappingURL=DurationFormatter.js.map","map":null,"metadata":{},"sourceType":"module"}