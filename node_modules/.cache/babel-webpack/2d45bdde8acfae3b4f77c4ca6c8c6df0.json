{"ast":null,"code":"/** @ignore */\n\n/** */\nimport { __extends } from \"tslib\";\nimport { BlendMode } from \"./Renderer\";\nimport { Color } from \"../../util/Color\";\nimport { Matrix } from \"../../util/Matrix\";\nimport { Percent, percent } from \"../../util/Percent\"; //import { Throttler } from \"../../util/Throttler\";\n\nimport { ArrayDisposer, Disposer, DisposerClass, CounterDisposer, MultiDisposer } from \"../../util/Disposer\";\nimport { TextFormatter } from \"../../util/TextFormatter\";\nimport * as $utils from \"../../util/Utils\";\nimport * as $array from \"../../util/Array\";\nimport * as $object from \"../../util/Object\";\nimport * as $type from \"../../util/Type\";\nimport * as $math from \"../../util/Math\";\nimport arcToBezier from 'svg-arc-to-cubic-bezier';\n/**\r\n * @ignore\r\n */\n\nfunction checkArgs(name, actual, expected) {\n  if (actual !== expected) {\n    throw new Error(\"Required \" + expected + \" arguments for \" + name + \" but got \" + actual);\n  }\n}\n/**\r\n * @ignore\r\n */\n\n\nfunction checkMinArgs(name, actual, expected) {\n  if (actual < expected) {\n    throw new Error(\"Required at least \" + expected + \" arguments for \" + name + \" but got \" + actual);\n  }\n}\n/**\r\n * @ignore\r\n */\n\n\nfunction checkEvenArgs(name, actual, expected) {\n  checkMinArgs(name, actual, expected);\n\n  if (actual % expected !== 0) {\n    throw new Error(\"Arguments for \" + name + \" must be in pairs of \" + expected);\n  }\n}\n/**\r\n * @ignore\r\n * This splits the flag so that way 0017 will be processed as 0 0 17\r\n *\r\n * This is important for weird paths like `M17 5A1 1 0 0017 30 1 1 0 0017 5`\r\n */\n\n\nfunction splitArcFlags(args) {\n  for (var i = 0; i < args.length; i += 7) {\n    var index = i + 3;\n    var flag = args[index];\n\n    if (flag.length > 1) {\n      var a = /^([01])([01])(.*)$/.exec(flag);\n\n      if (a !== null) {\n        args.splice(index, 0, a[1]);\n        ++index;\n        args.splice(index, 0, a[2]);\n        ++index;\n\n        if (a[3].length > 0) {\n          args[index] = a[3];\n        } else {\n          args.splice(index, 1);\n        }\n      }\n    }\n\n    ++index;\n    flag = args[index];\n\n    if (flag.length > 1) {\n      var a = /^([01])(.+)$/.exec(flag);\n\n      if (a !== null) {\n        args.splice(index, 0, a[1]);\n        ++index;\n        args[index] = a[2];\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\n\n\nfunction assertBinary(value) {\n  if (value === 0 || value === 1) {\n    return value;\n  } else {\n    throw new Error(\"Flag must be 0 or 1\");\n  }\n} //  1 -> 0xffffff * (2 / 2)\n//  2 -> 0xffffff * (1 / 2)\n//\n//  3 -> 0xffffff * (3 / 4)\n//  4 -> 0xffffff * (1 / 4)\n//\n//  5 -> 0xffffff * (7 / 8)\n//  6 -> 0xffffff * (5 / 8)\n//  7 -> 0xffffff * (3 / 8)\n//  8 -> 0xffffff * (1 / 8)\n//\n//  9 -> 0xffffff * (15 / 16)\n// 10 -> 0xffffff * (13 / 16)\n// 11 -> 0xffffff * (11 / 16)\n// 12 -> 0xffffff *  (9 / 16)\n// 13 -> 0xffffff *  (7 / 16)\n// 14 -> 0xffffff *  (5 / 16)\n// 15 -> 0xffffff *  (3 / 16)\n// 16 -> 0xffffff *  (1 / 16)\n// @todo remove this old color distribution algo if the new one pans out\n// function distributeIdBAK(id: number): number {\n// \tif (id === 1) {\n// \t\treturn 0x000001;\n// \t} else {\n// \t\t// Finds the closest power of 2\n// \t\tconst base = Math.pow(2, Math.ceil(Math.log(id) / Math.log(2)));\n// \t\t// Translates the id into an odd fraction index\n// \t\tconst index = ((base - id) * 2) + 1;\n// \t\t// TODO is Math.round correct ?\n// \t\treturn Math.round(0xffffff * (index / base));\n// \t}\n// }\n\n/**\r\n * Function by smeans:\r\n * https://lowcode.life/generating-unique-contrasting-colors-in-javascript/\r\n * @ignore\r\n */\n\n\nfunction distributeId(id) {\n  var rgb = [0, 0, 0];\n\n  for (var i = 0; i < 24; i++) {\n    rgb[i % 3] <<= 1;\n    rgb[i % 3] |= id & 0x01;\n    id >>= 1;\n  }\n\n  return (rgb[2] | 0) + (rgb[1] << 8) + (rgb[0] << 16);\n}\n/**\r\n * @ignore\r\n */\n\n\nfunction eachTargets(hitTarget, f) {\n  for (;;) {\n    if (hitTarget.interactive) {\n      if (!f(hitTarget)) {\n        break;\n      }\n    }\n\n    if (hitTarget._parent) {\n      hitTarget = hitTarget._parent;\n    } else {\n      break;\n    }\n  }\n} // TODO feature detection for mouse/touch/pointer\n\n/**\r\n * @ignore\r\n */\n\n\nfunction onPointerEvent(element, name, f) {\n  return $utils.addEventListener(element, $utils.getRendererEvent(name), function (event) {\n    var touches = event.touches;\n\n    if (touches) {\n      if (touches.length == 0) {\n        touches = event.changedTouches;\n      }\n\n      f($array.copy(touches));\n    } else {\n      f([event]);\n    }\n  });\n}\n/**\r\n * @ignore\r\n */\n\n\nfunction isTainted(image) {\n  var canvas = document.createElement(\"canvas\");\n  canvas.width = 1;\n  canvas.height = 1;\n  var context = canvas.getContext(\"2d\", {\n    willReadFrequently: true\n  });\n  context.drawImage(image, 0, 0, 1, 1);\n\n  try {\n    context.getImageData(0, 0, 1, 1);\n    return false;\n  } catch (err) {\n    console.warn(\"Image \\\"\" + image.src + \"\\\" is loaded from different host and is not covered by CORS policy. For more information about the implications read here: https://www.amcharts.com/docs/v5/concepts/cors\");\n    return true;\n  }\n}\n/**\r\n * This is needed to workaround a bug in iOS which causes it to not GC canvas elements.\r\n *\r\n * @ignore\r\n */\n\n\nfunction clearCanvas(view) {\n  view.width = 0;\n  view.height = 0;\n  view.style.width = \"0px\";\n  view.style.height = \"0px\";\n}\n/**\r\n * @ignore\r\n */\n\n\nvar CanvasPivot =\n/** @class */\nfunction () {\n  function CanvasPivot() {\n    Object.defineProperty(this, \"_x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n  }\n\n  Object.defineProperty(CanvasPivot.prototype, \"x\", {\n    get: function () {\n      return this._x;\n    },\n    set: function (value) {\n      this._x = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CanvasPivot.prototype, \"y\", {\n    get: function () {\n      return this._y;\n    },\n    set: function (value) {\n      this._y = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return CanvasPivot;\n}();\n\nexport { CanvasPivot };\n/**\r\n * @ignore\r\n */\n\nvar CanvasDisplayObject =\n/** @class */\nfunction (_super) {\n  __extends(CanvasDisplayObject, _super);\n\n  function CanvasDisplayObject(renderer) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"_layer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"mask\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: null\n    });\n    Object.defineProperty(_this, \"visible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(_this, \"exportable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(_this, \"interactive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"inactive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"wheelable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"cancelTouch\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"isMeasured\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"buttonMode\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"alpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"compoundAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"angle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"scale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"pivot\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new CanvasPivot()\n    });\n    Object.defineProperty(_this, \"filter\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"cursorOverStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_replacedCursorStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_localMatrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    Object.defineProperty(_this, \"_matrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    }); // TODO can this be replaced with _localMatrix ?\n\n    Object.defineProperty(_this, \"_uMatrix\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Matrix()\n    });\n    Object.defineProperty(_this, \"_renderer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_parent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_localBounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_bounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_colorId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    _this._renderer = renderer;\n    return _this;\n  }\n\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._renderer._removeObject(this);\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"getCanvas\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this.getLayer().view;\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"getLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var self = this;\n\n      for (;;) {\n        if (self._layer) {\n          return self._layer;\n        } else if (self._parent) {\n          self = self._parent;\n        } else {\n          return this._renderer.defaultLayer;\n        }\n      }\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"setLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (order, margin) {\n      if (order == null) {\n        this._layer = undefined;\n      } else {\n        var visible = true;\n        this._layer = this._renderer.getLayer(order, visible);\n        this._layer.visible = visible;\n        this._layer.margin = margin;\n\n        if (margin) {\n          $utils.setInteractive(this._layer.view, false);\n        }\n\n        this._renderer._ghostLayer.setMargin(this._renderer.layers);\n\n        if (this._parent) {\n          this._parent.registerChildLayer(this._layer);\n        }\n\n        this._renderer.resizeLayer(this._layer);\n\n        this._renderer.resizeGhost();\n      }\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"markDirtyLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.getLayer().dirty = true;\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"clear\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.invalidateBounds();\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"invalidateBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._localBounds = undefined;\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_bounds) {}\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_getColorId\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this._colorId === undefined) {\n        this._colorId = this._renderer.paintId(this);\n      }\n\n      return this._colorId;\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_isInteractive\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this.inactive == false && (this.interactive || this._renderer._forceInteractive > 0);\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_isInteractiveMask\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._isInteractive();\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"contains\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (child) {\n      for (;;) {\n        if (child === this) {\n          return true;\n        } else if (child._parent) {\n          child = child._parent;\n        } else {\n          return false;\n        }\n      }\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"toGlobal\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      return this._matrix.apply(point);\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"toLocal\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      return this._matrix.applyInverse(point);\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"getLocalMatrix\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._uMatrix.setTransform(0, 0, this.pivot.x, this.pivot.y, this.angle * Math.PI / 180, this.scale);\n\n      return this._uMatrix;\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"getLocalBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._localBounds) {\n        var bn = 10000000;\n        this._localBounds = {\n          left: bn,\n          top: bn,\n          right: -bn,\n          bottom: -bn\n        };\n\n        this._addBounds(this._localBounds);\n      }\n\n      return this._localBounds;\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"getAdjustedBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      this._setMatrix();\n\n      var matrix = this.getLocalMatrix();\n      var p0 = matrix.apply({\n        x: bounds.left,\n        y: bounds.top\n      });\n      var p1 = matrix.apply({\n        x: bounds.right,\n        y: bounds.top\n      });\n      var p2 = matrix.apply({\n        x: bounds.right,\n        y: bounds.bottom\n      });\n      var p3 = matrix.apply({\n        x: bounds.left,\n        y: bounds.bottom\n      });\n      return {\n        left: Math.min(p0.x, p1.x, p2.x, p3.x),\n        top: Math.min(p0.y, p1.y, p2.y, p3.y),\n        right: Math.max(p0.x, p1.x, p2.x, p3.x),\n        bottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n      };\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"on\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key, callback, context) {\n      if (this.interactive) {\n        return this._renderer._addEvent(this, key, callback, context);\n      } else {\n        return new Disposer(function () {});\n      }\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_setMatrix\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // TODO only calculate this if it has actually changed\n      this._localMatrix.setTransform(this.x, this.y, this.pivot.x, this.pivot.y, // Converts degrees to radians\n      this.angle * Math.PI / 180, this.scale);\n\n      this._matrix.copyFrom(this._localMatrix);\n\n      if (this._parent) {\n        // TODO only calculate this if it has actually changed\n        this._matrix.prepend(this._parent._matrix);\n      }\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_transform\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, resolution) {\n      var m = this._matrix;\n      context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, m.tx * resolution, m.ty * resolution);\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_transformMargin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, resolution, margin) {\n      var m = this._matrix;\n      context.setTransform(m.a * resolution, m.b * resolution, m.c * resolution, m.d * resolution, (m.tx + margin.left) * resolution, (m.ty + margin.top) * resolution);\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_transformLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, resolution, layer) {\n      if (layer.margin) {\n        this._transformMargin(context, layer.scale || resolution, layer.margin);\n      } else {\n        this._transform(context, layer.scale || resolution);\n      }\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parentLayer) {\n      var _this = this;\n\n      if (this.visible && (this.exportable !== false || !this._renderer._omitTainted)) {\n        this._setMatrix();\n\n        var resolution_1 = this._renderer.resolution;\n        var layers = this._renderer.layers;\n        var ghostLayer = this._renderer._ghostLayer;\n        var ghostContext = ghostLayer.context;\n        var mask_1 = this.mask;\n\n        if (mask_1) {\n          mask_1._setMatrix();\n        } // TODO improve this\n\n\n        $array.each(layers, function (layer) {\n          if (layer) {\n            var context = layer.context;\n            context.save(); // We must apply the mask before we transform the element\n\n            if (mask_1) {\n              mask_1._transformLayer(context, resolution_1, layer);\n\n              mask_1._runPath(context);\n\n              context.clip();\n            }\n\n            context.globalAlpha = _this.compoundAlpha * _this.alpha;\n\n            _this._transformLayer(context, resolution_1, layer);\n\n            if (_this.filter) {\n              context.filter = _this.filter;\n            }\n          }\n        });\n        ghostContext.save(); // We must apply the mask before we transform the element\n\n        if (mask_1 && this._isInteractiveMask()) {\n          mask_1._transformMargin(ghostContext, resolution_1, ghostLayer.margin);\n\n          mask_1._runPath(ghostContext);\n\n          ghostContext.clip();\n        }\n\n        this._transformMargin(ghostContext, resolution_1, ghostLayer.margin);\n\n        this._render(parentLayer);\n\n        ghostContext.restore();\n        $array.each(layers, function (layer) {\n          if (layer) {\n            layer.context.restore();\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"_render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parentLayer) {\n      if (this.exportable === false) {\n        var layer = this._layer || parentLayer;\n        layer.tainted = true;\n      }\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"hovering\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._renderer._hovering.has(this);\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"dragging\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      return this._renderer._dragging.some(function (x) {\n        return x.value === _this;\n      });\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.getLayer().dirty = true;\n    }\n  });\n  Object.defineProperty(CanvasDisplayObject.prototype, \"shouldCancelTouch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var renderer = this._renderer;\n\n      if (renderer.tapToActivate && !renderer._touchActive) {\n        return false;\n      }\n\n      if (this.cancelTouch) {\n        return true;\n      } else if (this._parent) {\n        return this._parent.shouldCancelTouch();\n      }\n\n      return false;\n    }\n  });\n  return CanvasDisplayObject;\n}(DisposerClass);\n\nexport { CanvasDisplayObject };\n/**\r\n * @ignore\r\n */\n\nvar CanvasContainer =\n/** @class */\nfunction (_super) {\n  __extends(CanvasContainer, _super);\n\n  function CanvasContainer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"interactiveChildren\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(_this, \"_childLayers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_children\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    return _this;\n  }\n\n  Object.defineProperty(CanvasContainer.prototype, \"_isInteractiveMask\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this.interactiveChildren || _super.prototype._isInteractiveMask.call(this);\n    }\n  });\n  Object.defineProperty(CanvasContainer.prototype, \"addChild\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (child) {\n      child._parent = this;\n\n      this._children.push(child);\n\n      if (child._layer) {\n        this.registerChildLayer(child._layer);\n      }\n    }\n  });\n  Object.defineProperty(CanvasContainer.prototype, \"addChildAt\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (child, index) {\n      child._parent = this;\n\n      this._children.splice(index, 0, child);\n\n      if (child._layer) {\n        this.registerChildLayer(child._layer);\n      }\n    }\n  });\n  Object.defineProperty(CanvasContainer.prototype, \"removeChild\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (child) {\n      child._parent = undefined;\n      $array.removeFirst(this._children, child);\n    }\n  });\n  Object.defineProperty(CanvasContainer.prototype, \"_render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parentLayer) {\n      var _this = this;\n\n      _super.prototype._render.call(this, parentLayer);\n\n      var renderer = this._renderer;\n\n      if (this.interactive && this.interactiveChildren) {\n        ++renderer._forceInteractive;\n      }\n\n      var layer = this._layer || parentLayer;\n      $array.each(this._children, function (child) {\n        child.compoundAlpha = _this.compoundAlpha * _this.alpha;\n        child.render(layer);\n      });\n\n      if (this.interactive && this.interactiveChildren) {\n        --renderer._forceInteractive;\n      }\n    }\n  });\n  Object.defineProperty(CanvasContainer.prototype, \"registerChildLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (layer) {\n      if (!this._childLayers) {\n        this._childLayers = [];\n      }\n\n      $array.pushOne(this._childLayers, layer);\n\n      if (this._parent) {\n        this._parent.registerChildLayer(layer);\n      }\n    }\n  });\n  Object.defineProperty(CanvasContainer.prototype, \"markDirtyLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (deep) {\n      if (deep === void 0) {\n        deep = false;\n      }\n\n      _super.prototype.markDirtyLayer.call(this);\n\n      if (deep && this._childLayers) {\n        $array.each(this._childLayers, function (layer) {\n          return layer.dirty = true;\n        });\n      }\n    }\n  });\n  Object.defineProperty(CanvasContainer.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.dispose.call(this);\n\n      if (this._childLayers) {\n        $array.each(this._childLayers, function (layer) {\n          layer.dirty = true;\n        });\n      }\n    }\n  });\n  return CanvasContainer;\n}(CanvasDisplayObject);\n\nexport { CanvasContainer };\n/**\r\n * @ignore\r\n */\n\nfunction setPoint(bounds, point) {\n  bounds.left = Math.min(bounds.left, point.x);\n  bounds.top = Math.min(bounds.top, point.y);\n  bounds.right = Math.max(bounds.right, point.x);\n  bounds.bottom = Math.max(bounds.bottom, point.y);\n}\n/**\r\n * @ignore\r\n */\n\n\nvar Op =\n/** @class */\nfunction () {\n  function Op() {}\n\n  Object.defineProperty(Op.prototype, \"colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_context, _forceColor) {}\n  });\n  Object.defineProperty(Op.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_context) {}\n  });\n  Object.defineProperty(Op.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_bounds) {}\n  });\n  return Op;\n}();\n/**\r\n * @ignore\r\n */\n\n\nvar BeginFill =\n/** @class */\nfunction (_super) {\n  __extends(BeginFill, _super);\n\n  function BeginFill(color) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    return _this;\n  }\n\n  Object.defineProperty(BeginFill.prototype, \"colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, forceColor) {\n      if (forceColor !== undefined) {\n        context.fillStyle = forceColor;\n      } else {\n        context.fillStyle = this.color;\n      }\n    }\n  });\n  return BeginFill;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar EndFill =\n/** @class */\nfunction (_super) {\n  __extends(EndFill, _super);\n\n  function EndFill(clearShadow) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"clearShadow\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: clearShadow\n    });\n    return _this;\n  }\n\n  Object.defineProperty(EndFill.prototype, \"colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, _forceColor) {\n      context.fill();\n\n      if (this.clearShadow) {\n        context.shadowColor = \"\";\n        context.shadowBlur = 0;\n        context.shadowOffsetX = 0;\n        context.shadowOffsetY = 0;\n      }\n    }\n  });\n  return EndFill;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar EndStroke =\n/** @class */\nfunction (_super) {\n  __extends(EndStroke, _super);\n\n  function EndStroke() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(EndStroke.prototype, \"colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, _forceColor) {\n      context.stroke();\n    }\n  });\n  return EndStroke;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar LineStyle =\n/** @class */\nfunction (_super) {\n  __extends(LineStyle, _super);\n\n  function LineStyle(width, color, lineJoin) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(_this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    Object.defineProperty(_this, \"lineJoin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: lineJoin\n    });\n    return _this;\n  }\n\n  Object.defineProperty(LineStyle.prototype, \"colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, forceColor) {\n      if (forceColor !== undefined) {\n        context.strokeStyle = forceColor;\n      } else {\n        context.strokeStyle = this.color;\n      }\n\n      context.lineWidth = this.width;\n\n      if (this.lineJoin) {\n        context.lineJoin = this.lineJoin;\n      }\n    }\n  });\n  return LineStyle;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar LineDash =\n/** @class */\nfunction (_super) {\n  __extends(LineDash, _super);\n\n  function LineDash(dash) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"dash\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: dash\n    });\n    return _this;\n  }\n\n  Object.defineProperty(LineDash.prototype, \"colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, _forceColor) {\n      context.setLineDash(this.dash);\n    }\n  });\n  return LineDash;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar LineDashOffset =\n/** @class */\nfunction (_super) {\n  __extends(LineDashOffset, _super);\n\n  function LineDashOffset(dashOffset) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"dashOffset\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: dashOffset\n    });\n    return _this;\n  }\n\n  Object.defineProperty(LineDashOffset.prototype, \"colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, _forceColor) {\n      context.lineDashOffset = this.dashOffset;\n    }\n  });\n  return LineDashOffset;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar DrawRect =\n/** @class */\nfunction (_super) {\n  __extends(DrawRect, _super);\n\n  function DrawRect(x, y, width, height) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(_this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(_this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(_this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: height\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DrawRect.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.rect(this.x, this.y, this.width, this.height);\n    }\n  });\n  Object.defineProperty(DrawRect.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      var l = this.x;\n      var t = this.y;\n      var r = l + this.width;\n      var b = t + this.height;\n      setPoint(bounds, {\n        x: l,\n        y: t\n      });\n      setPoint(bounds, {\n        x: r,\n        y: t\n      });\n      setPoint(bounds, {\n        x: l,\n        y: b\n      });\n      setPoint(bounds, {\n        x: r,\n        y: b\n      });\n    }\n  });\n  return DrawRect;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar DrawCircle =\n/** @class */\nfunction (_super) {\n  __extends(DrawCircle, _super);\n\n  function DrawCircle(x, y, radius) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(_this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(_this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DrawCircle.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.moveTo(this.x + this.radius, this.y);\n      context.arc(this.x, this.y, this.radius, 0, 2 * Math.PI);\n    }\n  }); // TODO handle skewing and rotation\n\n  Object.defineProperty(DrawCircle.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      setPoint(bounds, {\n        x: this.x - this.radius,\n        y: this.y - this.radius\n      });\n      setPoint(bounds, {\n        x: this.x + this.radius,\n        y: this.y + this.radius\n      });\n    }\n  });\n  return DrawCircle;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar DrawEllipse =\n/** @class */\nfunction (_super) {\n  __extends(DrawEllipse, _super);\n\n  function DrawEllipse(x, y, radiusX, radiusY) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(_this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    Object.defineProperty(_this, \"radiusX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radiusX\n    });\n    Object.defineProperty(_this, \"radiusY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radiusY\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DrawEllipse.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.ellipse(0, 0, this.radiusX, this.radiusY, 0, 0, Math.PI * 2);\n    }\n  }); // TODO handle skewing and rotation\n\n  Object.defineProperty(DrawEllipse.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      setPoint(bounds, {\n        x: this.x - this.radiusX,\n        y: this.y - this.radiusY\n      });\n      setPoint(bounds, {\n        x: this.x + this.radiusX,\n        y: this.y + this.radiusY\n      });\n    }\n  });\n  return DrawEllipse;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar Arc =\n/** @class */\nfunction (_super) {\n  __extends(Arc, _super);\n\n  function Arc(cx, cy, radius, startAngle, endAngle, anticlockwise) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"cx\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cx\n    });\n    Object.defineProperty(_this, \"cy\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cy\n    });\n    Object.defineProperty(_this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n    Object.defineProperty(_this, \"startAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: startAngle\n    });\n    Object.defineProperty(_this, \"endAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: endAngle\n    });\n    Object.defineProperty(_this, \"anticlockwise\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: anticlockwise\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Arc.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      if (this.radius > 0) {\n        context.arc(this.cx, this.cy, this.radius, this.startAngle, this.endAngle, this.anticlockwise);\n      }\n    }\n  });\n  Object.defineProperty(Arc.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      var arcBounds = $math.getArcBounds(this.cx, this.cy, this.startAngle * $math.DEGREES, this.endAngle * $math.DEGREES, this.radius);\n      setPoint(bounds, {\n        x: arcBounds.left,\n        y: arcBounds.top\n      });\n      setPoint(bounds, {\n        x: arcBounds.right,\n        y: arcBounds.bottom\n      });\n    }\n  });\n  return Arc;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar ArcTo =\n/** @class */\nfunction (_super) {\n  __extends(ArcTo, _super);\n\n  function ArcTo(x1, y1, x2, y2, radius) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"x1\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x1\n    });\n    Object.defineProperty(_this, \"y1\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y1\n    });\n    Object.defineProperty(_this, \"x2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x2\n    });\n    Object.defineProperty(_this, \"y2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y2\n    });\n    Object.defineProperty(_this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: radius\n    });\n    return _this;\n  }\n\n  Object.defineProperty(ArcTo.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      if (this.radius > 0) {\n        context.arcTo(this.x1, this.y1, this.x2, this.y2, this.radius);\n      }\n    }\n  }); // TODO: add points\n\n  Object.defineProperty(ArcTo.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_bounds) {\n      /*\r\n      // not finished\r\n      https://math.stackexchange.com/questions/1781438/finding-the-center-of-a-circle-given-two-points-and-a-radius-algebraically\r\n            if (prevPoint) {\r\n          let x1 = prevPoint.x;\r\n          let y1 = prevPoint.y;\r\n          let x2 = this.x2;\r\n          let y2 = this.y2;\r\n          let r = this.radius;\r\n                let xa = (x2 - x1) / 2;\r\n          let ya = (y2 - y1) / 2;\r\n                let x0 = x1 + xa;\r\n          let y0 = y1 + ya;\r\n                let a = Math.hypot(xa, ya);\r\n          let b = Math.sqrt(r * r - a * a);\r\n                let cx = x0 + b * ya / a;\r\n          let cy = y0 - b * xa / a;\r\n                console.log(cx, cy);\r\n      }*/\n    }\n  });\n  return ArcTo;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar LineTo =\n/** @class */\nfunction (_super) {\n  __extends(LineTo, _super);\n\n  function LineTo(x, y) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(_this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    return _this;\n  }\n\n  Object.defineProperty(LineTo.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.lineTo(this.x, this.y);\n    }\n  });\n  Object.defineProperty(LineTo.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      setPoint(bounds, {\n        x: this.x,\n        y: this.y\n      });\n    }\n  });\n  return LineTo;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar MoveTo =\n/** @class */\nfunction (_super) {\n  __extends(MoveTo, _super);\n\n  function MoveTo(x, y) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(_this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    return _this;\n  }\n\n  Object.defineProperty(MoveTo.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.moveTo(this.x, this.y);\n    }\n  });\n  Object.defineProperty(MoveTo.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      setPoint(bounds, {\n        x: this.x,\n        y: this.y\n      });\n    }\n  });\n  return MoveTo;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar ClosePath =\n/** @class */\nfunction (_super) {\n  __extends(ClosePath, _super);\n\n  function ClosePath() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(ClosePath.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.closePath();\n    }\n  });\n  return ClosePath;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar BezierCurveTo =\n/** @class */\nfunction (_super) {\n  __extends(BezierCurveTo, _super);\n\n  function BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"cpX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX\n    });\n    Object.defineProperty(_this, \"cpY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY\n    });\n    Object.defineProperty(_this, \"cpX2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX2\n    });\n    Object.defineProperty(_this, \"cpY2\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY2\n    });\n    Object.defineProperty(_this, \"toX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toX\n    });\n    Object.defineProperty(_this, \"toY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toY\n    });\n    return _this;\n  }\n\n  Object.defineProperty(BezierCurveTo.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.bezierCurveTo(this.cpX, this.cpY, this.cpX2, this.cpY2, this.toX, this.toY);\n    }\n  }); // TODO: OK?\n\n  Object.defineProperty(BezierCurveTo.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      setPoint(bounds, {\n        x: this.cpX,\n        y: this.cpY\n      });\n      setPoint(bounds, {\n        x: this.cpX2,\n        y: this.cpY2\n      });\n      setPoint(bounds, {\n        x: this.toX,\n        y: this.toY\n      });\n    }\n  });\n  return BezierCurveTo;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar QuadraticCurveTo =\n/** @class */\nfunction (_super) {\n  __extends(QuadraticCurveTo, _super);\n\n  function QuadraticCurveTo(cpX, cpY, toX, toY) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"cpX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpX\n    });\n    Object.defineProperty(_this, \"cpY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: cpY\n    });\n    Object.defineProperty(_this, \"toX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toX\n    });\n    Object.defineProperty(_this, \"toY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: toY\n    });\n    return _this;\n  }\n\n  Object.defineProperty(QuadraticCurveTo.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.quadraticCurveTo(this.cpX, this.cpY, this.toX, this.toY);\n    }\n  }); // TODO: OK?\n\n  Object.defineProperty(QuadraticCurveTo.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      setPoint(bounds, {\n        x: this.cpX,\n        y: this.cpY\n      });\n      setPoint(bounds, {\n        x: this.toX,\n        y: this.toY\n      });\n    }\n  });\n  return QuadraticCurveTo;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar Shadow =\n/** @class */\nfunction (_super) {\n  __extends(Shadow, _super);\n\n  function Shadow(color, blur, offsetX, offsetY, opacity) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"color\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: color\n    });\n    Object.defineProperty(_this, \"blur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: blur\n    });\n    Object.defineProperty(_this, \"offsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: offsetX\n    });\n    Object.defineProperty(_this, \"offsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: offsetY\n    });\n    Object.defineProperty(_this, \"opacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: opacity\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Shadow.prototype, \"colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, _forceColor) {\n      if (this.opacity) {\n        context.fillStyle = this.color;\n      }\n\n      context.shadowColor = this.color;\n      context.shadowBlur = this.blur;\n      context.shadowOffsetX = this.offsetX;\n      context.shadowOffsetY = this.offsetY;\n    }\n  });\n  return Shadow;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar GraphicsImage =\n/** @class */\nfunction (_super) {\n  __extends(GraphicsImage, _super);\n\n  function GraphicsImage(image, width, height, x, y) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"image\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: image\n    });\n    Object.defineProperty(_this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: width\n    });\n    Object.defineProperty(_this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: height\n    });\n    Object.defineProperty(_this, \"x\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: x\n    });\n    Object.defineProperty(_this, \"y\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: y\n    });\n    return _this;\n  }\n\n  Object.defineProperty(GraphicsImage.prototype, \"path\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.drawImage(this.image, this.x, this.y, this.width, this.height);\n    }\n  }); // TODO: OK?\n\n  Object.defineProperty(GraphicsImage.prototype, \"addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      setPoint(bounds, {\n        x: this.x,\n        y: this.y\n      });\n      setPoint(bounds, {\n        x: this.width,\n        y: this.height\n      });\n    }\n  });\n  return GraphicsImage;\n}(Op);\n/**\r\n * @ignore\r\n */\n\n\nvar CanvasGraphics =\n/** @class */\nfunction (_super) {\n  __extends(CanvasGraphics, _super);\n\n  function CanvasGraphics() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_operations\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_this, \"blendMode\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: BlendMode.NORMAL\n    });\n    Object.defineProperty(_this, \"_hasShadows\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_fillAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_strokeAlpha\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    return _this;\n  }\n\n  Object.defineProperty(CanvasGraphics.prototype, \"clear\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.clear.call(this);\n\n      this._operations.length = 0;\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"_pushOp\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (op) {\n      this._operations.push(op);\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"beginFill\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (color, alpha) {\n      if (alpha === void 0) {\n        alpha = 1;\n      }\n\n      this._fillAlpha = alpha;\n\n      if (color) {\n        if (color instanceof Color) {\n          this._pushOp(new BeginFill(color.toCSS(alpha)));\n        } else {\n          this.isMeasured = true;\n\n          this._pushOp(new BeginFill(color));\n        }\n      } else {\n        this._pushOp(new BeginFill(\"rgba(0, 0, 0, \" + alpha + \")\"));\n      }\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"endFill\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._pushOp(new EndFill(this._hasShadows));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"endStroke\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._pushOp(new EndStroke());\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"lineStyle\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (width, color, alpha, lineJoin) {\n      if (width === void 0) {\n        width = 0;\n      }\n\n      if (alpha === void 0) {\n        alpha = 1;\n      }\n\n      this._strokeAlpha = alpha;\n\n      if (color) {\n        if (color instanceof Color) {\n          this._pushOp(new LineStyle(width, color.toCSS(alpha), lineJoin));\n        } else {\n          this._pushOp(new LineStyle(width, color, lineJoin));\n        }\n      } else {\n        this._pushOp(new LineStyle(width, \"rgba(0, 0, 0, \" + alpha + \")\", lineJoin));\n      }\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"setLineDash\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dash) {\n      this._pushOp(new LineDash(dash ? dash : []));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"setLineDashOffset\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dashOffset) {\n      if (dashOffset === void 0) {\n        dashOffset = 0;\n      }\n\n      this._pushOp(new LineDashOffset(dashOffset));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"drawRect\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (x, y, width, height) {\n      this._pushOp(new DrawRect(x, y, width, height));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"drawCircle\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (x, y, radius) {\n      this._pushOp(new DrawCircle(x, y, radius));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"drawEllipse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (x, y, radiusX, radiusY) {\n      this._pushOp(new DrawEllipse(x, y, radiusX, radiusY));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"arc\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (cx, cy, radius, startAngle, endAngle, anticlockwise) {\n      if (anticlockwise === void 0) {\n        anticlockwise = false;\n      }\n\n      this._pushOp(new Arc(cx, cy, radius, startAngle, endAngle, anticlockwise));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"arcTo\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (x1, y1, x2, y2, radius) {\n      this._pushOp(new ArcTo(x1, y1, x2, y2, radius));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"lineTo\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (x, y) {\n      this._pushOp(new LineTo(x, y));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"moveTo\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (x, y) {\n      this._pushOp(new MoveTo(x, y));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"bezierCurveTo\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (cpX, cpY, cpX2, cpY2, toX, toY) {\n      this._pushOp(new BezierCurveTo(cpX, cpY, cpX2, cpY2, toX, toY));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"quadraticCurveTo\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (cpX, cpY, toX, toY) {\n      this._pushOp(new QuadraticCurveTo(cpX, cpY, toX, toY));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"closePath\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._pushOp(new ClosePath());\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"shadow\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (color, blur, offsetX, offsetY, opacity) {\n      if (blur === void 0) {\n        blur = 0;\n      }\n\n      if (offsetX === void 0) {\n        offsetX = 0;\n      }\n\n      if (offsetY === void 0) {\n        offsetY = 0;\n      }\n\n      this._hasShadows = true;\n\n      this._pushOp(new Shadow(opacity ? color.toCSS(opacity) : color.toCSS(this._fillAlpha || this._strokeAlpha), blur, offsetX, offsetY));\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"image\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (image, width, height, x, y) {\n      this._pushOp(new GraphicsImage(image, width, height, x, y));\n    }\n  }); // https://svgwg.org/svg2-draft/paths.html#DProperty\n  // TODO better error checking\n\n  Object.defineProperty(CanvasGraphics.prototype, \"svgPath\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (path) {\n      var _this = this;\n\n      var x = 0;\n      var y = 0;\n      var cpx = null;\n      var cpy = null;\n      var qcpx = null;\n      var qcpy = null;\n      var SEGMENTS_REGEXP = /([MmZzLlHhVvCcSsQqTtAa])([^MmZzLlHhVvCcSsQqTtAa]*)/g;\n      var ARGS_REGEXP = /[\\u0009\\u0020\\u000A\\u000C\\u000D]*([\\+\\-]?[0-9]*\\.?[0-9]+(?:[eE][\\+\\-]?[0-9]+)?)[\\u0009\\u0020\\u000A\\u000C\\u000D]*,?/g;\n      var match;\n\n      while ((match = SEGMENTS_REGEXP.exec(path)) !== null) {\n        var name_1 = match[1];\n        var rest = match[2];\n        var args = [];\n\n        while ((match = ARGS_REGEXP.exec(rest)) !== null) {\n          args.push(match[1]);\n        } // Reset control point\n\n\n        if (name_1 !== \"S\" && name_1 !== \"s\" && name_1 !== \"C\" && name_1 !== \"c\") {\n          cpx = null;\n          cpy = null;\n        } // Reset control point\n\n\n        if (name_1 !== \"Q\" && name_1 !== \"q\" && name_1 !== \"T\" && name_1 !== \"t\") {\n          qcpx = null;\n          qcpy = null;\n        }\n\n        switch (name_1) {\n          case \"M\":\n            checkEvenArgs(name_1, args.length, 2);\n            x = +args[0];\n            y = +args[1];\n            this.moveTo(x, y);\n\n            for (var i = 2; i < args.length; i += 2) {\n              x = +args[i];\n              y = +args[i + 1];\n              this.lineTo(x, y);\n            }\n\n            break;\n\n          case \"m\":\n            checkEvenArgs(name_1, args.length, 2);\n            x += +args[0];\n            y += +args[1];\n            this.moveTo(x, y);\n\n            for (var i = 2; i < args.length; i += 2) {\n              x += +args[i];\n              y += +args[i + 1];\n              this.lineTo(x, y);\n            }\n\n            break;\n\n          case \"L\":\n            checkEvenArgs(name_1, args.length, 2);\n\n            for (var i = 0; i < args.length; i += 2) {\n              x = +args[i];\n              y = +args[i + 1];\n              this.lineTo(x, y);\n            }\n\n            break;\n\n          case \"l\":\n            checkEvenArgs(name_1, args.length, 2);\n\n            for (var i = 0; i < args.length; i += 2) {\n              x += +args[i];\n              y += +args[i + 1];\n              this.lineTo(x, y);\n            }\n\n            break;\n\n          case \"H\":\n            checkMinArgs(name_1, args.length, 1);\n\n            for (var i = 0; i < args.length; ++i) {\n              x = +args[i];\n              this.lineTo(x, y);\n            }\n\n            break;\n\n          case \"h\":\n            checkMinArgs(name_1, args.length, 1);\n\n            for (var i = 0; i < args.length; ++i) {\n              x += +args[i];\n              this.lineTo(x, y);\n            }\n\n            break;\n\n          case \"V\":\n            checkMinArgs(name_1, args.length, 1);\n\n            for (var i = 0; i < args.length; ++i) {\n              y = +args[i];\n              this.lineTo(x, y);\n            }\n\n            break;\n\n          case \"v\":\n            checkMinArgs(name_1, args.length, 1);\n\n            for (var i = 0; i < args.length; ++i) {\n              y += +args[i];\n              this.lineTo(x, y);\n            }\n\n            break;\n\n          case \"C\":\n            checkEvenArgs(name_1, args.length, 6);\n\n            for (var i = 0; i < args.length; i += 6) {\n              var x1 = +args[i];\n              var y1 = +args[i + 1];\n              cpx = +args[i + 2];\n              cpy = +args[i + 3];\n              x = +args[i + 4];\n              y = +args[i + 5];\n              this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n            }\n\n            break;\n\n          case \"c\":\n            checkEvenArgs(name_1, args.length, 6);\n\n            for (var i = 0; i < args.length; i += 6) {\n              var x1 = +args[i] + x;\n              var y1 = +args[i + 1] + y;\n              cpx = +args[i + 2] + x;\n              cpy = +args[i + 3] + y;\n              x += +args[i + 4];\n              y += +args[i + 5];\n              this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n            }\n\n            break;\n\n          case \"S\":\n            checkEvenArgs(name_1, args.length, 4);\n\n            if (cpx === null || cpy === null) {\n              cpx = x;\n              cpy = y;\n            }\n\n            for (var i = 0; i < args.length; i += 4) {\n              var x1 = 2 * x - cpx;\n              var y1 = 2 * y - cpy;\n              cpx = +args[i];\n              cpy = +args[i + 1];\n              x = +args[i + 2];\n              y = +args[i + 3];\n              this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n            }\n\n            break;\n\n          case \"s\":\n            checkEvenArgs(name_1, args.length, 4);\n\n            if (cpx === null || cpy === null) {\n              cpx = x;\n              cpy = y;\n            }\n\n            for (var i = 0; i < args.length; i += 4) {\n              var x1 = 2 * x - cpx;\n              var y1 = 2 * y - cpy;\n              cpx = +args[i] + x;\n              cpy = +args[i + 1] + y;\n              x += +args[i + 2];\n              y += +args[i + 3];\n              this.bezierCurveTo(x1, y1, cpx, cpy, x, y);\n            }\n\n            break;\n\n          case \"Q\":\n            checkEvenArgs(name_1, args.length, 4);\n\n            for (var i = 0; i < args.length; i += 4) {\n              qcpx = +args[i];\n              qcpy = +args[i + 1];\n              x = +args[i + 2];\n              y = +args[i + 3];\n              this.quadraticCurveTo(qcpx, qcpy, x, y);\n            }\n\n            break;\n\n          case \"q\":\n            checkEvenArgs(name_1, args.length, 4);\n\n            for (var i = 0; i < args.length; i += 4) {\n              qcpx = +args[i] + x;\n              qcpy = +args[i + 1] + y;\n              x += +args[i + 2];\n              y += +args[i + 3];\n              this.quadraticCurveTo(qcpx, qcpy, x, y);\n            }\n\n            break;\n\n          case \"T\":\n            checkEvenArgs(name_1, args.length, 2);\n\n            if (qcpx === null || qcpy === null) {\n              qcpx = x;\n              qcpy = y;\n            }\n\n            for (var i = 0; i < args.length; i += 2) {\n              qcpx = 2 * x - qcpx;\n              qcpy = 2 * y - qcpy;\n              x = +args[i];\n              y = +args[i + 1];\n              this.quadraticCurveTo(qcpx, qcpy, x, y);\n            }\n\n            break;\n\n          case \"t\":\n            checkEvenArgs(name_1, args.length, 2);\n\n            if (qcpx === null || qcpy === null) {\n              qcpx = x;\n              qcpy = y;\n            }\n\n            for (var i = 0; i < args.length; i += 2) {\n              qcpx = 2 * x - qcpx;\n              qcpy = 2 * y - qcpy;\n              x += +args[i];\n              y += +args[i + 1];\n              this.quadraticCurveTo(qcpx, qcpy, x, y);\n            }\n\n            break;\n\n          case \"A\":\n          case \"a\":\n            var relative = name_1 === \"a\";\n            splitArcFlags(args);\n            checkEvenArgs(name_1, args.length, 7);\n\n            for (var i = 0; i < args.length; i += 7) {\n              var cx = +args[i + 5];\n              var cy = +args[i + 6];\n\n              if (relative) {\n                cx += x;\n                cy += y;\n              }\n\n              var bs = arcToBezier({\n                px: x,\n                py: y,\n                rx: +args[i],\n                ry: +args[i + 1],\n                xAxisRotation: +args[i + 2],\n                largeArcFlag: assertBinary(+args[i + 3]),\n                sweepFlag: assertBinary(+args[i + 4]),\n                cx: cx,\n                cy: cy\n              });\n              $array.each(bs, function (b) {\n                _this.bezierCurveTo(b.x1, b.y1, b.x2, b.y2, b.x, b.y);\n\n                x = b.x;\n                y = b.y;\n              });\n            }\n\n            break;\n\n          case \"Z\":\n          case \"z\":\n            checkArgs(name_1, args.length, 0);\n            this.closePath();\n            break;\n        }\n      }\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"_runPath\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      context.beginPath();\n      $array.each(this._operations, function (op) {\n        op.path(context);\n      });\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"_render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parentLayer) {\n      _super.prototype._render.call(this, parentLayer);\n\n      var layer = this._layer || parentLayer;\n      var layerDirty = layer.dirty;\n\n      var interactive = this._isInteractive();\n\n      if (layerDirty || interactive) {\n        var context_1 = layer.context;\n        var ghostContext_1 = this._renderer._ghostLayer.context;\n\n        if (layerDirty) {\n          context_1.globalCompositeOperation = this.blendMode;\n          context_1.beginPath();\n        }\n\n        var color_1;\n\n        if (interactive) {\n          ghostContext_1.beginPath();\n          color_1 = this._getColorId();\n        }\n\n        $array.each(this._operations, function (op) {\n          if (layerDirty) {\n            op.path(context_1);\n            op.colorize(context_1, undefined);\n          }\n\n          if (interactive) {\n            op.path(ghostContext_1);\n            op.colorize(ghostContext_1, color_1);\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"renderDetached\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      if (this.visible) {\n        this._setMatrix();\n\n        context.save(); // We must apply the mask before we transform the element\n\n        var mask = this.mask;\n\n        if (mask) {\n          mask._setMatrix();\n\n          mask._transform(context, 1);\n\n          mask._runPath(context);\n\n          context.clip();\n        } // TODO handle compoundAlpha somehow ?\n\n\n        context.globalAlpha = this.compoundAlpha * this.alpha;\n\n        this._transform(context, 1);\n\n        if (this.filter) {\n          context.filter = this.filter;\n        }\n\n        context.globalCompositeOperation = this.blendMode;\n        context.beginPath();\n        $array.each(this._operations, function (op) {\n          op.path(context);\n          op.colorize(context, undefined);\n        });\n        context.restore();\n      }\n    }\n  });\n  Object.defineProperty(CanvasGraphics.prototype, \"_addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      if (this.visible && this.isMeasured) {\n        $array.each(this._operations, function (op) {\n          op.addBounds(bounds);\n        });\n      }\n    }\n  });\n  return CanvasGraphics;\n}(CanvasDisplayObject);\n\nexport { CanvasGraphics };\n/**\r\n * @ignore\r\n */\n\nvar CanvasText =\n/** @class */\nfunction (_super) {\n  __extends(CanvasText, _super);\n\n  function CanvasText(renderer, text, style) {\n    var _this = _super.call(this, renderer) || this;\n\n    Object.defineProperty(_this, \"text\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"style\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"resolution\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_textInfo\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_textVisible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(_this, \"_originalScale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    _this.text = text;\n    _this.style = style;\n    return _this;\n  }\n\n  Object.defineProperty(CanvasText.prototype, \"invalidateBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.invalidateBounds.call(this);\n\n      this._textInfo = undefined;\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_shared\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context) {\n      if (this.style.textAlign) {\n        context.textAlign = this.style.textAlign;\n      }\n\n      if (this.style.direction) {\n        context.direction = this.style.direction;\n      }\n\n      if (this.style.textBaseline) {\n        context.textBaseline = this.style.textBaseline;\n      }\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_prerender\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (layer, ignoreGhost, ignoreFontWeight) {\n      if (ignoreGhost === void 0) {\n        ignoreGhost = false;\n      }\n\n      if (ignoreFontWeight === void 0) {\n        ignoreFontWeight = false;\n      }\n\n      _super.prototype._render.call(this, layer);\n\n      var context = layer.context;\n      var ghostContext = this._renderer._ghostLayer.context; // Font style\n\n      var style = this.style;\n\n      var fontStyle = this._getFontStyle(undefined, ignoreFontWeight);\n\n      context.font = fontStyle;\n\n      if (this._isInteractive() && !ignoreGhost) {\n        ghostContext.font = fontStyle;\n      } // Other parameters\n\n\n      if (style.fill) {\n        if (style.fill instanceof Color) {\n          context.fillStyle = style.fill.toCSS(style.fillOpacity != undefined ? style.fillOpacity : 1);\n        } else {\n          context.fillStyle = style.fill;\n        }\n      }\n\n      if (style.shadowColor) {\n        layer.context.shadowColor = style.shadowColor.toCSS(style.shadowOpacity || 1);\n      }\n\n      if (style.shadowBlur) {\n        layer.context.shadowBlur = style.shadowBlur;\n      }\n\n      if (style.shadowOffsetX) {\n        layer.context.shadowOffsetX = style.shadowOffsetX;\n      }\n\n      if (style.shadowOffsetY) {\n        layer.context.shadowOffsetY = style.shadowOffsetY;\n      }\n\n      this._shared(context);\n\n      if (this._isInteractive() && !ignoreGhost) {\n        ghostContext.fillStyle = this._getColorId();\n\n        this._shared(ghostContext);\n      }\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_getFontStyle\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (style2, ignoreFontWeight) {\n      if (ignoreFontWeight === void 0) {\n        ignoreFontWeight = false;\n      } // Process defaults\n\n\n      var style = this.style;\n      var fontStyle = [];\n\n      if (style2 && style2.fontVariant) {\n        fontStyle.push(style2.fontVariant);\n      } else if (style.fontVariant) {\n        fontStyle.push(style.fontVariant);\n      }\n\n      if (!ignoreFontWeight) {\n        if (style2 && style2.fontWeight) {\n          fontStyle.push(style2.fontWeight);\n        } else if (style.fontWeight) {\n          fontStyle.push(style.fontWeight);\n        }\n      }\n\n      if (style2 && style2.fontStyle) {\n        fontStyle.push(style2.fontStyle);\n      } else if (style.fontStyle) {\n        fontStyle.push(style.fontStyle);\n      }\n\n      if (style2 && style2.fontSize) {\n        if ($type.isNumber(style2.fontSize)) {\n          style2.fontSize = style2.fontSize + \"px\";\n        }\n\n        fontStyle.push(style2.fontSize);\n      } else if (style.fontSize) {\n        if ($type.isNumber(style.fontSize)) {\n          style.fontSize = style.fontSize + \"px\";\n        }\n\n        fontStyle.push(style.fontSize);\n      }\n\n      if (style2 && style2.fontFamily) {\n        fontStyle.push(style2.fontFamily);\n      } else if (style.fontFamily) {\n        fontStyle.push(style.fontFamily);\n      } else if (fontStyle.length) {\n        fontStyle.push(\"Arial\");\n      }\n\n      return fontStyle.join(\" \");\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parentLayer) {\n      var _this = this;\n\n      var layer = this._layer || parentLayer; // We need measurements in order to properly position text for alignment\n\n      if (!this._textInfo) {\n        this._measure(layer);\n      }\n\n      if (this._textVisible) {\n        var interactive_1 = this._isInteractive();\n\n        var context_2 = layer.context;\n        var layerDirty_1 = layer.dirty;\n        var ghostContext_2 = this._renderer._ghostLayer.context;\n        context_2.save();\n        ghostContext_2.save();\n\n        this._prerender(layer); // const lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n        // const x = this._localBounds && (this._localBounds.left < 0) ? Math.abs(this._localBounds.left) : 0;\n        // Process text info produced by _measure()\n\n\n        $array.each(this._textInfo, function (line, _index) {\n          $array.each(line.textChunks, function (chunk, _index) {\n            // Set style\n            if (chunk.style) {\n              context_2.save();\n              ghostContext_2.save();\n              context_2.font = chunk.style;\n\n              if (_this._isInteractive()) {\n                ghostContext_2.font = chunk.style;\n              }\n            }\n\n            if (chunk.fill) {\n              context_2.save();\n              context_2.fillStyle = chunk.fill.toCSS(); // Color does not affect ghostContext so we not set it\n            } // Draw text\n\n\n            if (layerDirty_1) {\n              context_2.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n            } // Draw underline\n\n\n            if (chunk.textDecoration == \"underline\" || chunk.textDecoration == \"line-through\") {\n              var thickness = 1;\n              var offset = 1;\n              var fontSize = chunk.height;\n              var offsetX = chunk.offsetX;\n\n              switch (_this.style.textAlign) {\n                case \"right\":\n                case \"end\":\n                  offsetX -= chunk.width;\n                  break;\n\n                case \"center\":\n                  offsetX -= chunk.width / 2;\n                  break;\n              }\n\n              if (chunk.style) {\n                var format = TextFormatter.getTextStyle(chunk.style);\n\n                switch (format.fontWeight) {\n                  case \"bolder\":\n                  case \"bold\":\n                  case \"700\":\n                  case \"800\":\n                  case \"900\":\n                    thickness = 2;\n                    break;\n                }\n              }\n\n              if (fontSize) {\n                offset = fontSize / 20;\n              }\n\n              var y = void 0;\n\n              if (chunk.textDecoration == \"line-through\") {\n                y = thickness + line.offsetY + chunk.offsetY - chunk.height / 2;\n              } else {\n                y = thickness + offset * 1.5 + line.offsetY + chunk.offsetY;\n              }\n\n              context_2.save();\n              context_2.beginPath();\n\n              if (chunk.fill) {\n                context_2.strokeStyle = chunk.fill.toCSS();\n              } else if (_this.style.fill && _this.style.fill instanceof Color) {\n                context_2.strokeStyle = _this.style.fill.toCSS();\n              }\n\n              context_2.lineWidth = thickness * offset;\n              context_2.moveTo(offsetX, y);\n              context_2.lineTo(offsetX + chunk.width, y);\n              context_2.stroke();\n              context_2.restore();\n            }\n\n            if (interactive_1 && _this.interactive) {\n              // Draw text in ghost canvas ONLY if it is set as interactive\n              // explicitly. This way we avoid hit test anomalies caused by anti\n              // aliasing of text.\n              ghostContext_2.fillText(chunk.text, chunk.offsetX, line.offsetY + chunk.offsetY);\n            }\n\n            if (chunk.fill) {\n              context_2.restore(); // Color does not affect ghostContext so we not set it\n            } // Reset style\n\n\n            if (chunk.style) {\n              context_2.restore();\n              ghostContext_2.restore();\n            }\n          });\n        });\n        context_2.restore();\n        ghostContext_2.restore();\n      }\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_addBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      if (this.visible && this.isMeasured) {\n        //if (this._textVisible) {\n        var x = this._measure(this.getLayer());\n\n        setPoint(bounds, {\n          x: x.left,\n          y: x.top\n        });\n        setPoint(bounds, {\n          x: x.right,\n          y: x.bottom\n        }); //}\n      }\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_ignoreFontWeight\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return /apple/i.test(navigator.vendor);\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_measure\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (layer) {\n      var _this = this;\n\n      var context = layer.context;\n      var ghostContext = this._renderer._ghostLayer.context;\n      var rtl = this.style.direction == \"rtl\"; // Reset text info\n\n      this._textInfo = []; // Init\n\n      var oversizedBehavior = this.style.oversizedBehavior;\n      var maxWidth = this.style.maxWidth;\n      var truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n      var wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\"); // Pre-render\n\n      context.save();\n      ghostContext.save();\n\n      this._prerender(layer, true, this._ignoreFontWeight()); // Get default font metrix\n\n\n      var refText = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 \"; // Split up text into lines\n\n      var lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n      var styleRestored = true;\n      var minX = 0;\n      var maxX = 0; // Iterate through the lines\n\n      var offsetY = 0;\n      var currentStyle;\n      $array.each(lines, function (line, _index) {\n        // Split up line into format/value chunks\n        var chunks;\n\n        if (line == \"\") {\n          chunks = [{\n            type: \"value\",\n            text: \"\"\n          }];\n        } else {\n          chunks = TextFormatter.chunk(line, false, _this.style.ignoreFormatting);\n        }\n\n        var _loop_1 = function () {\n          // Init line object\n          var lineInfo = {\n            offsetY: offsetY,\n            ascent: 0,\n            width: 0,\n            height: 0,\n            left: 0,\n            right: 0,\n            textChunks: []\n          }; // Measure reference text\n\n          var metrics = _this._measureText(refText, context);\n\n          var height = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n          lineInfo.height = height;\n          lineInfo.ascent = metrics.actualBoundingBoxAscent;\n          var currentFormat;\n          var currentDecoration = _this.style.textDecoration;\n          var currentFill;\n          var currentChunkWidth;\n          var skipFurtherText = false;\n          var firstTextChunk = true;\n          var leftoverChunks = [];\n          var currentVerticalAlign; //let offsetX = 0;\n          //let chunk;\n          //while(chunk = chunks.shift()) {\n\n          $array.eachContinue(chunks, function (chunk, index) {\n            // Format chunk\n            if (chunk.type == \"format\") {\n              if (chunk.text == \"[/]\") {\n                if (!styleRestored) {\n                  context.restore();\n                  ghostContext.restore();\n                  styleRestored = true;\n                }\n\n                currentFill = undefined;\n                currentStyle = undefined;\n                currentChunkWidth = undefined;\n                currentDecoration = _this.style.textDecoration;\n                currentVerticalAlign = undefined;\n                currentFormat = chunk.text;\n              } else {\n                if (!styleRestored) {\n                  context.restore();\n                  ghostContext.restore();\n                }\n\n                var format = TextFormatter.getTextStyle(chunk.text);\n\n                var fontStyle = _this._getFontStyle(format);\n\n                context.save();\n                ghostContext.save();\n                context.font = fontStyle;\n                currentStyle = fontStyle;\n                currentFormat = chunk.text;\n\n                if (format.textDecoration) {\n                  currentDecoration = format.textDecoration;\n                }\n\n                if (format.fill) {\n                  currentFill = format.fill;\n                }\n\n                if (format.width) {\n                  currentChunkWidth = $type.toNumber(format.width);\n                }\n\n                if (format.verticalAlign) {\n                  currentVerticalAlign = format.verticalAlign;\n                }\n\n                styleRestored = false; // Measure reference text after change of format\n\n                var metrics_1 = _this._measureText(refText, context);\n\n                var height_1 = metrics_1.actualBoundingBoxAscent + metrics_1.actualBoundingBoxDescent;\n\n                if (height_1 > lineInfo.height) {\n                  lineInfo.height = height_1;\n                }\n\n                if (metrics_1.actualBoundingBoxAscent > lineInfo.ascent) {\n                  lineInfo.ascent = metrics_1.actualBoundingBoxAscent;\n                }\n              }\n            } // Text chunk\n            else if (chunk.type == \"value\" && !skipFurtherText) {\n              // Measure\n              var metrics_2 = _this._measureText(chunk.text, context);\n\n              var chunkWidth = metrics_2.actualBoundingBoxLeft + metrics_2.actualBoundingBoxRight; // Check for fit\n\n              if (truncate) {\n                // Break words?\n                var breakWords = firstTextChunk || _this.style.breakWords || false; // Measure ellipsis and check if it fits\n\n                var ellipsis = _this.style.ellipsis || \"\";\n\n                var ellipsisMetrics = _this._measureText(ellipsis, context);\n\n                var ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight; // Check fit\n\n                if (lineInfo.width + chunkWidth > maxWidth) {\n                  var excessWidth = maxWidth - lineInfo.width - ellipsisWidth;\n                  chunk.text = _this._truncateText(context, chunk.text, excessWidth, breakWords);\n                  chunk.text += ellipsis;\n                  skipFurtherText = true;\n                }\n              } else if (wrap) {\n                // Check fit\n                if (lineInfo.width + chunkWidth > maxWidth) {\n                  var excessWidth = maxWidth - lineInfo.width;\n\n                  var tmpText = _this._truncateText(context, chunk.text, excessWidth, false, firstTextChunk && _this.style.oversizedBehavior != \"wrap-no-break\");\n\n                  if (tmpText == \"\") {\n                    // Unable to fit a single letter - hide the whole label\n                    _this._textVisible = true;\n                    return false;\n                  } //skipFurtherText = true;\n                  //Add remaining chunks for the next line\n\n\n                  leftoverChunks = chunks.slice(index + 1); //Add remaining text of current chunk if it was forced-cut\n\n                  if ($utils.trim(tmpText) != $utils.trim(chunk.text)) {\n                    leftoverChunks.unshift({\n                      type: \"value\",\n                      text: chunk.text.substr(tmpText.length)\n                    });\n\n                    if (currentFormat) {\n                      leftoverChunks.unshift({\n                        type: \"format\",\n                        text: currentFormat\n                      });\n                    }\n                  } // Set current chunk (truncated)\n\n\n                  chunk.text = $utils.trim(tmpText);\n                  chunks = [];\n                  skipFurtherText = true;\n                }\n              } // Chunk width?\n\n\n              var leftBoundMod = 1;\n              var rightBoundMod = 1;\n\n              if (currentStyle && currentChunkWidth && currentChunkWidth > chunkWidth) {\n                // increase horizontal bounding boxes accordingly\n                var boundsMod = chunkWidth / currentChunkWidth;\n\n                switch (_this.style.textAlign) {\n                  case \"right\":\n                  case \"end\":\n                    leftBoundMod = boundsMod;\n                    break;\n\n                  case \"center\":\n                    leftBoundMod = boundsMod;\n                    rightBoundMod = boundsMod;\n                    break;\n\n                  default:\n                    rightBoundMod = boundsMod;\n                }\n\n                chunkWidth = currentChunkWidth;\n              }\n\n              var chunkHeight = metrics_2.actualBoundingBoxAscent + metrics_2.actualBoundingBoxDescent;\n\n              if (chunkHeight > lineInfo.height) {\n                lineInfo.height = chunkHeight;\n              }\n\n              if (metrics_2.actualBoundingBoxAscent > lineInfo.ascent) {\n                lineInfo.ascent = metrics_2.actualBoundingBoxAscent;\n              }\n\n              lineInfo.width += chunkWidth;\n              lineInfo.left += metrics_2.actualBoundingBoxLeft / leftBoundMod;\n              lineInfo.right += metrics_2.actualBoundingBoxRight / rightBoundMod;\n              lineInfo.textChunks.push({\n                style: currentStyle,\n                fill: currentFill,\n                text: chunk.text,\n                width: chunkWidth,\n                height: chunkHeight,\n                left: metrics_2.actualBoundingBoxLeft,\n                right: metrics_2.actualBoundingBoxRight,\n                ascent: metrics_2.actualBoundingBoxAscent,\n                offsetX: 0,\n                offsetY: 0,\n                textDecoration: currentDecoration,\n                verticalAlign: currentVerticalAlign\n              }); //offsetX += chunkWidth;\n\n              firstTextChunk = false;\n            }\n\n            if (leftoverChunks) {//return false;\n            }\n\n            return true; //}\n          });\n\n          if (_this.style.lineHeight instanceof Percent) {\n            lineInfo.height *= _this.style.lineHeight.value;\n            lineInfo.ascent *= _this.style.lineHeight.value;\n          } else {\n            lineInfo.height *= _this.style.lineHeight || 1.2;\n            lineInfo.ascent *= _this.style.lineHeight || 1.2;\n          }\n\n          if (minX < lineInfo.left) {\n            minX = lineInfo.left;\n          }\n\n          if (maxX < lineInfo.right) {\n            maxX = lineInfo.right;\n          }\n\n          _this._textInfo.push(lineInfo); //lineInfo.offsetY += lineInfo.ascent;\n\n\n          offsetY += lineInfo.height; // Reset chunks so that it can proceed to the next line\n\n          chunks = leftoverChunks || [];\n        };\n\n        while (chunks.length > 0) {\n          _loop_1();\n        }\n      });\n\n      if (!styleRestored) {\n        context.restore();\n        ghostContext.restore();\n      } // Adjust chunk internal offsets\n\n\n      $array.each(this._textInfo, function (lineInfo, _index) {\n        var currentChunkOffset = 0;\n        $array.each(lineInfo.textChunks, function (chunk) {\n          chunk.offsetX = currentChunkOffset + chunk.left - lineInfo.left;\n          chunk.offsetY += lineInfo.height - lineInfo.height * (_this.style.baselineRatio || 0.19);\n          currentChunkOffset += chunk.width;\n\n          if (chunk.verticalAlign) {\n            switch (chunk.verticalAlign) {\n              case \"super\":\n                chunk.offsetY -= lineInfo.height / 2 - chunk.height / 2;\n                break;\n\n              case \"sub\":\n                chunk.offsetY += chunk.height / 2;\n                break;\n            }\n          }\n        });\n      });\n      var bounds = {\n        left: rtl ? -maxX : -minX,\n        top: 0,\n        right: rtl ? minX : maxX,\n        bottom: offsetY\n      }; // We need to fit?\n\n      if (oversizedBehavior !== \"none\") {\n        var ratio = this._fitRatio(bounds);\n\n        if (ratio < 1) {\n          if (oversizedBehavior == \"fit\") {\n            if ($type.isNumber(this.style.minScale) && ratio < this.style.minScale) {\n              this._textVisible = false;\n            } else {\n              if (!this._originalScale || this._originalScale == 1) {\n                this._originalScale = this.scale;\n              }\n\n              this.scale = ratio;\n              this._textVisible = true;\n            }\n          } else if (oversizedBehavior == \"hide\") {\n            this._textVisible = false;\n          } else {\n            switch (this.style.textAlign) {\n              case \"right\":\n              case \"end\":\n                bounds.left = -maxWidth;\n                bounds.right = 0;\n                break;\n\n              case \"center\":\n                bounds.left = -maxWidth / 2;\n                bounds.right = maxWidth / 2;\n                break;\n\n              default:\n                bounds.left = 0;\n                bounds.right = maxWidth;\n            }\n\n            this.scale = this._originalScale || 1;\n            this._originalScale = undefined;\n            this._textVisible = true;\n          }\n        } else {\n          this.scale = this._originalScale || 1;\n          this._originalScale = undefined;\n          this._textVisible = true;\n        }\n      }\n\n      context.restore();\n      ghostContext.restore();\n      return bounds;\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_fitRatio\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      var maxW = this.style.maxWidth;\n      var maxH = this.style.maxHeight;\n\n      if (!$type.isNumber(maxW) && !$type.isNumber(maxH)) {\n        return 1;\n      }\n\n      var w = bounds.right - bounds.left;\n      var h = bounds.bottom - bounds.top;\n      return Math.min(maxW / w || 1, maxH / h || 1);\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_truncateText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (context, text, maxWidth, breakWords, fallbackBreakWords) {\n      if (breakWords === void 0) {\n        breakWords = false;\n      }\n\n      if (fallbackBreakWords === void 0) {\n        fallbackBreakWords = true;\n      }\n\n      var width;\n\n      do {\n        if (breakWords) {\n          text = text.slice(0, -1);\n        } else {\n          var tmp = text.replace(/[^,;:!?\\\\\\/\\s]+[,;:!?\\\\\\/\\s]*$/g, \"\");\n\n          if (tmp == \"\" && fallbackBreakWords) {\n            breakWords = true;\n          } else if (tmp == \"\") {\n            return text;\n          } else {\n            text = tmp;\n          }\n        }\n\n        var metrics = this._measureText(text, context);\n\n        width = metrics.actualBoundingBoxLeft + metrics.actualBoundingBoxRight;\n      } while (width > maxWidth && text != \"\");\n\n      return text;\n    }\n  });\n  Object.defineProperty(CanvasText.prototype, \"_measureText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text, context) {\n      var metrics = context.measureText(text);\n      var fakeMetrics = {};\n\n      if (metrics.actualBoundingBoxAscent == null) {\n        var div = document.createElement(\"div\");\n        div.innerText = text;\n        div.style.visibility = \"hidden\";\n        div.style.position = \"absolute\";\n        div.style.top = \"-1000000px;\";\n        div.style.fontFamily = this.style.fontFamily || \"\";\n        div.style.fontSize = this.style.fontSize + \"\";\n        document.body.appendChild(div);\n        var bbox = div.getBoundingClientRect();\n        document.body.removeChild(div);\n        var h = bbox.height;\n        var w_1 = metrics.width;\n        var left = 0;\n        var right = w_1;\n        fakeMetrics = {\n          actualBoundingBoxAscent: h,\n          actualBoundingBoxDescent: 0,\n          actualBoundingBoxLeft: left,\n          actualBoundingBoxRight: right,\n          fontBoundingBoxAscent: h,\n          fontBoundingBoxDescent: 0,\n          width: w_1\n        }; //return fake;\n      } else {\n        fakeMetrics = {\n          actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n          actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n          actualBoundingBoxLeft: metrics.actualBoundingBoxLeft,\n          actualBoundingBoxRight: metrics.actualBoundingBoxRight,\n          fontBoundingBoxAscent: metrics.actualBoundingBoxAscent,\n          fontBoundingBoxDescent: metrics.actualBoundingBoxDescent,\n          width: metrics.width\n        };\n      }\n\n      var w = metrics.width;\n\n      switch (this.style.textAlign) {\n        case \"right\":\n        case \"end\":\n          fakeMetrics.actualBoundingBoxLeft = w;\n          fakeMetrics.actualBoundingBoxRight = 0;\n          break;\n\n        case \"center\":\n          fakeMetrics.actualBoundingBoxLeft = w / 2;\n          fakeMetrics.actualBoundingBoxRight = w / 2;\n          break;\n\n        default:\n          fakeMetrics.actualBoundingBoxLeft = 0;\n          fakeMetrics.actualBoundingBoxRight = w;\n      }\n\n      return fakeMetrics;\n    }\n  });\n  return CanvasText;\n}(CanvasDisplayObject);\n\nexport { CanvasText };\n/**\r\n * @ignore\r\n */\n\nvar CanvasTextStyle =\n/** @class */\nfunction () {\n  function CanvasTextStyle() {\n    //public wordWrapWidth: number = 100;\n    Object.defineProperty(this, \"fill\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fillOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textAlign\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontFamily\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontWeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontStyle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"fontVariant\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textDecoration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowColor\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowBlur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOffsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"shadowOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // leading?: number;\n    // letterSpacing?: number;\n\n    Object.defineProperty(this, \"lineHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: percent(120)\n    });\n    Object.defineProperty(this, \"baselineRatio\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0.19\n    }); // padding?: number;\n    // stroke?: number;\n    // strokeThickness?: number;\n    // trim?: number;\n    // wordWrap?: boolean;\n\n    Object.defineProperty(this, \"direction\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"textBaseline\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"oversizedBehavior\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"none\"\n    });\n    Object.defineProperty(this, \"breakWords\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"ellipsis\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"\"\n    });\n    Object.defineProperty(this, \"maxWidth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"maxHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"minScale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"ignoreFormatting\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n  }\n\n  return CanvasTextStyle;\n}();\n\nexport { CanvasTextStyle };\n/**\r\n * @ignore\r\n */\n\nvar CanvasRadialText =\n/** @class */\nfunction (_super) {\n  __extends(CanvasRadialText, _super);\n\n  function CanvasRadialText() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"textType\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"circular\"\n    });\n    Object.defineProperty(_this, \"radius\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"startAngle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"inside\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"orientation\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"auto\"\n    });\n    Object.defineProperty(_this, \"kerning\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_textReversed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    return _this;\n  }\n\n  Object.defineProperty(CanvasRadialText.prototype, \"_render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parentLayer) {\n      switch (this.textType) {\n        case \"circular\":\n          this._renderCircular(parentLayer);\n\n          break;\n\n        default:\n          _super.prototype._render.call(this, parentLayer);\n\n          break;\n      }\n    }\n  });\n  Object.defineProperty(CanvasRadialText.prototype, \"_renderCircular\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parentLayer) {\n      if (this._textVisible) {\n        var layer = this._layer || parentLayer;\n\n        this._prerender(layer);\n\n        var interactive_2 = this._isInteractive();\n\n        var context_3 = layer.context;\n        var layerDirty_2 = layer.dirty;\n        var ghostContext_3 = this._renderer._ghostLayer.context; // Savepoint\n\n        context_3.save();\n\n        if (interactive_2) {\n          ghostContext_3.save();\n        } // Init\n\n\n        var radius_1 = this.radius || 0;\n        var startAngle_1 = this.startAngle || 0;\n        var deltaAngle_1 = 0;\n        var orientation_1 = this.orientation;\n        var inward_1 = orientation_1 == \"auto\" ? \"auto\" : orientation_1 == \"inward\";\n        var inside_1 = this.inside;\n        var align_1 = this.style.textAlign || \"left\";\n        var kerning_1 = this.kerning || 0;\n        var clockwise_1 = align_1 == \"left\" ? 1 : -1;\n        var shouldReverse_1 = !this._textReversed; // We need measurements in order to properly position text for alignment\n\n        if (!this._textInfo) {\n          this._measure(layer);\n        } // Check if we need to invert the whole stuff\n\n\n        if (inward_1 == \"auto\") {\n          // Calc max angle so we know whether we need to flip it\n          var maxAngle_1 = 0;\n          var midAngle = 0;\n          $array.each(this._textInfo, function (line, _index) {\n            var deltaAngle = startAngle_1 + line.width / (radius_1 - line.height) / 2 * -clockwise_1;\n\n            if (deltaAngle > maxAngle_1) {\n              maxAngle_1 = deltaAngle;\n            }\n          });\n\n          if (align_1 == \"left\") {\n            midAngle = (maxAngle_1 + deltaAngle_1 / 2) * $math.DEGREES;\n          } else if (align_1 == \"right\") {\n            midAngle = (maxAngle_1 - deltaAngle_1 / 2) * $math.DEGREES;\n          } else {\n            midAngle = startAngle_1 * $math.DEGREES;\n          }\n\n          midAngle = $math.normalizeAngle(midAngle);\n          inward_1 = midAngle >= 270 || midAngle <= 90;\n        }\n\n        if (inward_1 == true && shouldReverse_1) {\n          this._textInfo.reverse();\n\n          this._textReversed = true;\n        } // if ((inward == false && align == \"left\") || (inward == true && align == \"right\")) {\n        // \tclockwise *= -1;\n        // }\n        // Process text info produced by _measure()\n\n\n        $array.each(this._textInfo, function (line, _index) {\n          var textHeight = line.height; // Adjust radius (for `inside = false`)\n          // Radius adjustment for `inside = false` is below the line calculation\n\n          if (!inside_1) {\n            radius_1 += textHeight;\n          } // Reverse letters if we're painting them counter-clockwise\n\n\n          if ((clockwise_1 == -1 && inward_1 || clockwise_1 == 1 && !inward_1) && shouldReverse_1) {\n            line.textChunks.reverse();\n          } // Init angles\n\n\n          var lineStartAngle = startAngle_1;\n          deltaAngle_1 = 0; // Adjust for center-align\n\n          if (align_1 == \"center\") {\n            lineStartAngle += line.width / (radius_1 - textHeight) / 2 * -clockwise_1;\n            deltaAngle_1 = lineStartAngle - startAngle_1;\n          } // if (inward == \"auto\") {\n          // \tlet midAngle;\n          // \tif (align == \"left\") {\n          // \t\tmidAngle = (lineStartAngle + deltaAngle / 2) * $math.DEGREES;\n          // \t}\n          // \telse if () {\n          // \t\tmidAngle = (lineStartAngle - deltaAngle / 2) * $math.DEGREES;\n          // \t}\n          // \tinward = (midAngle >= 270) || (midAngle <= 90);\n          // }\n          // Rotate letters if they are facing outward\n\n\n          lineStartAngle += Math.PI * (inward_1 ? 0 : 1); // Rotate 180 if outward\n          // Savepoint\n\n          context_3.save();\n\n          if (interactive_2) {\n            ghostContext_3.save();\n          } // Assume starting angle\n\n\n          context_3.rotate(lineStartAngle);\n\n          if (interactive_2) {\n            ghostContext_3.rotate(lineStartAngle);\n          }\n\n          var angleShift = 0;\n          $array.each(line.textChunks, function (chunk, _index) {\n            // Draw the letter\n            var char = chunk.text;\n            var charWidth = chunk.width; // Rotate half a letter\n\n            angleShift = charWidth / 2 / (radius_1 - textHeight) * clockwise_1;\n            context_3.rotate(angleShift);\n\n            if (interactive_2) {\n              ghostContext_3.rotate(angleShift);\n            } // Set style\n\n\n            if (chunk.style) {\n              context_3.save();\n              ghostContext_3.save();\n              context_3.font = chunk.style;\n\n              if (interactive_2) {\n                ghostContext_3.font = chunk.style;\n              }\n            }\n\n            if (chunk.fill) {\n              context_3.save();\n              context_3.fillStyle = chunk.fill.toCSS(); // Color does not affect ghostContext so we not set it\n            } // Center letters\n\n\n            context_3.textBaseline = \"middle\";\n            context_3.textAlign = \"center\";\n\n            if (interactive_2) {\n              ghostContext_3.textBaseline = \"middle\";\n              ghostContext_3.textAlign = \"center\";\n            } // Plop the letter\n\n\n            if (layerDirty_2) {\n              context_3.fillText(char, 0, (inward_1 ? 1 : -1) * (0 - radius_1 + textHeight / 2));\n            }\n\n            if (interactive_2) {\n              ghostContext_3.fillText(char, 0, (inward_1 ? 1 : -1) * (0 - radius_1 + textHeight / 2));\n            }\n\n            if (chunk.fill) {\n              context_3.restore(); // Color does not affect ghostContext so we not set it\n            } // Reset style\n\n\n            if (chunk.style) {\n              context_3.restore();\n              ghostContext_3.restore();\n            } // Rotate half a letter and add spacing\n\n\n            angleShift = (charWidth / 2 + kerning_1) / (radius_1 - textHeight) * clockwise_1;\n            context_3.rotate(angleShift);\n\n            if (interactive_2) {\n              ghostContext_3.rotate(angleShift);\n            }\n          }); // Restore angle\n\n          context_3.restore();\n\n          if (interactive_2) {\n            ghostContext_3.restore();\n          } // Adjust radius (for `inside = true`)\n\n\n          if (inside_1) {\n            radius_1 -= textHeight;\n          }\n        }); // Restore\n\n        context_3.restore();\n\n        if (interactive_2) {\n          ghostContext_3.restore();\n        }\n      }\n    }\n  });\n  Object.defineProperty(CanvasRadialText.prototype, \"_measure\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (layer) {\n      switch (this.textType) {\n        case \"circular\":\n          return this._measureCircular(layer);\n\n        default:\n          return _super.prototype._measure.call(this, layer);\n      }\n    }\n  });\n  Object.defineProperty(CanvasRadialText.prototype, \"_measureCircular\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (layer) {\n      var _this = this;\n\n      var context = layer.context;\n      var ghostContext = this._renderer._ghostLayer.context;\n      var rtl = this.style.direction == \"rtl\";\n      var oversizedBehavior = this.style.oversizedBehavior;\n      var maxWidth = this.style.maxWidth;\n      var truncate = $type.isNumber(maxWidth) && oversizedBehavior == \"truncate\";\n      var ellipsis = this.style.ellipsis || \"\";\n      var ellipsisMetrics; //const wrap = $type.isNumber(maxWidth) && (oversizedBehavior == \"wrap\" || oversizedBehavior == \"wrap-no-break\");\n      // Reset text info\n\n      this._textVisible = true;\n      this._textInfo = [];\n      this._textReversed = false; // Pre-render\n\n      context.save();\n      ghostContext.save();\n\n      this._prerender(layer, true); // Split up text into lines\n\n\n      var lines = this.text.toString().replace(/\\r/g, \"\").split(/\\n/);\n      var styleRestored = true;\n      var totalWidth = 0; // Iterate through the lines\n\n      var offsetY = 0;\n      $array.each(lines, function (line, _index) {\n        // Split up line into format/value chunks\n        var chunks = TextFormatter.chunk(line, false, _this.style.ignoreFormatting); // Init line object\n\n        var lineInfo = {\n          offsetY: offsetY,\n          ascent: 0,\n          width: 0,\n          height: 0,\n          left: 0,\n          right: 0,\n          textChunks: []\n        };\n        var currentStyle;\n        var currentFill;\n        var currentChunkWidth; //while(chunk = chunks.shift()) {\n\n        $array.each(chunks, function (chunk, _index) {\n          // Format chunk\n          if (chunk.type == \"format\") {\n            if (chunk.text == \"[/]\") {\n              if (!styleRestored) {\n                context.restore();\n                ghostContext.restore();\n                styleRestored = true;\n              }\n\n              currentFill = undefined;\n              currentStyle = undefined;\n              currentChunkWidth = undefined;\n            } else {\n              var format = TextFormatter.getTextStyle(chunk.text);\n\n              var fontStyle = _this._getFontStyle(format);\n\n              context.save();\n              ghostContext.save();\n              context.font = fontStyle;\n              currentStyle = fontStyle;\n\n              if (format.fill) {\n                currentFill = format.fill;\n              }\n\n              if (format.width) {\n                currentChunkWidth = $type.toNumber(format.width);\n              }\n\n              styleRestored = false;\n            }\n\n            if (truncate) {\n              ellipsisMetrics = _this._measureText(ellipsis, context);\n            }\n          } // Text format\n          else if (chunk.type == \"value\") {\n            // Measure each letter\n            var chars = chunk.text.match(/./ug) || [];\n\n            if (rtl) {\n              chars.reverse();\n            }\n\n            for (var i = 0; i < chars.length; i++) {\n              var char = chars[i]; // Measure\n\n              var metrics = _this._measureText(char, context);\n\n              var chunkWidth = metrics.width; // Chunk width?\n\n              if (currentStyle && currentChunkWidth && currentChunkWidth > chunkWidth) {\n                chunkWidth = currentChunkWidth;\n              }\n\n              var chunkHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\n              if (chunkHeight > lineInfo.height) {\n                lineInfo.height = chunkHeight;\n              }\n\n              if (metrics.actualBoundingBoxAscent > lineInfo.ascent) {\n                lineInfo.ascent = metrics.actualBoundingBoxAscent;\n              }\n\n              lineInfo.width += chunkWidth;\n              lineInfo.left += metrics.actualBoundingBoxLeft;\n              lineInfo.right += metrics.actualBoundingBoxRight;\n              lineInfo.textChunks.push({\n                style: currentStyle,\n                fill: currentFill,\n                text: char,\n                width: chunkWidth,\n                height: chunkHeight + metrics.actualBoundingBoxDescent,\n                left: metrics.actualBoundingBoxLeft,\n                right: metrics.actualBoundingBoxRight,\n                ascent: metrics.actualBoundingBoxAscent,\n                offsetX: 0,\n                offsetY: chunkHeight,\n                textDecoration: undefined\n              });\n              totalWidth += chunkWidth; // Handle oversized behavior\n\n              if (truncate) {\n                // Measure ellipsis and check if it fits\n                if (!ellipsisMetrics) {\n                  ellipsisMetrics = _this._measureText(ellipsis, context);\n                }\n\n                var ellipsisWidth = ellipsisMetrics.actualBoundingBoxLeft + ellipsisMetrics.actualBoundingBoxRight;\n                totalWidth += ellipsisWidth;\n\n                if (totalWidth + ellipsisWidth > maxWidth) {\n                  if (lineInfo.textChunks.length == 1) {\n                    _this._textVisible = false;\n                  } else {\n                    lineInfo.width += ellipsisWidth;\n                    lineInfo.left += ellipsisMetrics.actualBoundingBoxLeft;\n                    lineInfo.right += ellipsisMetrics.actualBoundingBoxRight;\n                    lineInfo.textChunks.push({\n                      style: currentStyle,\n                      fill: currentFill,\n                      text: ellipsis,\n                      width: ellipsisWidth,\n                      height: chunkHeight + ellipsisMetrics.actualBoundingBoxDescent,\n                      left: ellipsisMetrics.actualBoundingBoxLeft,\n                      right: ellipsisMetrics.actualBoundingBoxRight,\n                      ascent: ellipsisMetrics.actualBoundingBoxAscent,\n                      offsetX: 0,\n                      offsetY: chunkHeight,\n                      textDecoration: undefined\n                    });\n                  }\n\n                  break;\n                }\n              }\n\n              if (rtl) {\n                break;\n              }\n            }\n          }\n        });\n\n        if (_this.style.lineHeight instanceof Percent) {\n          lineInfo.height *= _this.style.lineHeight.value;\n        } else {\n          lineInfo.height *= _this.style.lineHeight || 1.2;\n        }\n\n        _this._textInfo.push(lineInfo); //lineInfo.offsetY += lineInfo.ascent;\n\n\n        offsetY += lineInfo.height;\n      });\n\n      if (!styleRestored) {\n        context.restore();\n        ghostContext.restore();\n      }\n\n      if (oversizedBehavior == \"hide\" && totalWidth > maxWidth) {\n        this._textVisible = false;\n      } // Adjust chunk internal offsets\n\n\n      $array.each(this._textInfo, function (lineInfo) {\n        $array.each(lineInfo.textChunks, function (chunk) {\n          chunk.offsetY += Math.round((lineInfo.height - chunk.height + (lineInfo.ascent - chunk.ascent)) / 2);\n        });\n      });\n      context.restore();\n      ghostContext.restore();\n      return {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      };\n    }\n  });\n  return CanvasRadialText;\n}(CanvasText);\n\nexport { CanvasRadialText };\n/**\r\n * @ignore\r\n */\n\nvar CanvasImage =\n/** @class */\nfunction (_super) {\n  __extends(CanvasImage, _super);\n\n  function CanvasImage(renderer, image) {\n    var _this = _super.call(this, renderer) || this;\n\n    Object.defineProperty(_this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"image\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"tainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"shadowColor\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"shadowBlur\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"shadowOffsetX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"shadowOffsetY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"shadowOpacity\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_imageMask\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    _this.image = image;\n    return _this;\n  }\n\n  Object.defineProperty(CanvasImage.prototype, \"_dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._dispose.call(this);\n\n      if (this._imageMask) {\n        clearCanvas(this._imageMask);\n      }\n    }\n  });\n  Object.defineProperty(CanvasImage.prototype, \"getLocalBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._localBounds) {\n        var w = 0;\n        var h = 0;\n\n        if (this.width) {\n          w = this.width;\n        }\n\n        if (this.height) {\n          h = this.height;\n        }\n\n        this._localBounds = {\n          left: 0,\n          top: 0,\n          right: w,\n          bottom: h\n        };\n\n        this._addBounds(this._localBounds);\n      }\n\n      return this._localBounds;\n    }\n  });\n  Object.defineProperty(CanvasImage.prototype, \"_render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parentLayer) {\n      _super.prototype._render.call(this, parentLayer);\n\n      if (this.image) {\n        var layer = this._layer || parentLayer;\n\n        if (this.tainted === undefined) {\n          this.tainted = isTainted(this.image);\n          layer.tainted = true;\n        }\n\n        if (this.tainted && this._renderer._omitTainted) {\n          return;\n        }\n\n        if (layer.dirty) {\n          if (this.shadowColor) {\n            layer.context.shadowColor = this.shadowColor.toCSS(this.shadowOpacity || 1);\n          }\n\n          if (this.shadowBlur) {\n            layer.context.shadowBlur = this.shadowBlur;\n          }\n\n          if (this.shadowOffsetX) {\n            layer.context.shadowOffsetX = this.shadowOffsetX;\n          }\n\n          if (this.shadowOffsetY) {\n            layer.context.shadowOffsetY = this.shadowOffsetY;\n          } // TODO should this round ?\n\n\n          var width = this.width || this.image.naturalWidth;\n          var height = this.height || this.image.naturalHeight;\n          layer.context.drawImage(this.image, 0, 0, width, height);\n        }\n\n        if (this.interactive && this._isInteractive()) {\n          var mask = this._getMask(this.image);\n\n          this._renderer._ghostLayer.context.drawImage(mask, 0, 0);\n        }\n      }\n    }\n  });\n  Object.defineProperty(CanvasImage.prototype, \"clear\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.clear.call(this);\n\n      this.image = undefined;\n      this._imageMask = undefined;\n    }\n  });\n  Object.defineProperty(CanvasImage.prototype, \"_getMask\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (image) {\n      if (this._imageMask === undefined) {\n        // TODO should this round ?\n        var width = this.width || image.naturalWidth;\n        var height = this.height || image.naturalHeight; // We need to create a second canvas because destination-in clears out the entire canvas\n\n        var canvas = document.createElement(\"canvas\");\n        canvas.width = width;\n        canvas.height = height;\n        var context = canvas.getContext(\"2d\");\n        context.imageSmoothingEnabled = false;\n        context.fillStyle = this._getColorId();\n        context.fillRect(0, 0, width, height);\n\n        if (!isTainted(image)) {\n          context.globalCompositeOperation = \"destination-in\";\n          context.drawImage(image, 0, 0, width, height);\n        }\n\n        this._imageMask = canvas;\n      }\n\n      return this._imageMask;\n    }\n  });\n  return CanvasImage;\n}(CanvasDisplayObject);\n\nexport { CanvasImage };\n/**\r\n * @ignore\r\n */\n\nvar CanvasRendererEvent =\n/** @class */\nfunction () {\n  function CanvasRendererEvent(event, originalPoint, point, bbox) {\n    Object.defineProperty(this, \"event\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: event\n    });\n    Object.defineProperty(this, \"originalPoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: originalPoint\n    });\n    Object.defineProperty(this, \"point\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: point\n    });\n    Object.defineProperty(this, \"bbox\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: bbox\n    });\n    Object.defineProperty(this, \"id\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"simulated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"native\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n\n    if ($utils.supports(\"touchevents\") && event instanceof Touch) {\n      this.id = event.identifier;\n    } else {\n      this.id = null;\n    }\n  }\n\n  return CanvasRendererEvent;\n}();\n\nexport { CanvasRendererEvent };\n/**\r\n * @ignore\r\n */\n\nvar CanvasRenderer =\n/** @class */\nfunction (_super) {\n  __extends(CanvasRenderer, _super);\n  /*protected _mouseMoveThrottler: Throttler = new Throttler(() => {\r\n      this._dispatchGlobalMousemove(this._lastPointerMoveEvent.event, this._lastPointerMoveEvent.native);\r\n  });\r\n  */\n\n\n  function CanvasRenderer(resolution) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"div\")\n    });\n    Object.defineProperty(_this, \"_layerDom\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"div\")\n    });\n    Object.defineProperty(_this, \"layers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_this, \"_dirtyLayers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_this, \"defaultLayer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.getLayer(0)\n    });\n    Object.defineProperty(_this, \"_ghostLayer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new GhostLayer()\n    });\n    Object.defineProperty(_this, \"_patternCanvas\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: document.createElement(\"canvas\")\n    });\n    Object.defineProperty(_this, \"_patternContext\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this._patternCanvas.getContext(\"2d\")\n    });\n    Object.defineProperty(_this, \"_width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_clientWidth\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_clientHeight\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"resolution\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"interactionsEnabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(_this, \"_listeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_events\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_colorId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_colorMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_forceInteractive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_omitTainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    }); // TODO this should store the Id as well\n\n    Object.defineProperty(_this, \"_hovering\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Set()\n    });\n    Object.defineProperty(_this, \"_dragging\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_this, \"_mousedown\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(_this, \"_lastPointerMoveEvent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"tapToActivate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"tapToActivateTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 3000\n    });\n    Object.defineProperty(_this, \"_touchActive\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_touchActiveTimeout\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n\n    if (resolution == null) {\n      _this.resolution = window.devicePixelRatio;\n    } else {\n      _this.resolution = resolution;\n    }\n\n    _this.view.style.position = \"absolute\";\n\n    _this.view.appendChild(_this._layerDom);\n\n    _this._disposers.push(new Disposer(function () {\n      $object.each(_this._events, function (_key, events) {\n        events.disposer.dispose();\n      });\n      $array.each(_this.layers, function (layer) {\n        clearCanvas(layer.view);\n\n        if (layer.exportableView) {\n          clearCanvas(layer.exportableView);\n        }\n      });\n      clearCanvas(_this._ghostLayer.view);\n      clearCanvas(_this._patternCanvas);\n    }));\n\n    _this._disposers.push($utils.addEventListener(_this._ghostLayer.view, \"click\", function (originalEvent) {\n      var event = _this.getEvent(originalEvent);\n\n      var target = _this._getHitTarget(event.originalPoint, event.bbox);\n\n      console.debug(target);\n    })); // Monitor for possible pixel ratio changes (when page is zoomed)\n\n\n    _this._disposers.push($utils.onZoom(function () {\n      if (resolution == null) {\n        _this.resolution = window.devicePixelRatio;\n      }\n    })); // We need this in order top prevent default touch gestures when dragging\n    // draggable elements\n\n\n    if ($utils.supports(\"touchevents\")) {\n      var listener = function (ev) {\n        if (_this._dragging.length !== 0) {\n          $array.eachContinue(_this._dragging, function (item) {\n            if (item.value.shouldCancelTouch()) {\n              ev.preventDefault();\n              return false;\n            }\n\n            return true;\n          });\n        } // If touch down happends, delay touch out\n\n\n        if (_this._touchActiveTimeout) {\n          _this._delayTouchDeactivate();\n        }\n      };\n\n      _this._disposers.push($utils.addEventListener(window, \"touchstart\", listener, {\n        passive: false\n      }));\n\n      _this._disposers.push($utils.addEventListener(_this.view, \"touchstart\", listener, {\n        passive: false\n      }));\n\n      _this._disposers.push($utils.addEventListener(_this.view, \"touchmove\", function () {\n        // If touch is moving, delay touch out\n        if (_this._touchActiveTimeout) {\n          _this._delayTouchDeactivate();\n        }\n      }, {\n        passive: true\n      }));\n\n      _this._disposers.push($utils.addEventListener(window, \"click\", function (_ev) {\n        _this._touchActive = false;\n      }, {\n        passive: true\n      }));\n\n      _this._disposers.push($utils.addEventListener(_this.view, \"click\", function (_ev) {\n        window.setTimeout(function () {\n          _this._touchActive = true;\n\n          _this._delayTouchDeactivate();\n        }, 100);\n      }, {\n        passive: true\n      }));\n    } // Prevent scrolling of the window when hovering on \"wheelable\" object\n\n\n    if ($utils.supports(\"wheelevents\")) {\n      _this._disposers.push($utils.addEventListener(_this.view, \"wheel\", function (ev) {\n        var prevent = false;\n\n        _this._hovering.forEach(function (obj) {\n          if (obj.wheelable) {\n            prevent = true;\n            return false;\n          }\n        });\n\n        if (prevent) {\n          ev.preventDefault();\n        }\n      }, {\n        passive: false\n      }));\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(CanvasRenderer.prototype, \"_delayTouchDeactivate\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      if (this._touchActiveTimeout) {\n        clearTimeout(this._touchActiveTimeout);\n      }\n\n      if (this.tapToActivateTimeout > 0) {\n        this._touchActiveTimeout = window.setTimeout(function () {\n          _this._touchActive = false;\n        }, this.tapToActivateTimeout);\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"debugGhostView\", {\n    get: function () {\n      return !!this._ghostLayer.view.parentNode;\n    },\n    set: function (value) {\n      if (value) {\n        if (!this._ghostLayer.view.parentNode) {\n          this.view.appendChild(this._ghostLayer.view);\n        }\n      } else {\n        if (this._ghostLayer.view.parentNode) {\n          this._ghostLayer.view.parentNode.removeChild(this._ghostLayer.view);\n        }\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"createLinearGradient\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (x1, y1, x2, y2) {\n      return this.defaultLayer.context.createLinearGradient(x1, y1, x2, y2);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"createRadialGradient\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (x1, y1, radius1, x2, y2, radius2) {\n      return this.defaultLayer.context.createRadialGradient(x1, y1, radius1, x2, y2, radius2);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"createPattern\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (graphics, background, repetition, width, height) {\n      // const patternCanvas = document.createElement(\"canvas\");\n      // const patternContext = patternCanvas.getContext(\"2d\")!;\n      // patternCanvas.width = width;\n      // patternCanvas.height = height;\n      // if (fill) {\n      // \tpatternContext.fillStyle = fill.toCSS();\n      // \tpatternContext.fillRect(0, 0, patternCanvas.width, patternCanvas.height);\n      // }\n      // const layer = {\n      // \tview: patternCanvas,\n      // \tcontext: patternContext,\n      // \tvisible: true,\n      // \torder: 0,\n      // \twidth: width,\n      // \theight: height,\n      // \tdirty: true\n      // };\n      // // patternContext.arc(0, 0, 50, 0, .5 * Math.PI);\n      // // patternContext.stroke();\n      // image.targetLayer = layer;\n      // image.render(layer);\n      //this._layerDom.appendChild(patternCanvas);\n      this._patternCanvas.width = width;\n      this._patternCanvas.height = height;\n\n      this._patternContext.clearRect(0, 0, width, height); // patternCanvas.style.width = width * this.resolution + \"px\";\n      // patternCanvas.style.height = height * this.resolution + \"px\";\n\n\n      background.renderDetached(this._patternContext);\n      graphics.renderDetached(this._patternContext);\n      return this._patternContext.createPattern(this._patternCanvas, repetition);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"makeContainer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return new CanvasContainer(this);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"makeGraphics\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return new CanvasGraphics(this);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"makeText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text, style) {\n      return new CanvasText(this, text, style);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"makeTextStyle\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return new CanvasTextStyle();\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"makeRadialText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text, style) {\n      return new CanvasRadialText(this, text, style);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"makePicture\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (image) {\n      return new CanvasImage(this, image);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"resizeLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (layer) {\n      layer.dirty = true;\n      layer.resize(this._clientWidth, this._clientHeight, this.resolution);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"resizeGhost\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._ghostLayer.resize(this._clientWidth, this._clientHeight, this.resolution);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"resize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (width, height) {\n      var _this = this;\n\n      this._clientWidth = width;\n      this._clientHeight = height;\n      this._width = Math.floor(width * this.resolution);\n      this._height = Math.floor(height * this.resolution);\n      $array.each(this.layers, function (layer) {\n        if (layer) {\n          _this.resizeLayer(layer);\n        }\n      });\n      this.resizeGhost();\n      this.view.style.width = width + \"px\";\n      this.view.style.height = height + \"px\";\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"createDetachedLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (willReadFrequently) {\n      if (willReadFrequently === void 0) {\n        willReadFrequently = false;\n      }\n\n      var view = document.createElement(\"canvas\");\n      var context = view.getContext(\"2d\", {\n        willReadFrequently: willReadFrequently\n      });\n      var layer = new CanvasLayer(view, context);\n      view.style.position = \"absolute\";\n      view.style.top = \"0px\";\n      view.style.left = \"0px\";\n      return layer;\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"getLayerByOrder\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (order) {\n      var layers = this.layers;\n      var length = layers.length;\n\n      for (var i = 0; i < length; i++) {\n        var layer = layers[i];\n\n        if (layer.order == order) {\n          return layer;\n        }\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"getLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (order, visible) {\n      if (visible === void 0) {\n        visible = true;\n      }\n\n      var existingLayer = this.getLayerByOrder(order);\n\n      if (existingLayer) {\n        return existingLayer;\n      }\n\n      var layer = this.createDetachedLayer(order == 99);\n      layer.order = order;\n      layer.visible = visible;\n\n      if (layer.visible && this._width) {\n        layer.view.width = this._width;\n        layer.view.style.width = this._clientWidth + \"px\";\n        layer.view.height = this._height;\n        layer.view.style.height = this._clientHeight + \"px\";\n      }\n\n      var layers = this.layers;\n      layers.push(layer);\n      layers.sort(function (a, b) {\n        if (a.order > b.order) {\n          return 1;\n        } else if (a.order < b.order) {\n          return -1;\n        } else {\n          return 0;\n        }\n      });\n      var length = layers.length;\n      var layerIndex = $array.indexOf(layers, layer);\n      var next;\n\n      for (var i = layerIndex + 1; i < length; i++) {\n        if (layers[i].visible) {\n          next = layers[i];\n          break;\n        }\n      }\n\n      if (layer.visible) {\n        if (next === undefined) {\n          this._layerDom.appendChild(layer.view);\n        } else {\n          this._layerDom.insertBefore(layer.view, next.view);\n        }\n      }\n\n      return layer;\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"render\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (root) {\n      var _this = this;\n\n      this._dirtyLayers.length = 0;\n      $array.each(this.layers, function (layer) {\n        if (layer) {\n          if (layer.dirty && layer.visible) {\n            _this._dirtyLayers.push(layer);\n\n            layer.clear();\n          }\n        }\n      });\n\n      this._ghostLayer.clear();\n\n      root.render(this.defaultLayer);\n\n      this._ghostLayer.context.restore(); //setTimeout(() => {\n      // Remove this after the Chrome bug is fixed:\n      // https://bugs.chromium.org/p/chromium/issues/detail?id=1279394\n\n\n      $array.each(this.layers, function (layer) {\n        if (layer) {\n          var context = layer.context;\n          context.beginPath();\n          context.moveTo(0, 0);\n          context.stroke();\n        }\n      });\n      $array.each(this._dirtyLayers, function (layer) {\n        layer.context.restore();\n        layer.dirty = false;\n      }); //}, 100)\n\n      if (this._hovering.size && this._lastPointerMoveEvent) {\n        //this._mouseMoveThrottler.run();\n        var native_1 = this._lastPointerMoveEvent.native;\n        $array.each(this._lastPointerMoveEvent.events, function (event) {\n          _this._dispatchGlobalMousemove(event, native_1);\n        });\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"paintId\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (obj) {\n      var id = distributeId(++this._colorId);\n      var color = Color.fromHex(id).toCSS();\n      this._colorMap[color] = obj;\n      return color;\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_removeObject\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (obj) {\n      if (obj._colorId !== undefined) {\n        delete this._colorMap[obj._colorId];\n      }\n    }\n  }); // protected _identifyObjectByColor(colorId: number): CanvasDisplayObject | undefined {\n  // \treturn this._colorMap[colorId];\n  // }\n\n  Object.defineProperty(CanvasRenderer.prototype, \"_adjustBoundingBox\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bbox) {\n      var margin = this._ghostLayer.margin;\n      return new DOMRect(bbox.left - margin.left, bbox.top - margin.top, bbox.width + margin.left + margin.right, bbox.height + margin.top + margin.bottom);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"getEvent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (originalEvent, adjustPoint) {\n      if (adjustPoint === void 0) {\n        adjustPoint = true;\n      }\n\n      var bbox = this.view.getBoundingClientRect();\n      var originalPoint = {\n        x: originalEvent.clientX || 0,\n        y: originalEvent.clientY || 0\n      };\n      var point = {\n        x: originalPoint.x - (adjustPoint ? bbox.left : 0),\n        y: originalPoint.y - (adjustPoint ? bbox.top : 0)\n      };\n      return new CanvasRendererEvent(originalEvent, originalPoint, point, this._adjustBoundingBox(bbox));\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_getHitTarget\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point, bbox) {\n      if (bbox.width === 0 || bbox.height === 0 || point.x < bbox.left || point.x > bbox.right || point.y < bbox.top || point.y > bbox.bottom) {\n        return;\n      } else {\n        var pixel = this._ghostLayer.getImageData(point, bbox);\n\n        if (pixel.data[0] === 0 && pixel.data[1] === 0 && pixel.data[2] === 0) {\n          return false;\n        }\n\n        var colorId = Color.fromRGB(pixel.data[0], pixel.data[1], pixel.data[2]).toCSS();\n        var hit = this._colorMap[colorId];\n        return hit;\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_withEvents\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key, f) {\n      var events = this._events[key];\n\n      if (events !== undefined) {\n        events.dispatching = true;\n\n        try {\n          f(events);\n        } finally {\n          events.dispatching = false;\n\n          if (events.cleanup) {\n            events.cleanup = false;\n            $array.keepIf(events.callbacks, function (callback) {\n              return !callback.disposed;\n            });\n\n            if (events.callbacks.length === 0) {\n              events.disposer.dispose();\n              delete this._events[key];\n            }\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchEventAll\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key, event) {\n      if (!this.interactionsEnabled) {\n        return;\n      }\n\n      this._withEvents(key, function (events) {\n        $array.each(events.callbacks, function (callback) {\n          if (!callback.disposed) {\n            callback.callback.call(callback.context, event);\n          }\n        });\n      });\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchEvent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key, target, event) {\n      if (!this.interactionsEnabled) {\n        return false;\n      }\n\n      var dispatched = false;\n\n      this._withEvents(key, function (events) {\n        $array.each(events.callbacks, function (callback) {\n          if (!callback.disposed && callback.object === target) {\n            callback.callback.call(callback.context, event);\n            dispatched = true;\n          }\n        });\n      });\n\n      return dispatched;\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchMousedown\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (originalEvent) {\n      var _this = this;\n\n      var button = originalEvent.button;\n\n      if (button != 0 && button != 2 && button != 1 && button !== undefined) {\n        // Ignore non-primary mouse buttons\n        return;\n      }\n\n      var event = this.getEvent(originalEvent);\n\n      var target = this._getHitTarget(event.originalPoint, event.bbox);\n\n      if (target) {\n        var id_1 = event.id;\n        var dragged_1 = false;\n        eachTargets(target, function (obj) {\n          var info = {\n            id: id_1,\n            value: obj\n          };\n\n          _this._mousedown.push(info);\n\n          if (!dragged_1 && _this._dispatchEvent(\"pointerdown\", obj, event)) {\n            // Only dispatch the first element which matches\n            dragged_1 = true;\n\n            var has = _this._dragging.some(function (x) {\n              return x.value === obj && x.id === id_1;\n            });\n\n            if (!has) {\n              _this._dragging.push(info);\n            }\n          }\n\n          return true;\n        });\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchGlobalMousemove\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (originalEvent, native) {\n      var _this = this;\n\n      var event = this.getEvent(originalEvent);\n\n      var target = this._getHitTarget(event.originalPoint, event.bbox);\n\n      event.native = native;\n\n      if (target) {\n        this._hovering.forEach(function (obj) {\n          if (!obj.contains(target)) {\n            _this._hovering.delete(obj);\n\n            if (obj.cursorOverStyle) {\n              $utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle);\n            }\n\n            _this._dispatchEvent(\"pointerout\", obj, event);\n          }\n        });\n\n        if (event.native) {\n          eachTargets(target, function (obj) {\n            if (!_this._hovering.has(obj)) {\n              _this._hovering.add(obj);\n\n              if (obj.cursorOverStyle) {\n                obj._replacedCursorStyle = $utils.getStyle(document.body, \"cursor\");\n                $utils.setStyle(document.body, \"cursor\", obj.cursorOverStyle);\n              }\n\n              _this._dispatchEvent(\"pointerover\", obj, event);\n            }\n\n            return true;\n          });\n        } //} else if (target === false) {\n\n      } else {\n        this._hovering.forEach(function (obj) {\n          if (obj.cursorOverStyle) {\n            $utils.setStyle(document.body, \"cursor\", obj._replacedCursorStyle);\n          }\n\n          _this._dispatchEvent(\"pointerout\", obj, event);\n        });\n\n        this._hovering.clear();\n      }\n\n      this._dispatchEventAll(\"globalpointermove\", event);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchGlobalMouseup\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (originalEvent, native) {\n      var event = this.getEvent(originalEvent);\n      event.native = native; //const target = this._getHitTarget(event.originalPoint);\n\n      this._dispatchEventAll(\"globalpointerup\", event);\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchDragMove\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (originalEvent) {\n      var _this = this;\n\n      if (this._dragging.length !== 0) {\n        var event_1 = this.getEvent(originalEvent);\n        var id_2 = event_1.id;\n\n        this._dragging.forEach(function (obj) {\n          if (obj.id === id_2) {\n            _this._dispatchEvent(\"pointermove\", obj.value, event_1);\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchDragEnd\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (originalEvent) {\n      var _this = this;\n\n      var button = originalEvent.button;\n      var clickevent;\n\n      if (button == 0 || button === undefined) {\n        clickevent = \"click\";\n      } else if (button == 2) {\n        clickevent = \"rightclick\";\n      } else if (button == 1) {\n        clickevent = \"middleclick\";\n      } else {\n        // Ignore non-primary mouse buttons\n        return;\n      }\n\n      var event = this.getEvent(originalEvent);\n      var id = event.id;\n\n      if (this._mousedown.length !== 0) {\n        var target_1 = this._getHitTarget(event.originalPoint, event.bbox);\n\n        if (target_1) {\n          this._mousedown.forEach(function (obj) {\n            if (obj.id === id && obj.value.contains(target_1)) {\n              _this._dispatchEvent(clickevent, obj.value, event);\n            }\n          });\n        }\n\n        this._mousedown.length = 0;\n      }\n\n      if (this._dragging.length !== 0) {\n        this._dragging.forEach(function (obj) {\n          if (obj.id === id) {\n            _this._dispatchEvent(\"pointerup\", obj.value, event);\n          }\n        });\n\n        this._dragging.length = 0;\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchDoubleClick\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (originalEvent) {\n      var _this = this;\n\n      var event = this.getEvent(originalEvent);\n\n      var target = this._getHitTarget(event.originalPoint, event.bbox);\n\n      if (target) {\n        eachTargets(target, function (obj) {\n          if (_this._dispatchEvent(\"dblclick\", obj, event)) {\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_dispatchWheel\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (originalEvent) {\n      var _this = this;\n\n      var event = this.getEvent(originalEvent);\n\n      var target = this._getHitTarget(event.originalPoint, event.bbox);\n\n      if (target) {\n        eachTargets(target, function (obj) {\n          if (_this._dispatchEvent(\"wheel\", obj, event)) {\n            return false;\n          } else {\n            return true;\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_makeSharedEvent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key, f) {\n      var _this = this;\n\n      if (this._listeners[key] === undefined) {\n        var listener_1 = f();\n        this._listeners[key] = new CounterDisposer(function () {\n          delete _this._listeners[key];\n          listener_1.dispose();\n        });\n      }\n\n      return this._listeners[key].increment();\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_onPointerEvent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (name, f) {\n      var native = false;\n      var timer = null;\n\n      function clear() {\n        timer = null;\n        native = false;\n      }\n\n      return new MultiDisposer([new Disposer(function () {\n        if (timer !== null) {\n          clearTimeout(timer);\n        }\n\n        clear();\n      }), $utils.addEventListener(this.view, $utils.getRendererEvent(name), function (_) {\n        native = true;\n\n        if (timer !== null) {\n          clearTimeout(timer);\n        }\n\n        timer = window.setTimeout(clear, 0);\n      }), onPointerEvent(window, name, function (ev) {\n        if (timer !== null) {\n          clearTimeout(timer);\n          timer = null;\n        }\n\n        f(ev, native);\n        native = false;\n      })]);\n    }\n  }); // This ensures that only a single DOM event is added (e.g. only a single mousemove event listener)\n\n  Object.defineProperty(CanvasRenderer.prototype, \"_initEvent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key) {\n      var _this = this;\n\n      switch (key) {\n        case \"globalpointermove\":\n        case \"pointerover\":\n        case \"pointerout\":\n          return this._makeSharedEvent(\"pointermove\", function () {\n            var listener = function (events, native) {\n              _this._lastPointerMoveEvent = {\n                events: events,\n                native: native\n              };\n              $array.each(events, function (event) {\n                _this._dispatchGlobalMousemove(event, native);\n              });\n            };\n\n            return new MultiDisposer([_this._onPointerEvent(\"pointerdown\", listener), _this._onPointerEvent(\"pointermove\", listener)]);\n          });\n\n        case \"globalpointerup\":\n          return this._makeSharedEvent(\"pointerup\", function () {\n            var mouseup = _this._onPointerEvent(\"pointerup\", function (events, native) {\n              $array.each(events, function (event) {\n                _this._dispatchGlobalMouseup(event, native);\n              });\n              _this._lastPointerMoveEvent = {\n                events: events,\n                native: native\n              };\n            });\n\n            var pointercancel = _this._onPointerEvent(\"pointercancel\", function (events, native) {\n              $array.each(events, function (event) {\n                _this._dispatchGlobalMouseup(event, native);\n              });\n              _this._lastPointerMoveEvent = {\n                events: events,\n                native: native\n              };\n            });\n\n            return new Disposer(function () {\n              mouseup.dispose();\n              pointercancel.dispose();\n            });\n          });\n\n        case \"click\":\n        case \"rightclick\":\n        case \"middleclick\":\n        case \"pointerdown\":\n        /*\r\n            return this._makeSharedEvent(\"pointerdown\", () => {\r\n                return this._onPointerEvent(\"pointerdown\", (event, native) => {\r\n                    this._lastPointerMoveEvent = { event, native };\r\n                    this._dispatchMousedown(event)\r\n                });\r\n            });\r\n        */\n\n        case \"pointermove\":\n        case \"pointerup\":\n          return this._makeSharedEvent(\"pointerdown\", function () {\n            //const throttler = new Throttler();\n            var mousedown = onPointerEvent(_this.view, \"pointerdown\", function (events) {\n              $array.each(events, function (ev) {\n                _this._dispatchMousedown(ev);\n              });\n            }); // TODO handle throttling properly for multitouch\n\n            var mousemove = _this._onPointerEvent(\"pointermove\", function (ev) {\n              //throttler.throttle(() => {\n              $array.each(ev, function (ev) {\n                _this._dispatchDragMove(ev);\n              }); //});\n            });\n\n            var mouseup = _this._onPointerEvent(\"pointerup\", function (ev) {\n              $array.each(ev, function (ev) {\n                _this._dispatchDragEnd(ev);\n              });\n            });\n\n            var pointercancel = _this._onPointerEvent(\"pointercancel\", function (ev) {\n              $array.each(ev, function (ev) {\n                _this._dispatchDragEnd(ev);\n              });\n            });\n\n            return new Disposer(function () {\n              mousedown.dispose();\n              mousemove.dispose();\n              mouseup.dispose();\n              pointercancel.dispose();\n            });\n          });\n\n        case \"dblclick\":\n          return this._makeSharedEvent(\"dblclick\", function () {\n            return _this._onPointerEvent(\"dblclick\", function (ev) {\n              $array.each(ev, function (ev) {\n                _this._dispatchDoubleClick(ev);\n              });\n            });\n          });\n\n        case \"wheel\":\n          return this._makeSharedEvent(\"wheel\", function () {\n            return $utils.addEventListener(window, $utils.getRendererEvent(\"wheel\"), function (event) {\n              _this._dispatchWheel(event);\n            }, {\n              passive: false\n            });\n          });\n      }\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"_addEvent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (object, key, callback, context) {\n      var _this = this;\n\n      var events = this._events[key];\n\n      if (events === undefined) {\n        events = this._events[key] = {\n          disposer: this._initEvent(key),\n          callbacks: [],\n          dispatching: false,\n          cleanup: false\n        };\n      }\n\n      var listener = {\n        object: object,\n        context: context,\n        callback: callback,\n        disposed: false\n      };\n      events.callbacks.push(listener);\n      return new Disposer(function () {\n        listener.disposed = true;\n\n        if (events.dispatching) {\n          events.cleanup = true;\n        } else {\n          $array.removeFirst(events.callbacks, listener);\n\n          if (events.callbacks.length === 0) {\n            events.disposer.dispose();\n            delete _this._events[key];\n          }\n        }\n      });\n    }\n  });\n  Object.defineProperty(CanvasRenderer.prototype, \"getCanvas\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (root, options) {\n      var _this = this; // Make sure everything is rendered\n\n\n      this.render(root);\n\n      if (!options) {\n        options = {};\n      }\n\n      var scale = this.resolution; // Check if we need to scale\n\n      if (options.minWidth && options.minWidth > this._width) {\n        var minScale = options.minWidth / this._width;\n\n        if (minScale > scale) {\n          scale = minScale * this.resolution;\n        }\n      }\n\n      if (options.minHeight && options.minHeight > this._height) {\n        var minScale = options.minHeight / this._height;\n\n        if (minScale > scale) {\n          scale = minScale * this.resolution;\n        }\n      }\n\n      if (options.maxWidth && options.maxWidth < this._width) {\n        var maxScale = options.maxWidth / this._width;\n\n        if (maxScale < scale) {\n          scale = maxScale * this.resolution;\n        }\n      }\n\n      if (options.maxHeight && options.maxHeight > this._height) {\n        var maxScale = options.maxHeight / this._height;\n\n        if (maxScale < scale) {\n          scale = maxScale * this.resolution;\n        }\n      } // Check if we need to compensate for pixel ratio\n\n\n      if (options.maintainPixelRatio) {\n        scale /= this.resolution;\n      } // Init list canvases to remove from DOM after export\n\n\n      var canvases = []; // Set up new canvas for export\n\n      var forceRender = false;\n      var canvasWidth = this._width;\n      var canvasHeight = this._height;\n      var canvas = document.createElement(\"canvas\");\n\n      if (scale != this.resolution) {\n        forceRender = true;\n        canvasWidth = this._width * scale / this.resolution;\n        canvasHeight = this._height * scale / this.resolution;\n      }\n\n      canvas.width = canvasWidth;\n      canvas.height = canvasHeight; // Add to DOM so it inherits CSS\n\n      canvas.style.position = \"fixed\";\n      canvas.style.top = \"-10000px\";\n      this.view.appendChild(canvas);\n      canvases.push(canvas); // Context\n\n      var context = canvas.getContext(\"2d\");\n      var width = 0;\n      var height = 0;\n      var needRerender = false;\n      $array.each(this.layers, function (layer) {\n        if (layer && layer.visible) {\n          if (layer.tainted || forceRender) {\n            needRerender = true;\n            layer.exportableView = layer.view;\n            layer.exportableContext = layer.context;\n            layer.view = document.createElement(\"canvas\"); // Add to DOM so it inherits CSS\n\n            layer.view.style.position = \"fixed\";\n            layer.view.style.top = \"-10000px\";\n\n            _this.view.appendChild(layer.view);\n\n            canvases.push(layer.view);\n            layer.view.width = canvasWidth;\n            layer.view.height = canvasHeight;\n            layer.context = layer.view.getContext(\"2d\");\n            layer.dirty = true;\n            layer.scale = scale;\n          }\n        }\n      });\n\n      if (needRerender) {\n        this._omitTainted = true;\n        this.render(root);\n        this._omitTainted = false;\n      }\n\n      $array.each(this.layers, function (layer) {\n        if (layer && layer.visible) {\n          // Layer is fine. Just plop it into our target canvas\n          context.drawImage(layer.view, 0, 0); // Restore layer original canvas\n\n          if (layer.exportableView) {\n            layer.view = layer.exportableView;\n            layer.exportableView = undefined;\n          }\n\n          if (layer.exportableContext) {\n            layer.context = layer.exportableContext;\n            layer.exportableContext = undefined;\n          }\n\n          if (width < layer.view.clientWidth) {\n            width = layer.view.clientWidth;\n          }\n\n          if (height < layer.view.clientHeight) {\n            height = layer.view.clientHeight;\n          }\n\n          layer.scale = undefined;\n        }\n      });\n      canvas.style.width = width + \"px\";\n      canvas.style.height = height + \"px\";\n      $array.each(canvases, function (canvas) {\n        canvas.style.position = \"\";\n        canvas.style.top = \"\";\n\n        _this.view.removeChild(canvas);\n      });\n      return canvas;\n    }\n  });\n  return CanvasRenderer;\n}(ArrayDisposer);\n\nexport { CanvasRenderer };\n\nvar GhostLayer =\n/** @class */\nfunction () {\n  function GhostLayer() {\n    Object.defineProperty(this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"margin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n    });\n    Object.defineProperty(this, \"_width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    this.view = document.createElement(\"canvas\");\n    this.context = this.view.getContext(\"2d\", {\n      alpha: false,\n      willReadFrequently: true\n    });\n    this.context.imageSmoothingEnabled = false;\n    this.view.style.position = \"absolute\";\n    this.view.style.top = \"0px\";\n    this.view.style.left = \"0px\";\n  }\n\n  Object.defineProperty(GhostLayer.prototype, \"resize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (width, height, resolution) {\n      width += this.margin.left + this.margin.right;\n      height += this.margin.top + this.margin.bottom;\n      this.view.style.left = -this.margin.left + \"px\";\n      this.view.style.top = -this.margin.top + \"px\";\n      this._width = Math.floor(width * resolution);\n      this._height = Math.floor(height * resolution);\n      this.view.width = this._width;\n      this.view.style.width = width + \"px\";\n      this.view.height = this._height;\n      this.view.style.height = height + \"px\";\n    }\n  });\n  Object.defineProperty(GhostLayer.prototype, \"getImageData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point, bbox) {\n      return this.context.getImageData( // TODO should this round ?\n      Math.round((point.x - bbox.left) / bbox.width * this._width), Math.round((point.y - bbox.top) / bbox.height * this._height), 1, 1);\n    }\n  });\n  Object.defineProperty(GhostLayer.prototype, \"setMargin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (layers) {\n      var _this = this;\n\n      this.margin.left = 0;\n      this.margin.right = 0;\n      this.margin.top = 0;\n      this.margin.bottom = 0;\n      $array.each(layers, function (layer) {\n        if (layer.margin) {\n          _this.margin.left = Math.max(_this.margin.left, layer.margin.left);\n          _this.margin.right = Math.max(_this.margin.right, layer.margin.right);\n          _this.margin.top = Math.max(_this.margin.top, layer.margin.top);\n          _this.margin.bottom = Math.max(_this.margin.bottom, layer.margin.bottom);\n        }\n      });\n    }\n  });\n  Object.defineProperty(GhostLayer.prototype, \"clear\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.context.save();\n      this.context.fillStyle = '#000';\n      this.context.fillRect(0, 0, this._width, this._height);\n    }\n  });\n  return GhostLayer;\n}();\n/**\r\n * @ignore\r\n */\n\n\nvar CanvasLayer =\n/** @class */\nfunction () {\n  function CanvasLayer(view, context) {\n    Object.defineProperty(this, \"view\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"context\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tainted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"margin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"order\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"visible\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"scale\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"dirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"exportableView\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"exportableContext\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_width\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(this, \"_height\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    this.view = view;\n    this.context = context;\n  }\n\n  Object.defineProperty(CanvasLayer.prototype, \"resize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (width, height, resolution) {\n      if (this.width != null) {\n        width = this.width;\n      }\n\n      if (this.height != null) {\n        height = this.height;\n      }\n\n      if (this.margin) {\n        width += this.margin.left + this.margin.right;\n        height += this.margin.top + this.margin.bottom;\n        this.view.style.left = -this.margin.left + \"px\";\n        this.view.style.top = -this.margin.top + \"px\";\n      } else {\n        this.view.style.left = \"0px\";\n        this.view.style.top = \"0px\";\n      }\n\n      this._width = Math.floor(width * resolution);\n      this._height = Math.floor(height * resolution);\n      this.view.width = this._width;\n      this.view.style.width = width + \"px\";\n      this.view.height = this._height;\n      this.view.style.height = height + \"px\";\n    }\n  });\n  Object.defineProperty(CanvasLayer.prototype, \"clear\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.context.save();\n      this.context.clearRect(0, 0, this._width, this._height);\n    }\n  });\n  return CanvasLayer;\n}();\n\nexport { CanvasLayer }; //# sourceMappingURL=CanvasRenderer.js.map","map":null,"metadata":{},"sourceType":"module"}