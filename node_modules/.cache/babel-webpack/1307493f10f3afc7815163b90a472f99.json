{"ast":null,"code":"import { __extends, __read } from \"tslib\";\nimport { XYChartDefaultTheme } from \"./XYChartDefaultTheme\";\nimport { Container } from \"../../core/render/Container\";\nimport { Rectangle } from \"../../core/render/Rectangle\";\nimport { SerialChart } from \"../../core/render/SerialChart\";\nimport { ListAutoDispose } from \"../../core/util/List\";\nimport { p100 } from \"../../core/util/Percent\";\nimport { Color } from \"../../core/util/Color\";\nimport { Button } from \"../../core/render/Button\";\nimport { Graphics } from \"../../core/render/Graphics\";\nimport { Percent } from \"../../core/util/Percent\";\nimport * as $array from \"../../core/util/Array\";\nimport * as $type from \"../../core/util/Type\";\nimport * as $order from \"../../core/util/Order\";\nimport * as $object from \"../../core/util/Object\";\nimport * as $utils from \"../../core/util/Utils\";\n/**\r\n * Creates an XY chart.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/} for more info\r\n * @important\r\n */\n\nvar XYChart =\n/** @class */\nfunction (_super) {\n  __extends(XYChart, _super);\n\n  function XYChart() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /**\r\n     * A list of horizontal axes.\r\n     */\n\n\n    Object.defineProperty(_this, \"xAxes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListAutoDispose()\n    });\n    /**\r\n     * A list of vertical axes.\r\n     */\n\n    Object.defineProperty(_this, \"yAxes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListAutoDispose()\n    });\n    /**\r\n     * A [[Container]] located on top of the chart, used to store top horizontal\r\n     * axes.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"topAxesContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.chartContainer.children.push(Container.new(_this._root, {\n        width: p100,\n        layout: _this._root.verticalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] located in the middle the chart, used to store vertical axes\r\n     * and plot area container.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"yAxesAndPlotContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.chartContainer.children.push(Container.new(_this._root, {\n        width: p100,\n        height: p100,\n        layout: _this._root.horizontalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] located on bottom of the chart, used to store bottom\r\n     * horizontal axes.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"bottomAxesContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.chartContainer.children.push(Container.new(_this._root, {\n        width: p100,\n        layout: _this._root.verticalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] located on left of the chart, used to store left-hand\r\n     * vertical axes.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"leftAxesContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.yAxesAndPlotContainer.children.push(Container.new(_this._root, {\n        height: p100,\n        layout: _this._root.horizontalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] located in the middle of the chart, used to store plotContainer and topPlotContainer\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"plotsContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.yAxesAndPlotContainer.children.push(Container.new(_this._root, {\n        width: p100,\n        height: p100,\n        maskContent: false\n      }))\n    });\n    /**\r\n     * A [[Container]] located in the middle of the chart, used to store actual\r\n     * plots (series).\r\n     *\r\n     * NOTE: `plotContainer` will automatically have its `background` preset. If\r\n     * you need to modify background or outline for chart's plot area, you can\r\n     * use `plotContainer.get(\"background\")` for that.*\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"plotContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.plotsContainer.children.push(Container.new(_this._root, {\n        width: p100,\n        height: p100\n      }))\n    });\n    /**\r\n     * A [[Container]] used for any elements that need to be displayed over\r\n     * regular `plotContainer`.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"topPlotContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.plotsContainer.children.push(Container.new(_this._root, {\n        width: p100,\n        height: p100\n      }))\n    });\n    /**\r\n     * A [[Container]] axis grid elements are stored in.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"gridContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.plotContainer.children.push(Container.new(_this._root, {\n        width: p100,\n        height: p100,\n        isMeasured: false\n      }))\n    });\n    /**\r\n     * A [[Container]] axis background grid elements are stored in.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"topGridContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: Container.new(_this._root, {\n        width: p100,\n        height: p100,\n        isMeasured: false\n      })\n    });\n    /**\r\n     * A [[Container]] located on right of the chart, used to store right-hand\r\n     * vertical axes.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/xy-chart-containers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"rightAxesContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.yAxesAndPlotContainer.children.push(Container.new(_this._root, {\n        height: p100,\n        layout: _this._root.horizontalLayout\n      }))\n    });\n    /**\r\n     * A [[Container]] axis headers are stored in.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/axis-headers/} for more info\r\n     * @default Container.new()\r\n     */\n\n    Object.defineProperty(_this, \"axisHeadersContainer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.plotContainer.children.push(Container.new(_this._root, {}))\n    });\n    /**\r\n     * A button that is shown when chart is not fully zoomed out.\r\n     *\r\n     * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/zoom-and-pan/#Zoom_out_button} for more info\r\n     * @default Button.new()\r\n     */\n\n    Object.defineProperty(_this, \"zoomOutButton\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _this.topPlotContainer.children.push(Button.new(_this._root, {\n        themeTags: [\"zoom\"],\n        icon: Graphics.new(_this._root, {\n          themeTags: [\"button\", \"icon\"]\n        })\n      }))\n    });\n    Object.defineProperty(_this, \"_movePoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        x: 0,\n        y: 0\n      }\n    });\n    Object.defineProperty(_this, \"_wheelDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_otherCharts\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_movePoints\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_downStartX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_downEndX\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_downStartY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_downEndY\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    return _this;\n  }\n\n  Object.defineProperty(XYChart.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._defaultThemes.push(XYChartDefaultTheme.new(this._root));\n\n      _super.prototype._afterNew.call(this);\n\n      this._disposers.push(this.xAxes);\n\n      this._disposers.push(this.yAxes);\n\n      var root = this._root;\n      var verticalLayout = this._root.verticalLayout;\n      var zoomOutButton = this.zoomOutButton;\n      zoomOutButton.events.on(\"click\", function () {\n        _this.zoomOut();\n      });\n      zoomOutButton.set(\"opacity\", 0);\n      zoomOutButton.states.lookup(\"default\").set(\"opacity\", 1);\n      this.chartContainer.set(\"layout\", verticalLayout);\n      var plotContainer = this.plotContainer;\n      plotContainer.children.push(this.seriesContainer);\n\n      this._disposers.push(this._processAxis(this.xAxes, this.bottomAxesContainer));\n\n      this._disposers.push(this._processAxis(this.yAxes, this.leftAxesContainer));\n\n      plotContainer.children.push(this.topGridContainer);\n      plotContainer.children.push(this.bulletsContainer); // Setting trasnparent background so that full body of the plot container\n      // is interactive\n\n      plotContainer.set(\"interactive\", true);\n      plotContainer.set(\"interactiveChildren\", false);\n      plotContainer.set(\"background\", Rectangle.new(root, {\n        themeTags: [\"xy\", \"background\"],\n        fill: Color.fromHex(0x000000),\n        fillOpacity: 0\n      }));\n\n      this._disposers.push(plotContainer.events.on(\"pointerdown\", function (event) {\n        _this._handlePlotDown(event.originalEvent);\n      }));\n\n      this._disposers.push(plotContainer.events.on(\"globalpointerup\", function (event) {\n        _this._handlePlotUp(event.originalEvent);\n      }));\n\n      this._disposers.push(plotContainer.events.on(\"globalpointermove\", function (event) {\n        _this._handlePlotMove(event.originalEvent);\n      }));\n\n      this._maskGrid();\n\n      this._setUpTouch();\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n\n      if (this.isDirty(\"pinchZoomX\") || this.isDirty(\"pinchZoomY\") || this.get(\"panX\") || this.get(\"panY\")) {\n        this._setUpTouch();\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_setUpTouch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this.plotContainer._display.cancelTouch) {\n        this.plotContainer._display.cancelTouch = this.get(\"pinchZoomX\") || this.get(\"pinchZoomY\") || this.get(\"panX\") || this.get(\"panY\") ? true : false;\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_maskGrid\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.gridContainer.set(\"maskContent\", true);\n      this.topGridContainer.set(\"maskContent\", true);\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_removeSeries\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series) {\n      var xAxis = series.get(\"xAxis\");\n\n      if (xAxis) {\n        $array.remove(xAxis.series, series);\n        xAxis.markDirtyExtremes();\n      }\n\n      var yAxis = series.get(\"yAxis\");\n\n      if (yAxis) {\n        $array.remove(yAxis.series, series);\n        yAxis.markDirtyExtremes();\n      }\n\n      var cursor = this.get(\"cursor\");\n\n      if (cursor) {\n        var snapToSeries = cursor.get(\"snapToSeries\");\n\n        if (snapToSeries) {\n          $array.remove(snapToSeries, series);\n        }\n      }\n\n      _super.prototype._removeSeries.call(this, series);\n    }\n  });\n  /**\r\n   * This method is invoked when mouse wheel is used over chart's plot\r\n   * container, and handles zooming/pan.\r\n   *\r\n   * You can invoke this method manually, if you need to mimic chart's wheel\r\n   * behavior over other elements of the chart.\r\n   */\n\n  Object.defineProperty(XYChart.prototype, \"handleWheel\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (event) {\n      var _this = this;\n\n      var wheelX = this.get(\"wheelX\");\n      var wheelY = this.get(\"wheelY\");\n      var plotContainer = this.plotContainer;\n      var wheelEvent = event.originalEvent; // Ignore wheel event if it is happening on a non-chart element, e.g. if\n      // some page element is over the chart.\n\n      if ($utils.isLocalEvent(wheelEvent, this)) {\n        wheelEvent.preventDefault();\n      } else {\n        return;\n      }\n\n      var plotPoint = plotContainer.toLocal(this._root.documentPointToRoot({\n        x: wheelEvent.clientX,\n        y: wheelEvent.clientY\n      }));\n      var wheelStep = this.get(\"wheelStep\", 0.2);\n      var shiftY = wheelEvent.deltaY / 100;\n      var shiftX = wheelEvent.deltaX / 100;\n      var wheelZoomPositionX = this.get(\"wheelZoomPositionX\");\n      var wheelZoomPositionY = this.get(\"wheelZoomPositionY\");\n\n      if ((wheelX === \"zoomX\" || wheelX === \"zoomXY\") && shiftX != 0) {\n        this.xAxes.each(function (axis) {\n          if (axis.get(\"zoomX\")) {\n            var start = axis.get(\"start\");\n            var end = axis.get(\"end\");\n            var position = axis.fixPosition(plotPoint.x / plotContainer.width());\n\n            if (wheelZoomPositionX != null) {\n              position = wheelZoomPositionX;\n            }\n\n            var newStart = start - wheelStep * (end - start) * shiftX * position;\n            var newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);\n\n            if (1 / (newEnd - newStart) < axis.getPrivate(\"maxZoomFactor\", Infinity) / axis.get(\"minZoomCount\", 1)) {\n              _this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n            }\n          }\n        });\n      }\n\n      if ((wheelY === \"zoomX\" || wheelY === \"zoomXY\") && shiftY != 0) {\n        this.xAxes.each(function (axis) {\n          if (axis.get(\"zoomX\")) {\n            var start = axis.get(\"start\");\n            var end = axis.get(\"end\");\n            var position = axis.fixPosition(plotPoint.x / plotContainer.width());\n\n            if (wheelZoomPositionX != null) {\n              position = wheelZoomPositionX;\n            }\n\n            var newStart = start - wheelStep * (end - start) * shiftY * position;\n            var newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);\n\n            if (1 / (newEnd - newStart) < axis.getPrivate(\"maxZoomFactor\", Infinity) / axis.get(\"minZoomCount\", 1)) {\n              _this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n            }\n          }\n        });\n      }\n\n      if ((wheelX === \"zoomY\" || wheelX === \"zoomXY\") && shiftX != 0) {\n        this.yAxes.each(function (axis) {\n          if (axis.get(\"zoomY\")) {\n            var start = axis.get(\"start\");\n            var end = axis.get(\"end\");\n            var position = axis.fixPosition(plotPoint.y / plotContainer.height());\n\n            if (wheelZoomPositionY != null) {\n              position = wheelZoomPositionY;\n            }\n\n            var newStart = start - wheelStep * (end - start) * shiftX * position;\n            var newEnd = end + wheelStep * (end - start) * shiftX * (1 - position);\n\n            if (1 / (newEnd - newStart) < axis.getPrivate(\"maxZoomFactor\", Infinity) / axis.get(\"minZoomCount\", 1)) {\n              _this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n            }\n          }\n        });\n      }\n\n      if ((wheelY === \"zoomY\" || wheelY === \"zoomXY\") && shiftY != 0) {\n        this.yAxes.each(function (axis) {\n          if (axis.get(\"zoomY\")) {\n            var start = axis.get(\"start\");\n            var end = axis.get(\"end\");\n            var position = axis.fixPosition(plotPoint.y / plotContainer.height());\n\n            if (wheelZoomPositionY != null) {\n              position = wheelZoomPositionY;\n            }\n\n            var newStart = start - wheelStep * (end - start) * shiftY * position;\n            var newEnd = end + wheelStep * (end - start) * shiftY * (1 - position);\n\n            if (1 / (newEnd - newStart) < axis.getPrivate(\"maxZoomFactor\", Infinity) / axis.get(\"minZoomCount\", 1)) {\n              _this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n            }\n          }\n        });\n      }\n\n      if ((wheelX === \"panX\" || wheelX === \"panXY\") && shiftX != 0) {\n        this.xAxes.each(function (axis) {\n          if (axis.get(\"panX\")) {\n            var start = axis.get(\"start\");\n            var end = axis.get(\"end\");\n            var delta = _this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;\n            var newStart = start + delta;\n            var newEnd = end + delta;\n\n            var se = _this._fixWheel(newStart, newEnd);\n\n            newStart = se[0];\n            newEnd = se[1];\n\n            _this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n          }\n        });\n      }\n\n      if ((wheelY === \"panX\" || wheelY === \"panXY\") && shiftY != 0) {\n        this.xAxes.each(function (axis) {\n          if (axis.get(\"panX\")) {\n            var start = axis.get(\"start\");\n            var end = axis.get(\"end\");\n            var delta = _this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;\n            var newStart = start + delta;\n            var newEnd = end + delta;\n\n            var se = _this._fixWheel(newStart, newEnd);\n\n            newStart = se[0];\n            newEnd = se[1];\n\n            _this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n          }\n        });\n      }\n\n      if ((wheelX === \"panY\" || wheelX === \"panXY\") && shiftX != 0) {\n        this.yAxes.each(function (axis) {\n          if (axis.get(\"panY\")) {\n            var start = axis.get(\"start\");\n            var end = axis.get(\"end\");\n            var delta = _this._getWheelSign(axis) * wheelStep * (end - start) * shiftX;\n            var newStart = start + delta;\n            var newEnd = end + delta;\n\n            var se = _this._fixWheel(newStart, newEnd);\n\n            newStart = se[0];\n            newEnd = se[1];\n\n            _this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n          }\n        });\n      }\n\n      if ((wheelY === \"panY\" || wheelY === \"panXY\") && shiftY != 0) {\n        this.yAxes.each(function (axis) {\n          if (axis.get(\"panY\")) {\n            var start = axis.get(\"start\");\n            var end = axis.get(\"end\");\n            var delta = _this._getWheelSign(axis) * wheelStep * (end - start) * shiftY;\n            var newStart = start - delta;\n            var newEnd = end - delta;\n\n            var se = _this._fixWheel(newStart, newEnd);\n\n            newStart = se[0];\n            newEnd = se[1];\n\n            _this._handleWheelAnimation(axis.zoom(newStart, newEnd));\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handleSetWheel\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var wheelX = this.get(\"wheelX\");\n      var wheelY = this.get(\"wheelY\");\n      var plotContainer = this.plotContainer;\n\n      if (wheelX !== \"none\" || wheelY !== \"none\") {\n        this._wheelDp = plotContainer.events.on(\"wheel\", function (event) {\n          _this.handleWheel(event);\n        });\n\n        this._disposers.push(this._wheelDp);\n      } else {\n        if (this._wheelDp) {\n          this._wheelDp.dispose();\n        }\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_getWheelSign\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (axis) {\n      var sign = 1;\n\n      if (axis.get(\"renderer\").get(\"inversed\")) {\n        sign = -1;\n      }\n\n      return sign;\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_fixWheel\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (start, end) {\n      var diff = end - start;\n\n      if (start < 0) {\n        start = 0;\n        end = start + diff;\n      }\n\n      if (end > 1) {\n        end = 1;\n        start = end - diff;\n      }\n\n      return [start, end];\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handlePlotDown\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (event) {\n      var plotContainer = this.plotContainer;\n      var local = plotContainer.toLocal(this._root.documentPointToRoot({\n        x: event.clientX,\n        y: event.clientY\n      }));\n\n      if (this.get(\"pinchZoomX\") || this.get(\"pinchZoomY\")) {\n        var touchEvent = event;\n        var pointerId = touchEvent.pointerId;\n\n        if (pointerId) {\n          if ($object.keys(plotContainer._downPoints).length > 0) {\n            var xAxis = this.xAxes.getIndex(0);\n            var yAxis = this.yAxes.getIndex(0);\n\n            if (xAxis) {\n              this._downStartX = xAxis.get(\"start\", 0);\n              this._downEndX = xAxis.get(\"end\", 1);\n            }\n\n            if (yAxis) {\n              this._downStartY = yAxis.get(\"start\", 0);\n              this._downEndY = yAxis.get(\"end\", 1);\n            }\n          }\n        }\n      }\n\n      if (this.get(\"panX\") || this.get(\"panY\")) {\n        if (local.x >= 0 && local.y >= 0 && local.x <= plotContainer.width() && local.y <= this.height()) {\n          //this._downPoint = local;\n          this._downPoint = {\n            x: event.clientX,\n            y: event.clientY\n          };\n          var panX = this.get(\"panX\");\n          var panY = this.get(\"panY\");\n\n          if (panX) {\n            this.xAxes.each(function (axis) {\n              axis._panStart = axis.get(\"start\");\n              axis._panEnd = axis.get(\"end\");\n            });\n          }\n\n          if (panY) {\n            this.yAxes.each(function (axis) {\n              axis._panStart = axis.get(\"start\");\n              axis._panEnd = axis.get(\"end\");\n            });\n          }\n\n          var eventType = \"panstarted\";\n\n          if (this.events.isEnabled(eventType)) {\n            this.events.dispatch(eventType, {\n              type: eventType,\n              target: this,\n              originalEvent: event\n            });\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handleWheelAnimation\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (animation) {\n      var _this = this;\n\n      if (animation) {\n        animation.events.on(\"stopped\", function () {\n          _this._dispatchWheelAnimation();\n        });\n      } else {\n        this._dispatchWheelAnimation();\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_dispatchWheelAnimation\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var eventType = \"wheelended\";\n\n      if (this.events.isEnabled(eventType)) {\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this\n        });\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handlePlotUp\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (event) {\n      var downPoint = this._downPoint;\n\n      if (downPoint) {\n        if (this.get(\"panX\") || this.get(\"panY\")) {\n          var local = this.plotContainer.toLocal(this._root.documentPointToRoot({\n            x: event.clientX,\n            y: event.clientY\n          }));\n\n          if (local.x == downPoint.x && local.y == downPoint.y) {\n            var eventType_1 = \"pancancelled\";\n\n            if (this.events.isEnabled(eventType_1)) {\n              this.events.dispatch(eventType_1, {\n                type: eventType_1,\n                target: this,\n                originalEvent: event\n              });\n            }\n          }\n\n          var eventType = \"panended\";\n\n          if (this.events.isEnabled(eventType)) {\n            this.events.dispatch(eventType, {\n              type: eventType,\n              target: this,\n              originalEvent: event\n            });\n          }\n        }\n      } // TODO: handle multitouch\n\n\n      this._downPoint = undefined;\n      this.xAxes.each(function (xAxis) {\n        xAxis._isPanning = false;\n      });\n      this.yAxes.each(function (yAxis) {\n        yAxis._isPanning = false;\n      });\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handlePlotMove\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (event) {\n      var plotContainer = this.plotContainer;\n\n      if (this.get(\"pinchZoomX\") || this.get(\"pinchZoomY\")) {\n        var touchEvent = event;\n        var pointerId = touchEvent.pointerId;\n\n        if (pointerId) {\n          this._movePoints[pointerId] = this._root.documentPointToRoot({\n            x: event.clientX,\n            y: event.clientY\n          });\n\n          if ($object.keys(plotContainer._downPoints).length > 1) {\n            this._handlePinch();\n\n            return;\n          }\n        }\n      }\n\n      var downPoint = this._downPoint;\n\n      if (downPoint) {\n        downPoint = plotContainer.toLocal(this._root.documentPointToRoot(downPoint));\n        var local_1 = plotContainer.toLocal(this._root.documentPointToRoot({\n          x: event.clientX,\n          y: event.clientY\n        }));\n        var panX = this.get(\"panX\");\n        var panY = this.get(\"panY\");\n\n        if (panX) {\n          var scrollbarX = this.get(\"scrollbarX\");\n\n          if (scrollbarX) {\n            scrollbarX.events.disableType(\"rangechanged\");\n          }\n\n          this.xAxes.each(function (axis) {\n            if (axis.get(\"panX\")) {\n              axis._isPanning = true; //const maxDeviation = axis.get(\"maxDeviation\", 0);\n\n              var panStart = axis._panStart;\n              var panEnd = axis._panEnd;\n              var difference = panEnd - panStart;\n              var deltaX = difference * (downPoint.x - local_1.x) / plotContainer.width();\n\n              if (axis.get(\"renderer\").get(\"inversed\")) {\n                deltaX *= -1;\n              }\n\n              var start = panStart + deltaX;\n              var end = panEnd + deltaX;\n\n              if (end - start < 1 + axis.get(\"maxDeviation\", 1) * 2) {\n                axis.set(\"start\", start);\n                axis.set(\"end\", end);\n              }\n            }\n          });\n\n          if (scrollbarX) {\n            scrollbarX.events.enableType(\"rangechanged\");\n          }\n        }\n\n        if (panY) {\n          var scrollbarY = this.get(\"scrollbarY\");\n\n          if (scrollbarY) {\n            scrollbarY.events.disableType(\"rangechanged\");\n          }\n\n          this.yAxes.each(function (axis) {\n            if (axis.get(\"panY\")) {\n              axis._isPanning = true; //const maxDeviation = axis.get(\"maxDeviation\", 0);\n\n              var panStart = axis._panStart;\n              var panEnd = axis._panEnd;\n              var difference = panEnd - panStart;\n              var deltaY = difference * (downPoint.y - local_1.y) / plotContainer.height();\n\n              if (axis.get(\"renderer\").get(\"inversed\")) {\n                deltaY *= -1;\n              }\n\n              var start = panStart - deltaY;\n              var end = panEnd - deltaY;\n\n              if (end - start < 1 + axis.get(\"maxDeviation\", 1) * 2) {\n                axis.set(\"start\", start);\n                axis.set(\"end\", end);\n              }\n            }\n          });\n\n          if (scrollbarY) {\n            scrollbarY.events.enableType(\"rangechanged\");\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handlePinch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _a, _b, _c, _d;\n\n      var _this = this;\n\n      var plotContainer = this.plotContainer;\n      var i = 0;\n      var downPoints = [];\n      var movePoints = [];\n      $object.each(plotContainer._downPoints, function (k, point) {\n        downPoints[i] = point;\n        var movePoint = _this._movePoints[k];\n\n        if (movePoint) {\n          movePoints[i] = movePoint;\n        }\n\n        i++;\n      });\n\n      if (downPoints.length > 1 && movePoints.length > 1) {\n        var w = plotContainer.width();\n        var h = plotContainer.height();\n        var downPoint0 = downPoints[0];\n        var downPoint1 = downPoints[1];\n        var movePoint0 = movePoints[0];\n        var movePoint1 = movePoints[1];\n\n        if (downPoint0 && downPoint1 && movePoint0 && movePoint1) {\n          movePoint0 = plotContainer.toLocal(movePoint0);\n          movePoint1 = plotContainer.toLocal(movePoint1);\n          downPoint0 = plotContainer.toLocal(downPoint0);\n          downPoint1 = plotContainer.toLocal(downPoint1);\n\n          if (this.get(\"pinchZoomX\")) {\n            var downStartX = this._downStartX;\n            var downEndX = this._downEndX;\n\n            if (downStartX != null && downEndX != null) {\n              if (downPoint0.x > downPoint1.x) {\n                _a = __read([downPoint1, downPoint0], 2), downPoint0 = _a[0], downPoint1 = _a[1];\n                _b = __read([movePoint1, movePoint0], 2), movePoint0 = _b[0], movePoint1 = _b[1];\n              }\n\n              var downPos0 = downStartX + downPoint0.x / w * (downEndX - downStartX);\n              var downPos1 = downStartX + downPoint1.x / w * (downEndX - downStartX);\n              var movePos0 = downStartX + movePoint0.x / w * (downEndX - downStartX);\n              var movePos1 = downStartX + movePoint1.x / w * (downEndX - downStartX);\n              var initialDistance = Math.max(0.001, downPos1 - downPos0);\n              var currentDistance = Math.max(0.001, movePos1 - movePos0);\n              var d = initialDistance / currentDistance;\n              var s_1 = downStartX * d + downPos0 - movePos0 * d;\n              var e_1 = downEndX * d + downPos1 - movePos1 * d;\n              this.xAxes.each(function (xAxis) {\n                var sa = xAxis.fixPosition(s_1);\n                var ea = xAxis.fixPosition(e_1);\n                xAxis.zoom(sa, ea, 0);\n              });\n            }\n          }\n\n          if (this.get(\"pinchZoomY\")) {\n            var downStartY = this._downStartY;\n            var downEndY = this._downEndY;\n\n            if (downStartY != null && downEndY != null) {\n              if (downPoint0.y < downPoint1.y) {\n                _c = __read([downPoint1, downPoint0], 2), downPoint0 = _c[0], downPoint1 = _c[1];\n                _d = __read([movePoint1, movePoint0], 2), movePoint0 = _d[0], movePoint1 = _d[1];\n              }\n\n              var downPos0 = downStartY + (1 - downPoint0.y / h) * (downEndY - downStartY);\n              var downPos1 = downStartY + (1 - downPoint1.y / h) * (downEndY - downStartY);\n              var movePos0 = downStartY + (1 - movePoint0.y / h) * (downEndY - downStartY);\n              var movePos1 = downStartY + (1 - movePoint1.y / h) * (downEndY - downStartY);\n              var initialDistance = Math.max(0.001, downPos1 - downPos0);\n              var currentDistance = Math.max(0.001, movePos1 - movePos0);\n              var d = initialDistance / currentDistance;\n              var s_2 = downStartY * d + downPos0 - movePos0 * d;\n              var e_2 = downEndY * d + downPos1 - movePos1 * d;\n              this.yAxes.each(function (yAxis) {\n                var sa = yAxis.fixPosition(s_2);\n                var ea = yAxis.fixPosition(e_2);\n                yAxis.zoom(sa, ea, 0);\n              });\n            }\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handleCursorPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var cursor = this.get(\"cursor\");\n\n      if (cursor) {\n        var cursorPoint_1 = cursor.getPrivate(\"point\");\n        var snapToSeries = cursor.get(\"snapToSeries\");\n\n        if (cursor._downPoint) {\n          snapToSeries = undefined;\n        }\n\n        if (snapToSeries && cursorPoint_1) {\n          var snapToSeriesBy_1 = cursor.get(\"snapToSeriesBy\");\n          var dataItems_1 = [];\n          $array.each(snapToSeries, function (series) {\n            if (!series.isHidden() && !series.isHiding()) {\n              if (snapToSeriesBy_1 != \"x!\" && snapToSeriesBy_1 != \"y!\") {\n                var startIndex = series.startIndex();\n                var endIndex = series.endIndex();\n\n                for (var i = startIndex; i < endIndex; i++) {\n                  var dataItem = series.dataItems[i];\n\n                  if (dataItem && !dataItem.isHidden()) {\n                    dataItems_1.push(dataItem);\n                  }\n                }\n              } else {\n                var tooltipDataItem = series.get(\"tooltipDataItem\");\n\n                if (tooltipDataItem) {\n                  dataItems_1.push(tooltipDataItem);\n                }\n              }\n            }\n          });\n          var minDistance_1 = Infinity;\n          var closestItem_1;\n          $array.each(dataItems_1, function (dataItem) {\n            var point = dataItem.get(\"point\");\n\n            if (point) {\n              var distance = 0;\n\n              if (snapToSeriesBy_1 == \"x\" || snapToSeriesBy_1 == \"x!\") {\n                distance = Math.abs(cursorPoint_1.x - point.x);\n              } else if (snapToSeriesBy_1 == \"y\" || snapToSeriesBy_1 == \"y!\") {\n                distance = Math.abs(cursorPoint_1.y - point.y);\n              } else {\n                distance = Math.hypot(cursorPoint_1.x - point.x, cursorPoint_1.y - point.y);\n              }\n\n              if (distance < minDistance_1) {\n                minDistance_1 = distance;\n                closestItem_1 = dataItem;\n              }\n            }\n          });\n          $array.each(snapToSeries, function (series) {\n            var tooltip = series.get(\"tooltip\");\n\n            if (tooltip) {\n              tooltip._setDataItem(undefined);\n            }\n          });\n\n          if (closestItem_1) {\n            var series = closestItem_1.component;\n            series.showDataItemTooltip(closestItem_1);\n            var point = closestItem_1.get(\"point\");\n\n            if (point) {\n              // removing x and y to solve #72225\n              cursor.handleMove(series.toGlobal({\n                x: point.x - series.x(),\n                y: point.y - series.y()\n              }), true);\n            }\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_updateCursor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var cursor = this.get(\"cursor\");\n\n      if (cursor) {\n        cursor.handleMove();\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_addCursor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (cursor) {\n      this.plotContainer.children.push(cursor);\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_prepareChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._prepareChildren.call(this);\n\n      this.series.each(function (series) {\n        _this._colorize(series);\n      });\n\n      if (this.isDirty(\"wheelX\") || this.isDirty(\"wheelY\")) {\n        this._handleSetWheel();\n      }\n\n      if (this.isDirty(\"cursor\")) {\n        var previous = this._prevSettings.cursor;\n        var cursor = this.get(\"cursor\");\n\n        if (cursor !== previous) {\n          this._disposeProperty(\"cursor\");\n\n          if (previous) {\n            previous.dispose();\n          }\n\n          if (cursor) {\n            cursor._setChart(this);\n\n            this._addCursor(cursor);\n\n            this._pushPropertyDisposer(\"cursor\", cursor.events.on(\"selectended\", function () {\n              _this._handleCursorSelectEnd();\n            }));\n          } //this.setRaw(\"cursor\", cursor) // to reset previous value\n\n\n          this._prevSettings.cursor = cursor;\n        }\n      }\n\n      if (this.isDirty(\"scrollbarX\")) {\n        var previous = this._prevSettings.scrollbarX;\n        var scrollbarX = this.get(\"scrollbarX\");\n\n        if (scrollbarX !== previous) {\n          this._disposeProperty(\"scrollbarX\");\n\n          if (previous) {\n            previous.dispose();\n          }\n\n          if (scrollbarX) {\n            if (!scrollbarX.parent) {\n              this.topAxesContainer.children.push(scrollbarX);\n            }\n\n            this._pushPropertyDisposer(\"scrollbarX\", scrollbarX.events.on(\"rangechanged\", function (e) {\n              _this._handleScrollbar(_this.xAxes, e.start, e.end, e.grip);\n            })); // Used to populate `ariaLabel` with meaningful values\n\n\n            scrollbarX.setPrivate(\"positionTextFunction\", function (position) {\n              var axis = _this.xAxes.getIndex(0);\n\n              return axis ? axis.getTooltipText(position) || \"\" : \"\";\n            });\n          }\n\n          this._prevSettings.scrollbarX = scrollbarX;\n        }\n      }\n\n      if (this.isDirty(\"scrollbarY\")) {\n        var previous = this._prevSettings.scrollbarY;\n        var scrollbarY = this.get(\"scrollbarY\");\n\n        if (scrollbarY !== previous) {\n          this._disposeProperty(\"scrollbarY\");\n\n          if (previous) {\n            previous.dispose();\n          }\n\n          if (scrollbarY) {\n            if (!scrollbarY.parent) {\n              this.rightAxesContainer.children.push(scrollbarY);\n            }\n\n            this._pushPropertyDisposer(\"scrollbarY\", scrollbarY.events.on(\"rangechanged\", function (e) {\n              _this._handleScrollbar(_this.yAxes, e.start, e.end, e.grip);\n            })); // Used to populate `ariaLabel` with meaningful values\n\n\n            scrollbarY.setPrivate(\"positionTextFunction\", function (position) {\n              var axis = _this.yAxes.getIndex(0);\n\n              return axis ? axis.getTooltipText(position) || \"\" : \"\";\n            });\n          }\n\n          this._prevSettings.scrollbarY = scrollbarY;\n        }\n      }\n\n      this._handleZoomOut();\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_processSeries\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series) {\n      _super.prototype._processSeries.call(this, series);\n\n      this._colorize(series);\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_colorize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series) {\n      var colorSet = this.get(\"colors\");\n\n      if (colorSet) {\n        if (series.get(\"fill\") == null) {\n          var color = colorSet.next();\n\n          series._setSoft(\"stroke\", color);\n\n          series._setSoft(\"fill\", color);\n        }\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handleCursorSelectEnd\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var cursor = this.get(\"cursor\");\n      var behavior = cursor.get(\"behavior\");\n      var downPositionX = cursor.getPrivate(\"downPositionX\", 0);\n      var downPositionY = cursor.getPrivate(\"downPositionY\", 0);\n      var positionX = cursor.getPrivate(\"positionX\", 0.5);\n      var positionY = cursor.getPrivate(\"positionY\", 0.5);\n      this.xAxes.each(function (axis) {\n        if (behavior === \"zoomX\" || behavior === \"zoomXY\") {\n          var position0 = axis.toAxisPosition(downPositionX);\n          var position1 = axis.toAxisPosition(positionX);\n          axis.zoom(position0, position1);\n        }\n\n        axis.setPrivate(\"updateScrollbar\", true);\n      });\n      this.yAxes.each(function (axis) {\n        if (behavior === \"zoomY\" || behavior === \"zoomXY\") {\n          var position0 = axis.toAxisPosition(downPositionY);\n          var position1 = axis.toAxisPosition(positionY);\n          axis.zoom(position0, position1);\n        }\n\n        axis.setPrivate(\"updateScrollbar\", true);\n      });\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handleScrollbar\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (axes, start, end, priority) {\n      axes.each(function (axis) {\n        var axisStart = axis.fixPosition(start);\n        var axisEnd = axis.fixPosition(end);\n        var zoomAnimation = axis.zoom(axisStart, axisEnd, undefined, priority);\n        var updateScrollbar = \"updateScrollbar\";\n        axis.setPrivateRaw(updateScrollbar, false);\n\n        if (zoomAnimation) {\n          zoomAnimation.events.on(\"stopped\", function () {\n            axis.setPrivateRaw(updateScrollbar, true);\n          });\n        } else {\n          axis.setPrivateRaw(updateScrollbar, true);\n        }\n      });\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_processAxis\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (axes, container) {\n      var _this = this;\n\n      return axes.events.onAll(function (change) {\n        if (change.type === \"clear\") {\n          $array.each(change.oldValues, function (axis) {\n            _this._removeAxis(axis);\n          });\n        } else if (change.type === \"push\") {\n          container.children.push(change.newValue);\n          change.newValue.processChart(_this);\n        } else if (change.type === \"setIndex\") {\n          container.children.setIndex(change.index, change.newValue);\n          change.newValue.processChart(_this);\n        } else if (change.type === \"insertIndex\") {\n          container.children.insertIndex(change.index, change.newValue);\n          change.newValue.processChart(_this);\n        } else if (change.type === \"removeIndex\") {\n          _this._removeAxis(change.oldValue);\n        } else if (change.type === \"moveIndex\") {\n          container.children.moveValue(change.value, change.newIndex);\n          change.value.processChart(_this);\n        } else {\n          throw new Error(\"Unknown IListEvent type\");\n        }\n      });\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_removeAxis\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (axis) {\n      if (!axis.isDisposed()) {\n        var axisParent = axis.parent;\n\n        if (axisParent) {\n          axisParent.children.removeValue(axis);\n        }\n\n        var gridContainer = axis.gridContainer;\n        var gridParent = gridContainer.parent;\n\n        if (gridParent) {\n          gridParent.children.removeValue(gridContainer);\n        }\n\n        var topGridContainer = axis.topGridContainer;\n        var topGridParent = topGridContainer.parent;\n\n        if (topGridParent) {\n          topGridParent.children.removeValue(topGridContainer);\n        }\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_updateChartLayout\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var left = this.leftAxesContainer.width();\n      var right = this.rightAxesContainer.width();\n      var bottomAxesContainer = this.bottomAxesContainer;\n      bottomAxesContainer.set(\"paddingLeft\", left);\n      bottomAxesContainer.set(\"paddingRight\", right);\n      var topAxesContainer = this.topAxesContainer;\n      topAxesContainer.set(\"paddingLeft\", left);\n      topAxesContainer.set(\"paddingRight\", right);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(XYChart.prototype, \"processAxis\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_axis) {}\n  });\n  ;\n  Object.defineProperty(XYChart.prototype, \"_handleAxisSelection\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (axis, force) {\n      var _a;\n\n      var start = axis.fixPosition(axis.get(\"start\", 0));\n      var end = axis.fixPosition(axis.get(\"end\", 1));\n\n      if (start > end) {\n        _a = __read([end, start], 2), start = _a[0], end = _a[1];\n      }\n\n      if (this.xAxes.indexOf(axis) != -1) {\n        if (force || axis.getPrivate(\"updateScrollbar\")) {\n          var scrollbarX = this.get(\"scrollbarX\");\n\n          if (scrollbarX && (!scrollbarX.getPrivate(\"isBusy\") || force)) {\n            scrollbarX.setRaw(\"start\", start);\n            scrollbarX.setRaw(\"end\", end);\n            scrollbarX.updateGrips();\n          }\n        }\n      } else if (this.yAxes.indexOf(axis) != -1) {\n        if (force || axis.getPrivate(\"updateScrollbar\")) {\n          var scrollbarY = this.get(\"scrollbarY\");\n\n          if (scrollbarY && (!scrollbarY.getPrivate(\"isBusy\") || force)) {\n            scrollbarY.setRaw(\"start\", start);\n            scrollbarY.setRaw(\"end\", end);\n            scrollbarY.updateGrips();\n          }\n        }\n      }\n\n      this._handleZoomOut();\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_handleZoomOut\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var zoomOutButton = this.zoomOutButton;\n\n      if (zoomOutButton && zoomOutButton.parent) {\n        var visible_1 = false;\n        this.xAxes.each(function (axis) {\n          if (axis.get(\"start\") != 0 || axis.get(\"end\") != 1) {\n            visible_1 = true;\n          }\n        });\n        this.yAxes.each(function (axis) {\n          if (axis.get(\"start\") != 0 || axis.get(\"end\") != 1) {\n            visible_1 = true;\n          }\n        });\n\n        if (visible_1) {\n          if (zoomOutButton.isHidden()) {\n            zoomOutButton.show();\n          }\n        } else {\n          zoomOutButton.hide();\n        }\n      }\n    }\n  });\n  /**\r\n   * Checks if point is within plot area.\r\n   *\r\n   * @param   point  Reference point\r\n   * @return         Is within plot area?\r\n   */\n\n  Object.defineProperty(XYChart.prototype, \"inPlot\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      var plotContainer = this.plotContainer;\n      var otherCharts = this.getPrivate(\"otherCharts\", this._otherCharts);\n      var global = plotContainer.toGlobal(point);\n\n      if (point.x >= -0.1 && point.y >= -0.1 && point.x <= plotContainer.width() + 0.1 && point.y <= plotContainer.height() + 0.1) {\n        return true;\n      }\n\n      if (otherCharts) {\n        for (var i = otherCharts.length - 1; i >= 0; i--) {\n          var chart = otherCharts[i];\n\n          if (chart != this) {\n            var chartPlotContainer = chart.plotContainer;\n\n            var documentPoint = this._root.rootPointToDocument(global);\n\n            var chartRoot = chart._root.documentPointToRoot(documentPoint);\n\n            var local = chartPlotContainer.toLocal(chartRoot);\n\n            if (local.x >= -0.1 && local.y >= -0.1 && local.x <= chartPlotContainer.width() + 0.1 && local.y <= chartPlotContainer.height() + 0.1) {\n              return true;\n            }\n          }\n        }\n      }\n\n      return false;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(XYChart.prototype, \"arrangeTooltips\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var plotContainer = this.plotContainer;\n      var w = plotContainer.width();\n      var h = plotContainer.height();\n      var hh = this.height();\n\n      var plotT = plotContainer._display.toGlobal({\n        x: 0,\n        y: 0\n      });\n\n      var plotB = plotContainer._display.toGlobal({\n        x: w,\n        y: h\n      });\n\n      var tooltips = [];\n      var sum = 0;\n      var minDistance = Infinity;\n      var movePoint = this._movePoint;\n      var maxTooltipDistance = this.get(\"maxTooltipDistance\");\n      var maxTooltipDistanceBy = this.get(\"maxTooltipDistanceBy\", \"xy\");\n      var closest;\n      var closestPoint;\n\n      if ($type.isNumber(maxTooltipDistance)) {\n        this.series.each(function (series) {\n          var tooltip = series.get(\"tooltip\");\n\n          if (tooltip) {\n            var point = tooltip.get(\"pointTo\");\n\n            if (point) {\n              var distance = Math.hypot(movePoint.x - point.x, movePoint.y - point.y);\n\n              if (maxTooltipDistanceBy == \"x\") {\n                distance = Math.abs(movePoint.x - point.x);\n              } else if (maxTooltipDistanceBy == \"y\") {\n                distance = Math.abs(movePoint.y - point.y);\n              }\n\n              if (distance < minDistance) {\n                minDistance = distance;\n                closest = series;\n                closestPoint = point;\n              }\n            }\n          }\n        });\n      }\n\n      var tooltipSeries = [];\n      this.series.each(function (series) {\n        var tooltip = series.get(\"tooltip\");\n\n        if (tooltip) {\n          var hidden = false;\n          var point = tooltip.get(\"pointTo\");\n\n          if (point) {\n            if (maxTooltipDistance >= 0) {\n              var point_1 = tooltip.get(\"pointTo\");\n\n              if (point_1) {\n                if (series != closest) {\n                  var distance = Math.hypot(closestPoint.x - point_1.x, closestPoint.y - point_1.y);\n\n                  if (maxTooltipDistanceBy == \"x\") {\n                    distance = Math.abs(closestPoint.x - point_1.x);\n                  } else if (maxTooltipDistanceBy == \"y\") {\n                    distance = Math.abs(closestPoint.y - point_1.y);\n                  }\n\n                  if (distance > maxTooltipDistance) {\n                    hidden = true;\n                  }\n                }\n              }\n            } else if (maxTooltipDistance == -1) {\n              if (series != closest) {\n                hidden = true;\n              }\n            }\n\n            if (!_this.inPlot(_this._tooltipToLocal(point)) || !tooltip.dataItem) {\n              hidden = true;\n            } else {\n              if (!hidden) {\n                sum += point.y;\n              }\n            }\n\n            if (hidden || series.isHidden() || series.isHiding()) {\n              tooltip.hide(0);\n            } else {\n              tooltip.show();\n              tooltips.push(tooltip);\n              tooltipSeries.push(series);\n            }\n          }\n        }\n      });\n      this.setPrivate(\"tooltipSeries\", tooltipSeries);\n\n      if (this.get(\"arrangeTooltips\")) {\n        var tooltipContainer_1 = this._root.tooltipContainer;\n        var count = tooltips.length;\n        var average = sum / count;\n\n        if (average > h / 2 + plotT.y) {\n          tooltips.sort(function (a, b) {\n            return $order.compareNumber(b.get(\"pointTo\").y, a.get(\"pointTo\").y);\n          });\n          var prevY_1 = plotB.y;\n          $array.each(tooltips, function (tooltip) {\n            var height = tooltip.height();\n            var centerY = tooltip.get(\"centerY\");\n\n            if (centerY instanceof Percent) {\n              height *= centerY.value;\n            }\n\n            height += tooltip.get(\"marginBottom\", 0);\n            tooltip.set(\"bounds\", {\n              left: plotT.x,\n              top: plotT.y,\n              right: plotB.x,\n              bottom: prevY_1\n            });\n            tooltip.setPrivate(\"customData\", {\n              left: plotT.x,\n              top: plotT.y,\n              right: plotB.x,\n              bottom: prevY_1\n            });\n            prevY_1 = Math.min(prevY_1 - height, tooltip._fy - height);\n\n            if (tooltip.parent == tooltipContainer_1) {\n              tooltipContainer_1.children.moveValue(tooltip, 0);\n            }\n          });\n\n          if (prevY_1 < 0) {\n            tooltips.reverse();\n            var prevBottom_1 = prevY_1;\n            $array.each(tooltips, function (tooltip) {\n              var bounds = tooltip.get(\"bounds\");\n\n              if (bounds) {\n                var top_1 = bounds.top - prevY_1;\n                var bottom = bounds.bottom - prevY_1;\n\n                if (top_1 < prevBottom_1) {\n                  top_1 = prevBottom_1;\n                  bottom = top_1 + tooltip.height();\n                }\n\n                tooltip.set(\"bounds\", {\n                  left: bounds.left,\n                  top: top_1,\n                  right: bounds.right,\n                  bottom: bottom\n                });\n                prevBottom_1 = bounds.bottom - prevY_1 + tooltip.get(\"marginBottom\", 0);\n              }\n            });\n          }\n        } else {\n          tooltips.reverse();\n          tooltips.sort(function (a, b) {\n            return $order.compareNumber(a.get(\"pointTo\").y, b.get(\"pointTo\").y);\n          });\n          var prevY_2 = 0;\n          $array.each(tooltips, function (tooltip) {\n            var height = tooltip.height();\n            var centerY = tooltip.get(\"centerY\");\n\n            if (centerY instanceof Percent) {\n              height *= centerY.value;\n            }\n\n            height += tooltip.get(\"marginBottom\", 0);\n            tooltip.set(\"bounds\", {\n              left: plotT.x,\n              top: prevY_2,\n              right: plotB.x,\n              bottom: Math.max(plotT.y + hh, prevY_2 + height)\n            });\n\n            if (tooltip.parent == tooltipContainer_1) {\n              tooltipContainer_1.children.moveValue(tooltip, 0);\n            }\n\n            prevY_2 = Math.max(prevY_2 + height, tooltip._fy + height);\n          });\n\n          if (prevY_2 > hh) {\n            tooltips.reverse();\n            var prevBottom_2 = hh;\n            $array.each(tooltips, function (tooltip) {\n              var bounds = tooltip.get(\"bounds\");\n\n              if (bounds) {\n                var top_2 = bounds.top - (hh - prevY_2);\n                var bottom = bounds.bottom - (hh - prevY_2);\n\n                if (bottom > prevBottom_2) {\n                  bottom = prevBottom_2;\n                  top_2 = bottom - tooltip.height();\n                }\n\n                tooltip.set(\"bounds\", {\n                  left: bounds.left,\n                  top: top_2,\n                  right: bounds.right,\n                  bottom: bottom\n                });\n                prevBottom_2 = bottom - tooltip.height() - tooltip.get(\"marginBottom\", 0);\n              }\n            });\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(XYChart.prototype, \"_tooltipToLocal\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      return this.plotContainer.toLocal(point);\n    }\n  });\n  /**\r\n   * Fully zooms out the chart.\r\n   */\n\n  Object.defineProperty(XYChart.prototype, \"zoomOut\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.xAxes.each(function (axis) {\n        axis.setPrivate(\"updateScrollbar\", true);\n        axis.zoom(0, 1);\n      });\n      this.yAxes.each(function (axis) {\n        axis.setPrivate(\"updateScrollbar\", true);\n        axis.zoom(0, 1);\n      });\n    }\n  });\n  Object.defineProperty(XYChart, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"XYChart\"\n  });\n  Object.defineProperty(XYChart, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: SerialChart.classNames.concat([XYChart.className])\n  });\n  return XYChart;\n}(SerialChart);\n\nexport { XYChart }; //# sourceMappingURL=XYChart.js.map","map":null,"metadata":{},"sourceType":"module"}