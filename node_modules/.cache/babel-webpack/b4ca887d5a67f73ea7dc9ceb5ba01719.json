{"ast":null,"code":"import { Color } from \"./Color\";\nimport * as $type from \"./Type\";\n\nvar TextFormatter =\n/** @class */\nfunction () {\n  function TextFormatter() {}\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n\n  Object.defineProperty(TextFormatter, \"escape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(/\\[\\[/g, this.prefix + \"1\").replace(/([^\\/\\]]{1})\\]\\]/g, \"$1\" + this.prefix + \"2\").replace(/\\]\\]/g, this.prefix + \"2\").replace(/\\{\\{/g, this.prefix + \"3\").replace(/\\}\\}/g, this.prefix + \"4\").replace(/\\'\\'/g, this.prefix + \"5\");\n    }\n  });\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n  Object.defineProperty(TextFormatter, \"unescape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(new RegExp(this.prefix + \"1\", \"g\"), \"[[\").replace(new RegExp(this.prefix + \"2\", \"g\"), \"]]\").replace(new RegExp(this.prefix + \"3\", \"g\"), \"{{\").replace(new RegExp(this.prefix + \"4\", \"g\"), \"}}\").replace(new RegExp(this.prefix + \"5\", \"g\"), \"''\");\n    }\n  });\n  /**\r\n   * Cleans up the text text for leftover double square brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Cleaned up text\r\n   */\n\n  Object.defineProperty(TextFormatter, \"cleanUp\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(/\\[\\[/g, \"[\").replace(/\\]\\]/g, \"]\").replace(/\\{\\{/g, \"{\").replace(/\\}\\}/g, \"}\").replace(/\\'\\'/g, \"'\");\n    }\n  });\n  /**\r\n   * Splits string into chunks. (style blocks, quoted blocks, regular blocks)\r\n   *\r\n   * If the second parameter `quotedBlocks` is set to `true` this method will\r\n   * also single out text blocks enclosed within single quotes that no\r\n   * formatting should be applied to, and they should be displayed as is.\r\n   *\r\n   * Default for the above is `false`, so that you can use single quote in text\r\n   * without escaping it.\r\n   *\r\n   * If enabled, single quotes can be escaped by doubling it - adding two\r\n   * single quotes, which will be replaced by a one single quote in the final\r\n   * output.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text          Text to chunk\r\n   * @param quotedBlocks  Use quoted blocks\r\n   * @param noFormatting  Formatting blocks will be treated as regular text\r\n   * @return Array of string chunks\r\n   */\n\n  Object.defineProperty(TextFormatter, \"chunk\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text, quotedBlocks, noFormatting) {\n      if (quotedBlocks === void 0) {\n        quotedBlocks = false;\n      }\n\n      if (noFormatting === void 0) {\n        noFormatting = false;\n      } // Init result\n\n\n      var res = []; // Replace double (escaped) square spaces and quotes with temporary codes\n\n      text = this.escape(text); // Deal with style blocks\n\n      var chunks = quotedBlocks ? text.split(\"'\") : [text];\n\n      for (var i = 0; i < chunks.length; i++) {\n        var chunk = chunks[i]; // Empty?\n\n        if (chunk === \"\") {\n          continue;\n        }\n\n        if (i % 2 === 0) {\n          // Text outside quotes\n          // Parse for style blocks which are \"text\" chunks, the rest chunks are\n          // \"value\"\n          chunk = chunk.replace(/\\]\\[/g, \"]\" + $type.PLACEHOLDER + \"[\");\n          chunk = chunk.replace(/\\[\\]/g, \"[ ]\");\n          var chunks2 = chunk.split(/[\\[\\]]+/);\n\n          for (var i2 = 0; i2 < chunks2.length; i2++) {\n            var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Placeholder?\n\n            if (chunk2 === $type.PLACEHOLDER) {\n              continue;\n            } // Empty?\n\n\n            if (chunk2 === \"\") {\n              continue;\n            } // Block or value\n\n\n            if (i2 % 2 === 0) {\n              res.push({\n                \"type\": \"value\",\n                \"text\": chunk2\n              });\n            } else {\n              res.push({\n                \"type\": noFormatting ? \"value\" : \"format\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            }\n          }\n        } else {\n          // A text within doublequotes\n          // All chunks are \"text\"\n          var chunks2 = chunk.split(/[\\[\\]]+/);\n\n          for (var i2 = 0; i2 < chunks2.length; i2++) {\n            var chunk2 = this.cleanUp(this.unescape(chunks2[i2])); // Empty?\n\n            if (chunk2 === \"\") {\n              continue;\n            } // Block or text\n\n\n            if (i2 % 2 === 0) {\n              res.push({\n                \"type\": \"text\",\n                \"text\": chunk2\n              });\n            } else if (this.isImage(chunk2)) {\n              res.push({\n                \"type\": \"image\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            } else {\n              res.push({\n                \"type\": \"format\",\n                \"text\": \"[\" + chunk2 + \"]\"\n              });\n            }\n          }\n        }\n      }\n\n      return res;\n    }\n  });\n  /**\r\n   * Checks if supplied format contains image information and should be\r\n   * formatted as such.\r\n   * I.e.: `[img: myImage.png]`\r\n   *\r\n   * @ignore\r\n   * @param  text  Format\r\n   * @return true if it is an image\r\n   */\n\n  Object.defineProperty(TextFormatter, \"isImage\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.match(/img[ ]?:/) ? true : false;\n    }\n  });\n  Object.defineProperty(TextFormatter, \"getTextStyle\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (style) {\n      // let textStyle: string[] = [];\n      // let textFill: string | undefined;\n      var format = {};\n\n      if (style == \"\" || style == \"[ ]\") {\n        return {};\n      } // Pre-process quoted text\n\n\n      var q = style.match(/('[^']*')|(\"[^\"]*\")/gi);\n\n      if (q) {\n        for (var i = 0; i < q.length; i++) {\n          style = style.replace(q[i], q[i].replace(/['\"]*/g, \"\").replace(/[ ]+/g, \"+\"));\n        }\n      } // Get style parts\n\n\n      var b = style.match(/([\\w\\-]*:[\\s]?[^;\\s\\]]*)|(\\#[\\w]{1,6})|([\\w\\-]+)|(\\/)/gi); // Empty?\n\n      if (!b) {\n        return {};\n      } // Check each part\n\n\n      for (var i = 0; i < b.length; i++) {\n        if (b[i].match(/^(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)$/i)) {\n          format.fontWeight = b[i];\n        } else if (b[i].match(/^(underline|line-through)$/i)) {\n          format.textDecoration = b[i];\n        } else if (b[i] == \"/\") {// Just closing tag\n          // Do nothing\n        } else if (!b[i].match(/:/)) {\n          // Color\n          format.fill = Color.fromString(b[i]);\n        } else {\n          var p = b[i].replace(\"+\", \" \").split(/:[ ]*/);\n          format[p[0]] = p[1]; //textStyle.push(b[i].replace(/^[a-zA-Z]:[ ]*/, \"\"));\n          //b[i] = b[i].replace(/\\+/g, \" \");\n        }\n      }\n\n      return format;\n    }\n  });\n  Object.defineProperty(TextFormatter, \"prefix\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"__amcharts__\"\n  });\n  return TextFormatter;\n}();\n\nexport { TextFormatter }; //# sourceMappingURL=TextFormatter.js.map","map":null,"metadata":{},"sourceType":"module"}