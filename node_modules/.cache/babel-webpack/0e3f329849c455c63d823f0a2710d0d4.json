{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Entity } from \"./Entity\";\nimport { TextFormatter } from \"./TextFormatter\";\nimport * as $object from \"./Object\";\nimport * as $utils from \"./Utils\";\nimport * as $type from \"./Type\";\n/**\r\n * Number formatter\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/formatters/formatting-numbers/} for more info\r\n * @important\r\n */\n\nvar NumberFormatter =\n/** @class */\nfunction (_super) {\n  __extends(NumberFormatter, _super);\n\n  function NumberFormatter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(NumberFormatter.prototype, \"_setDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      // Defaults\n      this._setDefault(\"negativeBase\", 0);\n\n      this._setDefault(\"numberFormat\", \"#,###.#####\");\n\n      this._setDefault(\"smallNumberThreshold\", 1.00);\n\n      var bns = \"_big_number_suffix_\";\n      var sns = \"_small_number_suffix_\";\n      var bs = \"_byte_suffix_\";\n\n      this._setDefault(\"bigNumberPrefixes\", [{\n        \"number\": 1e+3,\n        \"suffix\": this._t(bns + \"3\")\n      }, {\n        \"number\": 1e+6,\n        \"suffix\": this._t(bns + \"6\")\n      }, {\n        \"number\": 1e+9,\n        \"suffix\": this._t(bns + \"9\")\n      }, {\n        \"number\": 1e+12,\n        \"suffix\": this._t(bns + \"12\")\n      }, {\n        \"number\": 1e+15,\n        \"suffix\": this._t(bns + \"15\")\n      }, {\n        \"number\": 1e+18,\n        \"suffix\": this._t(bns + \"18\")\n      }, {\n        \"number\": 1e+21,\n        \"suffix\": this._t(bns + \"21\")\n      }, {\n        \"number\": 1e+24,\n        \"suffix\": this._t(bns + \"24\")\n      }]);\n\n      this._setDefault(\"smallNumberPrefixes\", [{\n        \"number\": 1e-24,\n        \"suffix\": this._t(sns + \"24\")\n      }, {\n        \"number\": 1e-21,\n        \"suffix\": this._t(sns + \"21\")\n      }, {\n        \"number\": 1e-18,\n        \"suffix\": this._t(sns + \"18\")\n      }, {\n        \"number\": 1e-15,\n        \"suffix\": this._t(sns + \"15\")\n      }, {\n        \"number\": 1e-12,\n        \"suffix\": this._t(sns + \"12\")\n      }, {\n        \"number\": 1e-9,\n        \"suffix\": this._t(sns + \"9\")\n      }, {\n        \"number\": 1e-6,\n        \"suffix\": this._t(sns + \"6\")\n      }, {\n        \"number\": 1e-3,\n        \"suffix\": this._t(sns + \"3\")\n      }]);\n\n      this._setDefault(\"bytePrefixes\", [{\n        \"number\": 1,\n        suffix: this._t(bs + \"B\")\n      }, {\n        \"number\": 1024,\n        suffix: this._t(bs + \"KB\")\n      }, {\n        \"number\": 1048576,\n        suffix: this._t(bs + \"MB\")\n      }, {\n        \"number\": 1073741824,\n        suffix: this._t(bs + \"GB\")\n      }, {\n        \"number\": 1099511627776,\n        suffix: this._t(bs + \"TB\")\n      }, {\n        \"number\": 1125899906842624,\n        suffix: this._t(bs + \"PB\")\n      }]);\n\n      _super.prototype._setDefaults.call(this);\n    }\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n    }\n  });\n  /**\r\n   * Formats the number according to specific format.\r\n   *\r\n   * @param value   Value to format\r\n   * @param format  Format to apply\r\n   * @return Formatted number\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"format\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, format, precision) {\n      // no format passed in or \"Number\"\n      if (format == null || $type.isString(format) && format.toLowerCase() === \"number\") {\n        format = this.get(\"numberFormat\", \"\");\n      } // Init return value\n\n\n      var formatted; // Cast to number just in case\n      // TODO: maybe use better casting\n\n      var source = Number(value); // Is it a built-in format or Intl.NumberFormatOptions\n\n      if ($type.isObject(format)) {\n        try {\n          if (this.get(\"intlLocales\")) {\n            return new Intl.NumberFormat(this.get(\"intlLocales\"), format).format(source);\n          } else {\n            return new Intl.NumberFormat(undefined, format).format(source);\n          }\n        } catch (e) {\n          return \"Invalid\";\n        }\n      } else {\n        // Clean format\n        format = $utils.cleanFormat(format); // Get format info (it will also deal with parser caching)\n\n        var info = this.parseFormat(format, this._root.language); // format and replace the number\n\n        var details = void 0;\n\n        if (source > this.get(\"negativeBase\")) {\n          details = info.positive;\n        } else if (source < this.get(\"negativeBase\")) {\n          details = info.negative;\n        } else {\n          details = info.zero;\n        } // Adjust precision\n\n\n        if (precision != null && !details.mod) {\n          details = $object.copy(details);\n          details.decimals.active = source == 0 ? 0 : precision;\n        } // Format\n\n\n        formatted = details.template.split($type.PLACEHOLDER).join(this.applyFormat(source, details));\n      }\n\n      return formatted;\n    }\n  });\n  /**\r\n   * Parses supplied format into structured object which can be used to format\r\n   * the number.\r\n   *\r\n   * @param format Format string, i.e. \"#,###.00\"\r\n   * @param language Language\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"parseFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (format, language) {\n      // Check cache\n      // TODO\n      // let cached = this.getCache(format);\n      // if (cached != null) {\n      // \treturn cached;\n      // }\n      var _this = this;\n\n      var thousandSeparator = language.translateEmpty(\"_thousandSeparator\");\n      var decimalSeparator = language.translateEmpty(\"_decimalSeparator\"); // init format parse info holder\n\n      var info = {\n        \"positive\": {\n          \"thousands\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"interval\": -1,\n            \"separator\": thousandSeparator\n          },\n          \"decimals\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"separator\": decimalSeparator\n          },\n          \"template\": \"\",\n          \"source\": \"\",\n          \"parsed\": false\n        },\n        \"negative\": {\n          \"thousands\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"interval\": -1,\n            \"separator\": thousandSeparator\n          },\n          \"decimals\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"separator\": decimalSeparator\n          },\n          \"template\": \"\",\n          \"source\": \"\",\n          \"parsed\": false\n        },\n        \"zero\": {\n          \"thousands\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"interval\": -1,\n            \"separator\": thousandSeparator\n          },\n          \"decimals\": {\n            \"active\": -1,\n            \"passive\": -1,\n            \"separator\": decimalSeparator\n          },\n          \"template\": \"\",\n          \"source\": \"\",\n          \"parsed\": false\n        }\n      }; // Escape double vertical bars (that mean display one vertical bar)\n\n      format = format.replace(\"||\", $type.PLACEHOLDER2); // Split it up and deal with different formats\n\n      var parts = format.split(\"|\");\n      info.positive.source = parts[0];\n\n      if (typeof parts[2] === \"undefined\") {\n        info.zero = info.positive;\n      } else {\n        info.zero.source = parts[2];\n      }\n\n      if (typeof parts[1] === \"undefined\") {\n        info.negative = info.positive;\n      } else {\n        info.negative.source = parts[1];\n      } // Parse each\n\n\n      $object.each(info, function (_part, item) {\n        // Already parsed\n        if (item.parsed) {\n          return;\n        } // Check cached\n        // TODO\n        // if (typeof this.getCache(item.source) !== \"undefined\") {\n        // \tinfo[part] = this.getCache(item.source);\n        // \treturn;\n        // }\n        // Begin parsing\n\n\n        var partFormat = item.source; // Just \"Number\"?\n\n        if (partFormat.toLowerCase() === \"number\") {\n          partFormat = _this.get(\"numberFormat\", \"#,###.#####\");\n        } // Let TextFormatter split into chunks\n\n\n        var chunks = TextFormatter.chunk(partFormat, true);\n\n        for (var i = 0; i < chunks.length; i++) {\n          var chunk = chunks[i]; // replace back double vertical bar\n\n          chunk.text = chunk.text.replace($type.PLACEHOLDER2, \"|\");\n\n          if (chunk.type === \"value\") {\n            // Parse format\n            // Look for codes\n            var matches = chunk.text.match(/[#0.,]+[ ]?[abespABESP%!]?[abespABESP‰!]?/);\n\n            if (matches) {\n              if (matches === null || matches[0] === \"\") {\n                // no codes here - assume string\n                // nothing to do here\n                item.template += chunk.text;\n              } else {\n                // look for the format modifiers at the end\n                var mods = matches[0].match(/[abespABESP%‰!]{2}|[abespABESP%‰]{1}$/);\n\n                if (mods) {\n                  item.mod = mods[0].toLowerCase();\n                  item.modSpacing = matches[0].match(/[ ]{1}[abespABESP%‰!]{1}$/) ? true : false;\n                } // break the format up\n\n\n                var a = matches[0].split(\".\"); // Deal with thousands\n\n                if (a[0] === \"\") {// No directives for thousands\n                  // Leave default settings (no formatting)\n                } else {\n                  // Counts\n                  item.thousands.active = (a[0].match(/0/g) || []).length;\n                  item.thousands.passive = (a[0].match(/\\#/g) || []).length + item.thousands.active; // Separator interval\n\n                  var b = a[0].split(\",\");\n\n                  if (b.length === 1) {// No thousands separators\n                    // Do nothing\n                  } else {\n                    // Use length fo the last chunk as thousands length\n                    item.thousands.interval = (b.pop() || \"\").length;\n\n                    if (item.thousands.interval === 0) {\n                      item.thousands.interval = -1;\n                    }\n                  }\n                } // Deal with decimals\n\n\n                if (typeof a[1] === \"undefined\") {// No directives for decimals\n                  // Leave at defaults (no formatting)\n                } else {\n                  // Counts\n                  item.decimals.active = (a[1].match(/0/g) || []).length;\n                  item.decimals.passive = (a[1].match(/\\#/g) || []).length + item.decimals.active;\n                } // Add special code to template\n\n\n                item.template += chunk.text.split(matches[0]).join($type.PLACEHOLDER);\n              }\n            }\n          } else {\n            // Quoted string - take it as it is\n            item.template += chunk.text;\n          }\n        } // Apply style formatting\n        //item.template = getTextFormatter().format(item.template, this.outputFormat);\n        // Save cache\n        // TODO\n        //this.setCache(item.source, item);\n        // Mark this as parsed\n\n\n        item.parsed = true;\n      }); // Save cache (the whole thing)\n      // TODO\n      //this.setCache(format, info);\n\n      return info;\n    }\n  });\n  /**\r\n   * Applies parsed format to a numeric value.\r\n   *\r\n   * @param value    Value\r\n   * @param details  Parsed format as returned by parseFormat()\r\n   * @return Formatted number\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"applyFormat\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, details) {\n      // Use absolute values\n      var negative = value < 0;\n      value = Math.abs(value); // Recalculate according to modifier\n\n      var prefix = \"\",\n          suffix = \"\";\n      var mods = details.mod ? details.mod.split(\"\") : [];\n\n      if (mods.indexOf(\"b\") !== -1) {\n        var a_1 = this.applyPrefix(value, this.get(\"bytePrefixes\"), mods.indexOf(\"!\") !== -1);\n        value = a_1[0];\n        prefix = a_1[1];\n        suffix = a_1[2];\n\n        if (details.modSpacing) {\n          suffix = \" \" + suffix;\n        }\n      } else if (mods.indexOf(\"a\") !== -1) {\n        var a_2 = this.applyPrefix(value, value < this.get(\"smallNumberThreshold\") ? this.get(\"smallNumberPrefixes\") : this.get(\"bigNumberPrefixes\"), mods.indexOf(\"!\") !== -1);\n        value = a_2[0];\n        prefix = a_2[1];\n        suffix = a_2[2];\n\n        if (details.modSpacing) {\n          suffix = \" \" + suffix;\n        }\n      } else if (mods.indexOf(\"p\") !== -1) {\n        var ol = Math.min(value.toString().length + 2, 21); //value *= 100;\n\n        value = parseFloat(value.toPrecision(ol));\n        prefix = this._root.language.translate(\"_percentPrefix\");\n        suffix = this._root.language.translate(\"_percentSuffix\");\n\n        if (prefix == \"\" && suffix == \"\") {\n          suffix = \"%\";\n        }\n      } else if (mods.indexOf(\"%\") !== -1) {\n        var ol = Math.min(value.toString().length + 2, 21);\n        value *= 100;\n        value = parseFloat(value.toPrecision(ol));\n        suffix = \"%\";\n      } else if (mods.indexOf(\"‰\") !== -1) {\n        var ol = Math.min(value.toString().length + 3, 21);\n        value *= 1000;\n        value = parseFloat(value.toPrecision(ol));\n        suffix = \"‰\";\n      } // Round to passive\n\n\n      if (mods.indexOf(\"e\") !== -1) {\n        // convert the value to exponential\n        var exp = void 0;\n\n        if (details.decimals.passive >= 0) {\n          exp = value.toExponential(details.decimals.passive).split(\"e\");\n        } else {\n          exp = value.toExponential().split(\"e\");\n        }\n\n        value = Number(exp[0]);\n        suffix = \"e\" + exp[1];\n\n        if (details.modSpacing) {\n          suffix = \" \" + suffix;\n        }\n      } else if (details.decimals.passive === 0) {\n        value = Math.round(value);\n      } else if (details.decimals.passive > 0) {\n        var d = Math.pow(10, details.decimals.passive);\n        value = Math.round(value * d) / d;\n      } // Init return value\n\n\n      var res = \"\"; // Calc integer and decimal parts\n\n      var a = $type.numberToString(value).split(\".\"); // Format integers\n\n      var ints = a[0]; // Pad integers to active length\n\n      if (ints.length < details.thousands.active) {\n        ints = Array(details.thousands.active - ints.length + 1).join(\"0\") + ints;\n      } // Insert thousands separators\n\n\n      if (details.thousands.interval > 0) {\n        var ip = [];\n        var intsr = ints.split(\"\").reverse().join(\"\");\n\n        for (var i = 0, len = ints.length; i <= len; i += details.thousands.interval) {\n          var c = intsr.substr(i, details.thousands.interval).split(\"\").reverse().join(\"\");\n\n          if (c !== \"\") {\n            ip.unshift(c);\n          }\n        }\n\n        ints = ip.join(details.thousands.separator);\n      } // Add integers\n\n\n      res += ints; // Add decimals\n\n      if (a.length === 1) {\n        a.push(\"\");\n      }\n\n      var decs = a[1]; // Fill zeros?\n\n      if (decs.length < details.decimals.active) {\n        decs += Array(details.decimals.active - decs.length + 1).join(\"0\");\n      }\n\n      if (decs !== \"\") {\n        res += details.decimals.separator + decs;\n      } // Can't have empty return value\n\n\n      if (res === \"\") {\n        res = \"0\";\n      } // Add minus sign back\n\n\n      if (value !== 0 && negative && mods.indexOf(\"s\") === -1) {\n        res = \"-\" + res;\n      } // Add suffixes/prefixes\n\n\n      if (prefix) {\n        res = prefix + res;\n      }\n\n      if (suffix) {\n        res += suffix;\n      }\n\n      return res;\n    }\n  });\n  Object.defineProperty(NumberFormatter.prototype, \"applyPrefix\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, prefixes, force) {\n      if (force === void 0) {\n        force = false;\n      }\n\n      var newvalue = value;\n      var prefix = \"\";\n      var suffix = \"\";\n      var applied = false;\n      var k = 1;\n\n      for (var i = 0, len = prefixes.length; i < len; i++) {\n        if (prefixes[i].number <= value) {\n          if (prefixes[i].number === 0) {\n            newvalue = 0;\n          } else {\n            newvalue = value / prefixes[i].number;\n            k = prefixes[i].number;\n          }\n\n          prefix = prefixes[i].prefix;\n          suffix = prefixes[i].suffix;\n          applied = true;\n        }\n      }\n\n      if (!applied && force && prefixes.length && value != 0) {\n        // Prefix was not applied. Use the first prefix.\n        newvalue = value / prefixes[0].number;\n        prefix = prefixes[0].prefix;\n        suffix = prefixes[0].suffix;\n        applied = true;\n      }\n\n      if (applied) {\n        newvalue = parseFloat(newvalue.toPrecision(Math.min(k.toString().length + Math.floor(newvalue).toString().replace(/[^0-9]*/g, \"\").length, 21)));\n      }\n\n      return [newvalue, prefix, suffix];\n    }\n  });\n  /**\r\n   * Replaces brackets with temporary placeholders.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Input text\r\n   * @return Escaped text\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"escape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace(\"||\", $type.PLACEHOLDER2);\n    }\n  });\n  /**\r\n   * Replaces placeholders back to brackets.\r\n   *\r\n   * @ignore Exclude from docs\r\n   * @param text  Escaped text\r\n   * @return Unescaped text\r\n   */\n\n  Object.defineProperty(NumberFormatter.prototype, \"unescape\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (text) {\n      return text.replace($type.PLACEHOLDER2, \"|\");\n    }\n  });\n  return NumberFormatter;\n}(Entity);\n\nexport { NumberFormatter }; //# sourceMappingURL=NumberFormatter.js.map","map":null,"metadata":{},"sourceType":"module"}