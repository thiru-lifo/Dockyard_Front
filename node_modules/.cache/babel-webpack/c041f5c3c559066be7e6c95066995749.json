{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $order from \"../../../core/util/Order\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $object from \"../../../core/util/Object\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $time from \"../../../core/util/Time\";\n/**\r\n * Creates a date axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/date-axis/} for more info\r\n * @important\r\n */\n\nvar DateAxis =\n/** @class */\nfunction (_super) {\n  __extends(DateAxis, _super);\n\n  function DateAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_seriesDataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_baseDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_intervalMax\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_intervalMin\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DateAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\n      _super.prototype._afterNew.call(this);\n\n      this._setBaseInterval(this.get(\"baseInterval\"));\n\n      this.on(\"baseInterval\", function () {\n        _this._setBaseInterval(_this.get(\"baseInterval\"));\n      });\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_setBaseInterval\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (interval) {\n      this.setPrivateRaw(\"baseInterval\", interval);\n      this._baseDuration = $time.getIntervalDuration(interval);\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_fixZoomFactor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var maxZoomFactor = this.get(\"maxZoomFactor\");\n\n      if (maxZoomFactor != null && maxZoomFactor != Infinity) {\n        this.setPrivateRaw(\"maxZoomFactor\", maxZoomFactor);\n      } else {\n        this.setPrivateRaw(\"maxZoomFactor\", Math.round((this.getPrivate(\"max\", 0) - this.getPrivate(\"min\", 0)) / this.baseMainDuration()));\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_groupData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        this._fixZoomFactor();\n\n        var groupInterval = this.getPrivate(\"groupInterval\");\n\n        if (groupInterval) {\n          this._setBaseInterval(groupInterval);\n        } else {\n          this._setBaseInterval(this.get(\"baseInterval\"));\n        }\n\n        if (this.isDirty(\"groupInterval\")) {\n          var groupInterval_1 = this.get(\"groupInterval\");\n\n          if (groupInterval_1) {\n            this.setRaw(\"groupIntervals\", [groupInterval_1]);\n          }\n        }\n\n        if (this.isDirty(\"groupData\")) {\n          if (!this._dataGrouped) {\n            if (this.get(\"groupData\")) {\n              $array.each(this.series, function (series) {\n                _this._groupSeriesData(series);\n              });\n\n              this._handleRangeChange();\n            } else {\n              var baseInterval = this.get(\"baseInterval\");\n              var mainDataSetId_1 = baseInterval.timeUnit + baseInterval.count;\n              $array.each(this.series, function (series) {\n                series.setDataSet(mainDataSetId_1);\n              });\n\n              this._setBaseInterval(baseInterval);\n\n              this.setPrivateRaw(\"groupInterval\", undefined);\n              this.markDirtyExtremes();\n            }\n\n            this._dataGrouped = true;\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_groupSeriesData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series) {\n      var _this = this;\n\n      if (this.get(\"groupData\") && !series.get(\"groupDataDisabled\")) {\n        this._dataGrouped = true; // helps to avoid double grouping\n\n        this._seriesDataGrouped = true; // make array of intervals which will be used;\n\n        var intervals_1 = [];\n        var baseDuration_1 = this.baseMainDuration();\n        var groupIntervals = this.get(\"groupIntervals\");\n\n        if (groupIntervals) {}\n\n        $array.each(groupIntervals, function (interval) {\n          var intervalDuration = $time.getIntervalDuration(interval);\n\n          if (intervalDuration > baseDuration_1) {\n            intervals_1.push(interval);\n          }\n        });\n        series._dataSets = {};\n        var key_1 = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n        var fields_1;\n        var baseAxis = series.get(\"baseAxis\");\n\n        if (series.get(\"xAxis\") === baseAxis) {\n          fields_1 = series._valueYFields;\n        } else if (series.get(\"yAxis\") === baseAxis) {\n          fields_1 = series._valueXFields;\n        }\n\n        var dataItems_1 = series._mainDataItems;\n        var baseInterval = this.get(\"baseInterval\");\n        var mainDataSetId = baseInterval.timeUnit + baseInterval.count;\n        series._dataSets[mainDataSetId] = dataItems_1;\n        var groupCallback_1 = series.get(\"groupDataCallback\");\n        var groupOriginals_1 = series.get(\"groupDataWithOriginals\", false);\n\n        if (groupCallback_1) {\n          groupOriginals_1 = true;\n        }\n\n        $array.each(intervals_1, function (interval) {\n          var previousTime = -Infinity;\n          var dataSetId = interval.timeUnit + interval.count;\n          series._dataSets[dataSetId] = [];\n          var newDataItem;\n          var sum = {};\n          var count = {};\n          var groupFieldValues = {};\n          var workingFields = {};\n          $array.each(fields_1, function (field) {\n            sum[field] = 0;\n            count[field] = 0;\n            groupFieldValues[field] = series.get(field + \"Grouped\");\n            workingFields[field] = field + \"Working\";\n          });\n          var intervalDuration = $time.getDuration(interval.timeUnit);\n          var firstItem = dataItems_1[0];\n          var firstDate;\n\n          if (firstItem) {\n            firstDate = new Date(dataItems_1[0].get(key_1));\n          }\n\n          var prevNewDataItem;\n          $array.each(dataItems_1, function (dataItem) {\n            var time = dataItem.get(key_1);\n            var roundedTime = $time.round(new Date(time), interval.timeUnit, interval.count, _this._root.locale.firstDayOfWeek, _this._root.utc, firstDate, _this._root.timezone).getTime();\n            var dataContext;\n\n            if (previousTime < roundedTime - intervalDuration / 24) {\n              dataContext = $object.copy(dataItem.dataContext);\n              newDataItem = new DataItem(series, dataContext, series._makeDataItem(dataContext));\n              newDataItem.setRaw(key_1, roundedTime);\n\n              series._dataSets[dataSetId].push(newDataItem);\n\n              $array.each(fields_1, function (field) {\n                var value = dataItem.get(field);\n\n                if ($type.isNumber(value)) {\n                  newDataItem.setRaw(field, value);\n                  newDataItem.setRaw(workingFields[field], value);\n                  count[field] = 1;\n                  sum[field] = value;\n                } else {\n                  sum[field] = 0;\n                  count[field] = 0;\n                }\n              });\n\n              if (groupOriginals_1) {\n                newDataItem.set(\"originals\", [dataItem]);\n              }\n\n              if (groupCallback_1 && prevNewDataItem) {\n                groupCallback_1(prevNewDataItem, interval);\n              }\n\n              prevNewDataItem = newDataItem;\n            } else {\n              $array.each(fields_1, function (field) {\n                var groupKey = groupFieldValues[field];\n                var value = dataItem.get(field);\n\n                if (value !== undefined) {\n                  var currentValue = newDataItem.get(field);\n\n                  switch (groupKey) {\n                    case \"close\":\n                      newDataItem.setRaw(field, value);\n                      break;\n\n                    case \"sum\":\n                      newDataItem.setRaw(field, currentValue + value);\n                      break;\n\n                    case \"open\":\n                      break;\n\n                    case \"low\":\n                      if (value < currentValue) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n\n                    case \"high\":\n                      if (value > currentValue) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n\n                    case \"average\":\n                      count[field]++;\n                      sum[field] += value;\n                      var average = sum[field] / count[field];\n                      newDataItem.setRaw(field, average);\n                      break;\n\n                    case \"extreme\":\n                      if (Math.abs(value) > Math.abs(currentValue)) {\n                        newDataItem.setRaw(field, value);\n                      }\n\n                      break;\n                  }\n\n                  newDataItem.setRaw(workingFields[field], newDataItem.get(field));\n                  var dataContext_1 = $object.copy(dataItem.dataContext);\n                  dataContext_1[key_1] = roundedTime;\n                  newDataItem.dataContext = dataContext_1;\n                }\n              });\n\n              if (groupOriginals_1) {\n                newDataItem.get(\"originals\").push(dataItem);\n              }\n            }\n\n            previousTime = roundedTime;\n          });\n\n          if (groupCallback_1 && prevNewDataItem) {\n            groupCallback_1(prevNewDataItem, interval);\n          }\n        });\n\n        if (series._dataSetId) {\n          series.setDataSet(series._dataSetId);\n        }\n\n        this.markDirtySize();\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_clearDirty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._clearDirty.call(this);\n\n      this._groupingCalculated = false;\n      this._dataGrouped = false;\n    }\n  });\n  /**\r\n   * Returns a time interval axis would group data to for a specified duration.\r\n   *\r\n   * @since 5.2.1\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getGroupInterval\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (duration) {\n      var baseInterval = this.get(\"baseInterval\");\n      var groupInterval = $time.chooseInterval(0, duration, this.get(\"groupCount\", Infinity), this.get(\"groupIntervals\"));\n\n      if ($time.getIntervalDuration(groupInterval) < $time.getIntervalDuration(baseInterval)) {\n        groupInterval = __assign({}, baseInterval);\n      }\n\n      return groupInterval;\n    }\n  });\n  /**\r\n   * Return `max` of a specified time interval.\r\n   *\r\n   * Will work only if the axis was grouped to this interval at least once.\r\n   *\r\n   * @since 5.2.1\r\n   * @param   interval  Interval\r\n   * @return            Max\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getIntervalMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (interval) {\n      return this._intervalMax[interval.timeUnit + interval.count];\n    }\n  });\n  /**\r\n   * Return `min` of a specified time interval.\r\n   *\r\n   * Will work only if the axis was grouped to this interval at least once.\r\n   *\r\n   * @since 5.2.1\r\n   * @param   interval  Interval\r\n   * @return            Min\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getIntervalMin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (interval) {\n      return this._intervalMin[interval.timeUnit + interval.count];\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_handleRangeChange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._handleRangeChange.call(this);\n\n      var baseInterval = this.get(\"baseInterval\");\n      var min = this.getIntervalMin(baseInterval);\n      var max = this.getIntervalMax(baseInterval);\n      var selectionMin = min + (max - min) * this.get(\"start\", 0);\n      var selectionMax = min + (max - min) * this.get(\"end\", 1); // this caused non stop switching 4186#\n      //let selectionMin = Math.round(this.getPrivate(\"selectionMin\")! as number);\n      //let selectionMax = Math.round(this.getPrivate(\"selectionMax\")! as number);\n\n      if ($type.isNumber(selectionMin) && $type.isNumber(selectionMax)) {\n        if (this.get(\"endLocation\") == 0) {\n          selectionMax += 1;\n        }\n\n        if (this.get(\"groupData\") && !this._groupingCalculated) {\n          this._groupingCalculated = true;\n          var modifiedDifference = selectionMax - selectionMin + (this.get(\"startLocation\", 0) + (1 - this.get(\"endLocation\", 1)) * this.baseDuration());\n          var groupInterval = this.get(\"groupInterval\");\n\n          if (!groupInterval) {\n            groupInterval = this.getGroupInterval(modifiedDifference);\n          }\n\n          var current = this.getPrivate(\"groupInterval\");\n\n          if (groupInterval && (!current || current.timeUnit !== groupInterval.timeUnit || current.count !== groupInterval.count || this._seriesDataGrouped)) {\n            this._seriesDataGrouped = false;\n            this.setPrivateRaw(\"groupInterval\", groupInterval);\n\n            this._setBaseInterval(groupInterval);\n\n            var newId_1 = groupInterval.timeUnit + groupInterval.count;\n            $array.each(this.series, function (series) {\n              if (series.get(\"baseAxis\") === _this) {\n                series.setDataSet(newId_1);\n              }\n            });\n            this.markDirtyExtremes();\n\n            this._root.events.once(\"frameended\", function () {\n              _this._root.events.once(\"frameended\", function () {\n                var type = \"groupintervalchanged\";\n\n                if (_this.events.isEnabled(type)) {\n                  _this.events.dispatch(type, {\n                    type: type,\n                    target: _this\n                  });\n                }\n              });\n            });\n          }\n        }\n\n        selectionMin = Math.round(this.getPrivate(\"selectionMin\"));\n        selectionMax = Math.round(this.getPrivate(\"selectionMax\"));\n        $array.each(this.series, function (series) {\n          if (series.get(\"baseAxis\") === _this) {\n            var fieldName_1 = _this.getPrivate(\"name\") + _this.get(\"renderer\").getPrivate(\"letter\");\n\n            var start = $array.getSortedIndex(series.dataItems, function (dataItem) {\n              return $order.compare(dataItem.get(fieldName_1), selectionMin);\n            });\n            var startIndex = start.index;\n\n            if (startIndex > 0) {\n              startIndex -= 1;\n            }\n\n            selectionMax += _this.baseDuration() * (1 - _this.get(\"endLocation\", 1));\n            var end = $array.getSortedIndex(series.dataItems, function (dataItem) {\n              return $order.compare(dataItem.get(fieldName_1), selectionMax);\n            });\n            var endIndex = end.index;\n            var endIndex2 = endIndex;\n\n            if (endIndex2 > 0) {\n              endIndex2--;\n            }\n\n            var firstDataItem = series.dataItems[startIndex];\n            var lastDataItem = series.dataItems[endIndex2];\n            var lastDate = void 0;\n            var firstDate = void 0;\n\n            if (firstDataItem) {\n              firstDate = firstDataItem.get(fieldName_1);\n            }\n\n            if (lastDataItem) {\n              lastDate = lastDataItem.get(fieldName_1);\n            }\n\n            var outOfSelection = false;\n\n            if (lastDate != null && firstDate != null) {\n              if (lastDate < selectionMin || firstDate > selectionMax) {\n                outOfSelection = true;\n              }\n            }\n\n            series.setPrivate(\"outOfSelection\", outOfSelection);\n            series.setPrivate(\"startIndex\", startIndex);\n            series.setPrivate(\"endIndex\", endIndex);\n          }\n        });\n      }\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, _strictMode) {\n      return {\n        min: min,\n        max: max,\n        step: (max - min) / gridCount\n      };\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"intervalDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._intervalDuration;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_saveMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max) {\n      var groupInterval = this.getPrivate(\"groupInterval\");\n\n      if (!groupInterval) {\n        groupInterval = this.get(\"baseInterval\");\n      }\n\n      var id = groupInterval.timeUnit + groupInterval.count;\n      this._intervalMin[id] = min;\n      this._intervalMax[id] = max;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        var selectionMin = Math.round(this.getPrivate(\"selectionMin\"));\n        var selectionMax = Math.round(this.getPrivate(\"selectionMax\"));\n        var renderer = this.get(\"renderer\");\n        var baseInterval = this.getPrivate(\"baseInterval\");\n        var value = selectionMin;\n        var i = 0;\n        var intervals = this.get(\"gridIntervals\");\n        var gridInterval = $time.chooseInterval(0, selectionMax - selectionMin, renderer.gridCount(), intervals);\n\n        if ($time.getIntervalDuration(gridInterval) < this.baseDuration()) {\n          gridInterval = __assign({}, baseInterval);\n        }\n\n        var intervalDuration = $time.getIntervalDuration(gridInterval);\n        this._intervalDuration = intervalDuration;\n        var nextGridUnit = $time.getNextUnit(gridInterval.timeUnit);\n        value = $time.round(new Date(selectionMin - intervalDuration), gridInterval.timeUnit, gridInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, new Date(min), this._root.timezone).getTime();\n        var previousValue = value - intervalDuration;\n        var format = void 0;\n        var formats = this.get(\"dateFormats\");\n        this.setPrivateRaw(\"gridInterval\", gridInterval);\n\n        while (value < selectionMax + intervalDuration) {\n          var dataItem = void 0;\n\n          if (this.dataItems.length < i + 1) {\n            dataItem = new DataItem(this, undefined, {});\n\n            this._dataItems.push(dataItem);\n\n            this.processDataItem(dataItem);\n          } else {\n            dataItem = this.dataItems[i];\n          }\n\n          this._createAssets(dataItem, []);\n\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n\n          dataItem.setRaw(\"value\", value);\n          var endValue = value + $time.getDuration(gridInterval.timeUnit, gridInterval.count * 1.05);\n          endValue = $time.round(new Date(endValue), gridInterval.timeUnit, 1, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n          dataItem.setRaw(\"endValue\", endValue);\n          var date = new Date(value);\n          format = formats[gridInterval.timeUnit];\n\n          if (nextGridUnit && this.get(\"markUnitChange\") && $type.isNumber(previousValue)) {\n            if (gridInterval.timeUnit != \"year\") {\n              if ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {\n                format = this.get(\"periodChangeDateFormats\")[gridInterval.timeUnit];\n              }\n            }\n          }\n\n          var label = dataItem.get(\"label\");\n\n          if (label) {\n            label.set(\"text\", this._root.dateFormatter.format(date, format));\n          }\n\n          this._prepareDataItem(dataItem, gridInterval.count);\n\n          previousValue = value;\n          value = endValue;\n\n          if (value == previousValue) {\n            break;\n          }\n\n          i++;\n        }\n\n        for (var j = i; j < this.dataItems.length; j++) {\n          this.dataItems[j].hide();\n        }\n\n        $array.each(this.series, function (series) {\n          if (series.inited) {\n            series._markDirtyAxes();\n          }\n        });\n      }\n\n      this._updateGhost();\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_getDelta\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._deltaMinMax = this.baseDuration() / 2;\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_fixMin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min) {\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      var startTime = $time.round(new Date(min), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n      var endTime = startTime + $time.getDuration(baseInterval.timeUnit, baseInterval.count * 1.05);\n      endTime = $time.round(new Date(endTime), baseInterval.timeUnit, 1, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n      return startTime + (endTime - startTime) * this.get(\"startLocation\", 0);\n    }\n  });\n  /* goes up to the year\r\n  protected _getFormat(timeUnit: TimeUnit, value: number, previousValue: number) {\r\n      const formats = this.get(\"dateFormats\")!;\r\n      let format = formats[timeUnit];\r\n        if (this.get(\"markUnitChange\")) {\r\n          let nextGridUnit = $time.getNextUnit(timeUnit);\r\n            while (nextGridUnit != undefined) {\r\n                if (nextGridUnit) {\r\n                  if (timeUnit != \"year\") {\r\n                      if ($time.checkChange(value, previousValue, nextGridUnit, this._root.utc, this._root.timezone)) {\r\n                          format = this.get(\"periodChangeDateFormats\")![timeUnit];\r\n                          timeUnit = nextGridUnit;\r\n                          nextGridUnit = $time.getNextUnit(nextGridUnit);\r\n                      }\r\n                      else {\r\n                          nextGridUnit = undefined;\r\n                      }\r\n                  }\r\n                  else {\r\n                      nextGridUnit = undefined;\r\n                  }\r\n              }\r\n          }\r\n      }\r\n      return format;\r\n  }\r\n  */\n\n  Object.defineProperty(DateAxis.prototype, \"_fixMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (max) {\n      var baseInterval = this.getPrivate(\"baseInterval\");\n      var startTime = $time.round(new Date(max), baseInterval.timeUnit, baseInterval.count, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n      var endTime = startTime + $time.getDuration(baseInterval.timeUnit, baseInterval.count * 1.05);\n      endTime = $time.round(new Date(endTime), baseInterval.timeUnit, 1, this._root.locale.firstDayOfWeek, this._root.utc, undefined, this._root.timezone).getTime();\n      return startTime + (endTime - startTime) * this.get(\"endLocation\", 1);\n    }\n  });\n  Object.defineProperty(DateAxis.prototype, \"_updateDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_date) {}\n  });\n  /**\r\n   * Returns a duration of currently active `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"baseDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._baseDuration; //return $time.getIntervalDuration(this.getPrivate(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * Returns a duration of user-defined `baseInterval` in milliseconds.\r\n   *\r\n   * @return Duration\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"baseMainDuration\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return $time.getIntervalDuration(this.get(\"baseInterval\"));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"processSeriesDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, fields) {\n      var _this = this;\n\n      var baseInterval = this.getPrivate(\"baseInterval\");\n\n      if (!dataItem.open) {\n        dataItem.open = {};\n      }\n\n      if (!dataItem.close) {\n        dataItem.close = {};\n      }\n\n      $array.each(fields, function (field) {\n        var value = dataItem.get(field);\n\n        if ($type.isNumber(value)) {\n          var startTime = dataItem.open[field];\n          var endTime = dataItem.close[field]; // this is done to save cpu, as rounding is quite expensive, especially with timezone set. \n          // if value is between prev start and end, it means it didn't change, all is fine.\n\n          if (value >= startTime && value <= endTime) {} else {\n            startTime = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, _this._root.locale.firstDayOfWeek, _this._root.utc, undefined, _this._root.timezone).getTime();\n            endTime = startTime + $time.getDuration(baseInterval.timeUnit, baseInterval.count * 1.05);\n            endTime = $time.round(new Date(endTime), baseInterval.timeUnit, 1, _this._root.locale.firstDayOfWeek, _this._root.utc, undefined, _this._root.timezone).getTime();\n            dataItem.open[field] = startTime;\n            dataItem.close[field] = endTime;\n          }\n\n          _this._updateDates(startTime);\n        }\n      });\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemPositionX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      var openValue;\n      var closeValue;\n\n      if (dataItem.open && dataItem.close) {\n        openValue = dataItem.open[field];\n        closeValue = dataItem.close[field];\n      } else {\n        openValue = dataItem.get(field);\n        closeValue = openValue;\n      }\n\n      var value = openValue + (closeValue - openValue) * cellLocation;\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemCoordinateX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemPositionY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      var openValue;\n      var closeValue;\n\n      if (dataItem.open && dataItem.close) {\n        openValue = dataItem.open[field];\n        closeValue = dataItem.close[field];\n      } else {\n        openValue = dataItem.get(field);\n        closeValue = openValue;\n      }\n\n      var value = openValue + (closeValue - openValue) * cellLocation;\n      value = this._baseValue + (value - this._baseValue) * axisLocation;\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getDataItemCoordinateY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"roundAxisPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position, location) {\n      var value = this.positionToValue(position);\n      value = value - (location - 0.5) * this.baseDuration();\n      var baseInterval = this.getPrivate(\"baseInterval\");\n\n      if (!$type.isNaN(value)) {\n        var timeZone = this._root.timezone;\n        var firstDayOfWeek = this._root.locale.firstDayOfWeek;\n        value = $time.round(new Date(value), baseInterval.timeUnit, baseInterval.count, firstDayOfWeek, this._root.utc, new Date(this.getPrivate(\"min\", 0)), timeZone).getTime();\n        var duration = $time.getDateIntervalDuration(baseInterval, new Date(value), firstDayOfWeek, this._root.utc, this._root.timezone);\n\n        if (timeZone) {\n          value = $time.round(new Date(value + this.baseDuration() * 0.05), baseInterval.timeUnit, baseInterval.count, firstDayOfWeek, this._root.utc, new Date(this.getPrivate(\"min\", 0)), timeZone).getTime();\n          var newValue = value + duration * location;\n          duration = $time.getDateIntervalDuration(baseInterval, new Date(newValue), firstDayOfWeek, this._root.utc, this._root.timezone);\n        }\n\n        return this.valueToPosition(value + duration * location);\n      }\n\n      return NaN;\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      //@todo number formatter + tag\n      if (this.getPrivate(\"min\") != null) {\n        var format = this.get(\"tooltipDateFormats\")[this.getPrivate(\"baseInterval\").timeUnit];\n        var value = this.positionToValue(position);\n        var date = new Date(value);\n        var baseInterval = this.getPrivate(\"baseInterval\");\n        var duration = $time.getDateIntervalDuration(baseInterval, date, this._root.locale.firstDayOfWeek, this._root.utc, this._root.timezone);\n        return this._root.dateFormatter.format(new Date(value + this.get(\"tooltipIntervalOffset\", -this.get(\"tooltipLocation\", 0.5)) * duration), this.get(\"tooltipDateFormat\", format));\n      }\n\n      return \"\";\n    }\n  });\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getSeriesItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series, position, location) {\n      var fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n      var value = this.positionToValue(position);\n\n      if (location == null) {\n        location = 0.5;\n      }\n\n      value = value - (location - 0.5) * this.baseDuration();\n      var result = $array.getSortedIndex(series.dataItems, function (dataItem) {\n        var diValue = 0;\n\n        if (dataItem.open) {\n          diValue = dataItem.open[fieldName];\n        }\n\n        return $order.compare(diValue, value);\n      });\n\n      if (series.get(\"snapTooltip\")) {\n        var first = series.dataItems[result.index - 1];\n        var second = series.dataItems[result.index];\n\n        if (first && second) {\n          if (first.open && second.close) {\n            var open_1 = first.open[fieldName];\n            var close_1 = second.close[fieldName];\n\n            if (Math.abs(value - open_1) > Math.abs(value - close_1)) {\n              return second;\n            }\n          }\n        }\n\n        return first;\n      } else {\n        // @todo check if is in range\n        var dataItem = series.dataItems[result.index - 1];\n\n        if (dataItem) {\n          if (dataItem.open && dataItem.close) {\n            var open_2 = dataItem.open[fieldName];\n            var close_2 = dataItem.close[fieldName];\n\n            if (value >= open_2 && value <= close_2) {\n              return dataItem;\n            }\n          }\n        }\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"shouldGap\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, nextItem, autoGapCount, fieldName) {\n      var value1 = dataItem.get(fieldName);\n      var value2 = nextItem.get(fieldName);\n\n      if (value2 - value1 > this.baseDuration() * autoGapCount) {\n        return true;\n      }\n\n      return false;\n    }\n  });\n  /**\r\n   * Zooms the axis to specific `start` and `end` dates.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start Date\r\n   * @param  end       End Date\r\n   * @param  duration  Duration in milliseconds\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"zoomToDates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (start, end, duration) {\n      this.zoomToValues(start.getTime(), end.getTime(), duration);\n    }\n  });\n  /**\r\n   * Returns a `Date` object corresponding to specific position within plot\r\n   * area.\r\n   *\r\n   * @param   position  Pposition\r\n   * @return            Date\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"positionToDate\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      return new Date(this.positionToValue(position));\n    }\n  });\n  /**\r\n   * Returns a relative position within plot area that corresponds to specific\r\n   * date.\r\n   *\r\n   * @param   date  Date\r\n   * @return        Position\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"dateToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (date) {\n      return this.valueToPosition(date.getTime());\n    }\n  });\n  /**\r\n   * Returns position span between start and end of a single cell in axis.\r\n   *\r\n   * @since 5.2.30\r\n   * @return Position\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(DateAxis.prototype, \"getCellWidthPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var max = this.getPrivate(\"selectionMax\", this.getPrivate(\"max\"));\n      var min = this.getPrivate(\"selectionMin\", this.getPrivate(\"min\"));\n\n      if ($type.isNumber(max) && $type.isNumber(min)) {\n        return this.baseDuration() / (max - min);\n      }\n\n      return 0.05;\n    }\n  });\n  Object.defineProperty(DateAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"DateAxis\"\n  });\n  Object.defineProperty(DateAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: ValueAxis.classNames.concat([DateAxis.className])\n  });\n  return DateAxis;\n}(ValueAxis);\n\nexport { DateAxis }; //# sourceMappingURL=DateAxis.js.map","map":null,"metadata":{},"sourceType":"module"}