{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { Entity } from \"../util/Entity\";\nimport { Template } from \"../util/Template\";\nimport { Percent } from \"../util/Percent\";\nimport { EventDispatcher } from \"../util/EventDispatcher\";\nimport { MultiDisposer, CounterDisposer } from \"../util/Disposer\";\nimport { waitForAnimations } from \"../util/Animation\";\nimport * as $utils from \"../util/Utils\";\nimport * as $array from \"../util/Array\";\nimport * as $type from \"../util/Type\";\nimport * as $object from \"../util/Object\";\nimport * as $math from \"../util/Math\"; //import { populateString } from \"../util/PopulateString\";\n\n/**\r\n * An [[EventDispatcher]] for [[Sprite]].\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n */\n\nvar SpriteEventDispatcher =\n/** @class */\nfunction (_super) {\n  __extends(SpriteEventDispatcher, _super);\n\n  function SpriteEventDispatcher(sprite) {\n    var _this = _super.call(this) || this;\n\n    Object.defineProperty(_this, \"_sprite\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_rendererDisposers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_dispatchParents\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    _this._sprite = sprite;\n    return _this;\n  }\n\n  Object.defineProperty(SpriteEventDispatcher.prototype, \"_makePointerEvent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key, event) {\n      return {\n        type: key,\n        originalEvent: event.event,\n        point: event.point,\n        simulated: event.simulated,\n        native: event.native,\n        target: this._sprite\n      };\n    }\n  });\n  Object.defineProperty(SpriteEventDispatcher.prototype, \"_onRenderer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key, dispatch) {\n      var _this = this; // TODO: is this OK? it'd be good not to require to set this on each individual element\n\n\n      this._sprite.set(\"interactive\", true);\n\n      this._sprite._display.interactive = true;\n      var events = this._rendererDisposers[key];\n\n      if (events === undefined) {\n        var disposer_1 = this._sprite._display.on(key, function (e) {\n          dispatch.call(_this, e);\n        });\n\n        events = this._rendererDisposers[key] = new CounterDisposer(function () {\n          delete _this._rendererDisposers[key];\n          disposer_1.dispose();\n        });\n      }\n\n      return events.increment();\n    }\n  });\n  Object.defineProperty(SpriteEventDispatcher.prototype, \"_on\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (once, type, callback, context, shouldClone, dispatch) {\n      var info = _super.prototype._on.call(this, once, type, callback, context, shouldClone, dispatch);\n\n      var rendererEvent = SpriteEventDispatcher.RENDERER_EVENTS[type];\n\n      if (rendererEvent !== undefined) {\n        info.disposer = new MultiDisposer([info.disposer, this._onRenderer(type, rendererEvent)]);\n      }\n\n      return info;\n    }\n  });\n  /**\r\n   * Will stop any bubbling up of the event to element's parents.\r\n   *\r\n   * Should be called in an event handler, e.g.:\r\n   *\r\n   * ```TypeScript\r\n   * element.events.on(\"pointerdown\", function(ev) {\r\n   *   // Do something here and prevent from \"pointerdown\" bubbling up\r\n   *   // ...\r\n   *   ev.target.events.stopParentDispatch();\r\n   * });\r\n   * ```\r\n   * ```JavaScript\r\n   * element.events.on(\"pointerdown\", function(ev) {\r\n   *   // Do something here and prevent from \"pointerdown\" bubbling up\r\n   *   // ...\r\n   *   ev.target.events.stopParentDispatch();\r\n   * });\r\n   * ```\r\n   */\n\n  Object.defineProperty(SpriteEventDispatcher.prototype, \"stopParentDispatch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._dispatchParents = false;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(SpriteEventDispatcher.prototype, \"dispatchParents\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, event) {\n      var old = this._dispatchParents;\n      this._dispatchParents = true;\n\n      try {\n        this.dispatch(type, event);\n\n        if (this._dispatchParents && this._sprite.parent) {\n          this._sprite.parent.events.dispatchParents(type, event);\n        }\n      } finally {\n        this._dispatchParents = old;\n      }\n    }\n  });\n  Object.defineProperty(SpriteEventDispatcher, \"RENDERER_EVENTS\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n      \"click\": function (event) {\n        if (this.isEnabled(\"click\") && !this._sprite.isDragging() && this._sprite._hasDown() && !this._sprite._hasMoved(this._makePointerEvent(\"click\", event))) {\n          this.dispatch(\"click\", this._makePointerEvent(\"click\", event));\n        }\n      },\n      \"rightclick\": function (event) {\n        if (this.isEnabled(\"rightclick\")) {\n          this.dispatch(\"rightclick\", this._makePointerEvent(\"rightclick\", event));\n        }\n      },\n      \"middleclick\": function (event) {\n        if (this.isEnabled(\"middleclick\")) {\n          this.dispatch(\"middleclick\", this._makePointerEvent(\"middleclick\", event));\n        }\n      },\n      \"dblclick\": function (event) {\n        this.dispatchParents(\"dblclick\", this._makePointerEvent(\"dblclick\", event));\n      },\n      \"pointerover\": function (event) {\n        if (this.isEnabled(\"pointerover\")) {\n          this.dispatch(\"pointerover\", this._makePointerEvent(\"pointerover\", event));\n        }\n      },\n      \"pointerout\": function (event) {\n        if (this.isEnabled(\"pointerout\")) {\n          this.dispatch(\"pointerout\", this._makePointerEvent(\"pointerout\", event));\n        }\n      },\n      \"pointerdown\": function (event) {\n        this.dispatchParents(\"pointerdown\", this._makePointerEvent(\"pointerdown\", event));\n      },\n      \"pointerup\": function (event) {\n        if (this.isEnabled(\"pointerup\")) {\n          this.dispatch(\"pointerup\", this._makePointerEvent(\"pointerup\", event));\n        }\n      },\n      \"globalpointerup\": function (event) {\n        if (this.isEnabled(\"globalpointerup\")) {\n          this.dispatch(\"globalpointerup\", this._makePointerEvent(\"globalpointerup\", event));\n        }\n      },\n      \"globalpointermove\": function (event) {\n        if (this.isEnabled(\"globalpointermove\")) {\n          this.dispatch(\"globalpointermove\", this._makePointerEvent(\"globalpointermove\", event));\n        }\n      },\n      \"wheel\": function (event) {\n        this.dispatchParents(\"wheel\", {\n          type: \"wheel\",\n          target: this._sprite,\n          originalEvent: event.event,\n          point: event.point\n        });\n      }\n    }\n  });\n  return SpriteEventDispatcher;\n}(EventDispatcher);\n/**\r\n * A base class for all visual elements.\r\n *\r\n * @important\r\n */\n\n\nvar Sprite =\n/** @class */\nfunction (_super) {\n  __extends(Sprite, _super);\n\n  function Sprite() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_adjustedLocalBounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n    });\n    Object.defineProperty(_this, \"_localBounds\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }\n    });\n    Object.defineProperty(_this, \"_parent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_dataItem\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_templateField\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_sizeDirty\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    }); // Will be true only when dragging\n\n    Object.defineProperty(_this, \"_isDragging\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    }); // The event when the dragging starts\n\n    Object.defineProperty(_this, \"_dragEvent\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    }); // The position when dragging starts\n\n    Object.defineProperty(_this, \"_dragPoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_isHidden\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_isShowing\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_isHiding\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_isDown\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_downPoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_downPoints\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(_this, \"_toggleDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_dragDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_tooltipDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_hoverDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_focusDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_tooltipMoveDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_tooltipPointerDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_statesHandled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    return _this;\n  }\n\n  Object.defineProperty(Sprite.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.setPrivateRaw(\"visible\", true);\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_markDirtyKey\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key) {\n      _super.prototype._markDirtyKey.call(this, key);\n\n      if (key == \"x\" || key == \"y\" || key == \"dx\" || key == \"dy\") {\n        this.markDirtyBounds();\n\n        this._addPercentagePositionChildren();\n\n        this.markDirtyPosition();\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_markDirtyPrivateKey\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (key) {\n      _super.prototype._markDirtyPrivateKey.call(this, key);\n\n      if (key == \"x\" || key == \"y\") {\n        this.markDirtyPosition();\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_removeTemplateField\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this._templateField) {\n        this._templateField._removeObjectTemplate(this);\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_createEvents\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return new SpriteEventDispatcher(this);\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_processTemplateField\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var template;\n      var field = this.get(\"templateField\");\n\n      if (field) {\n        var dataItem = this.dataItem;\n\n        if (dataItem) {\n          var context = dataItem.dataContext;\n\n          if (context) {\n            template = context[field];\n\n            if (!(template instanceof Template) && template) {\n              template = Template.new(template);\n            }\n          }\n        }\n      }\n\n      if (this._templateField !== template) {\n        this._removeTemplateField();\n\n        this._templateField = template;\n\n        if (template) {\n          template._setObjectTemplate(this);\n        }\n\n        this._applyTemplates();\n      }\n    }\n  }); // TODO change this to run before the element is added to the parent, so that way\n  //      it doesn't need to apply the themes twice\n\n  Object.defineProperty(Sprite.prototype, \"_setDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem) {\n      var oldDataItem = this._dataItem;\n      this._dataItem = dataItem;\n\n      this._processTemplateField();\n\n      var eventType = \"dataitemchanged\";\n\n      if (this.events.isEnabled(eventType)) {\n        this.events.dispatch(eventType, {\n          type: eventType,\n          target: this,\n          oldDataItem: oldDataItem,\n          newDataItem: dataItem\n        });\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"dataItem\", {\n    /**\r\n     * @return DataItem\r\n     */\n    get: function () {\n      if (this._dataItem) {\n        return this._dataItem;\n      } else {\n        var parent_1 = this._parent;\n\n        while (parent_1) {\n          if (parent_1._dataItem) {\n            return parent_1._dataItem;\n          } else {\n            parent_1 = parent_1._parent;\n          }\n        }\n      }\n    },\n\n    /**\r\n     * A [[DataItem]] used for this element.\r\n     *\r\n     * NOTE: data item is being assigned automatically in most cases where it\r\n     * matters. Use this accessor to set data item only if you know what you're\r\n     * doing.\r\n     *\r\n     * @param  value  Data item\r\n     */\n    set: function (value) {\n      this._setDataItem(value);\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"_addPercentageSizeChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var parent = this.parent;\n\n      if (parent) {\n        if (this.get(\"width\") instanceof Percent || this.get(\"height\") instanceof Percent) {\n          $array.pushOne(parent._percentageSizeChildren, this);\n        } else {\n          $array.removeFirst(parent._percentageSizeChildren, this);\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_addPercentagePositionChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var parent = this.parent;\n\n      if (parent) {\n        if (this.get(\"x\") instanceof Percent || this.get(\"y\") instanceof Percent) {\n          $array.pushOne(parent._percentagePositionChildren, this);\n        } else {\n          $array.removeFirst(parent._percentagePositionChildren, this);\n        }\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"markDirtyPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._root._addDirtyPosition(this);\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"updatePivotPoint\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var bounds = this._localBounds;\n\n      if (bounds) {\n        var centerX = this.get(\"centerX\");\n\n        if (centerX != null) {\n          this._display.pivot.x = bounds.left + $utils.relativeToValue(centerX, bounds.right - bounds.left);\n        }\n\n        var centerY = this.get(\"centerY\");\n\n        if (centerY != null) {\n          this._display.pivot.y = bounds.top + $utils.relativeToValue(centerY, bounds.bottom - bounds.top);\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._beforeChanged.call(this); // handling states in beforeChanged, otherwise states is not applied without animated theme\n\n\n      this._handleStates();\n\n      if (this.isDirty(\"tooltip\")) {\n        var previous = this._prevSettings.tooltip;\n\n        if (previous) {\n          previous.dispose();\n        }\n      }\n\n      if (this.isDirty(\"layer\") || this.isDirty(\"layerMargin\")) {\n        this._display.setLayer(this.get(\"layer\"), this.get(\"layerMargin\"));\n\n        this.markDirtyLayer();\n      }\n\n      if (this.isDirty(\"tooltipPosition\")) {\n        var tooltipMoveDp = this._tooltipMoveDp;\n\n        if (tooltipMoveDp) {\n          tooltipMoveDp.dispose();\n          this._tooltipMoveDp = undefined;\n        }\n\n        var tooltipPointerDp = this._tooltipPointerDp;\n\n        if (tooltipPointerDp) {\n          tooltipPointerDp.dispose();\n          this._tooltipPointerDp = undefined;\n        }\n\n        if (this.get(\"tooltipPosition\") == \"pointer\") {\n          this._tooltipPointerDp = new MultiDisposer([this.events.on(\"pointerover\", function () {\n            _this._tooltipMoveDp = _this.events.on(\"globalpointermove\", function (e) {\n              _this.showTooltip(e.point);\n            });\n          }), this.events.on(\"pointerout\", function () {\n            var tooltipMoveDp = _this._tooltipMoveDp;\n\n            if (tooltipMoveDp) {\n              tooltipMoveDp.dispose();\n              _this._tooltipMoveDp = undefined;\n            }\n          })]);\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_handleStates\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._statesHandled) {\n        if (this.isDirty(\"active\")) {\n          if (this.get(\"active\")) {\n            this.states.applyAnimate(\"active\");\n            this.set(\"ariaChecked\", true);\n          } else {\n            if (!this.isHidden()) {\n              this.states.applyAnimate(\"default\");\n            }\n\n            this.set(\"ariaChecked\", false);\n          }\n\n          this.markDirtyAccessibility();\n        }\n\n        if (this.isDirty(\"disabled\")) {\n          if (this.get(\"disabled\")) {\n            this.states.applyAnimate(\"disabled\");\n            this.set(\"ariaChecked\", false);\n          } else {\n            if (!this.isHidden()) {\n              this.states.applyAnimate(\"default\");\n            }\n\n            this.set(\"ariaChecked\", true);\n          }\n\n          this.markDirtyAccessibility();\n        }\n\n        this._statesHandled = true;\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_changed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._changed.call(this);\n\n      var display = this._display;\n      var events = this.events;\n\n      if (this.isDirty(\"draggable\")) {\n        var draggable = this.get(\"draggable\");\n\n        if (draggable) {\n          this.set(\"interactive\", true);\n          this._dragDp = new MultiDisposer([events.on(\"pointerdown\", function (ev) {\n            _this.dragStart(ev);\n          }), events.on(\"globalpointermove\", function (ev) {\n            _this.dragMove(ev);\n          }), events.on(\"globalpointerup\", function (ev) {\n            _this.dragStop(ev);\n          })]);\n        } else {\n          if (this._dragDp) {\n            this._dragDp.dispose();\n\n            this._dragDp = undefined;\n          }\n        }\n\n        display.cancelTouch = draggable ? true : false;\n      }\n\n      if (this.isDirty(\"tooltipText\") || this.isDirty(\"tooltipHTML\") || this.isDirty(\"showTooltipOn\")) {\n        var tooltipText = this.get(\"tooltipText\");\n        var tooltipHTML = this.get(\"tooltipHTML\");\n        var showTooltipOn = this.get(\"showTooltipOn\", \"hover\");\n\n        if (this._tooltipDp) {\n          this._tooltipDp.dispose();\n\n          this._tooltipDp = undefined;\n        }\n\n        if (tooltipText || tooltipHTML) {\n          if (showTooltipOn == \"click\") {\n            this._tooltipDp = new MultiDisposer([events.on(\"click\", function () {\n              _this.setTimeout(function () {\n                return _this.showTooltip();\n              }, 10);\n            }), $utils.addEventListener(document, \"click\", function (_ev) {\n              _this.hideTooltip();\n            })]);\n          } else if (showTooltipOn == \"always\") {// nothing\n          } else {\n            this._tooltipDp = new MultiDisposer([events.on(\"pointerover\", function () {\n              _this.showTooltip();\n            }), events.on(\"pointerout\", function () {\n              _this.hideTooltip();\n            })]);\n          }\n        }\n      }\n\n      if (this.isDirty(\"toggleKey\")) {\n        var toggleKey_1 = this.get(\"toggleKey\");\n\n        if (toggleKey_1 && toggleKey_1 != \"none\") {\n          this._toggleDp = events.on(\"click\", function () {\n            if (!_this._isDragging) {\n              _this.set(toggleKey_1, !_this.get(toggleKey_1));\n            }\n          });\n        } else {\n          if (this._toggleDp) {\n            this._toggleDp.dispose();\n\n            this._toggleDp = undefined;\n          }\n        }\n      }\n\n      if (this.isDirty(\"opacity\")) {\n        display.alpha = Math.max(0, this.get(\"opacity\", 1));\n      }\n\n      if (this.isDirty(\"rotation\")) {\n        this.markDirtyBounds();\n        display.angle = this.get(\"rotation\", 0);\n      }\n\n      if (this.isDirty(\"scale\")) {\n        this.markDirtyBounds();\n        display.scale = this.get(\"scale\", 0);\n      }\n\n      if (this.isDirty(\"centerX\") || this.isDirty(\"centerY\")) {\n        this.markDirtyBounds();\n        this.updatePivotPoint();\n      }\n\n      if (this.isDirty(\"visible\") || this.isPrivateDirty(\"visible\") || this.isDirty(\"forceHidden\")) {\n        if (!this.get(\"visible\") || !this.getPrivate(\"visible\") || this.get(\"forceHidden\")) {\n          display.visible = false;\n          this.hideTooltip();\n        } else {\n          display.visible = true;\n        }\n\n        this.markDirtyBounds();\n\n        if (this.get(\"focusable\")) {\n          this.markDirtyAccessibility();\n        }\n      }\n\n      if (this.isDirty(\"width\") || this.isDirty(\"height\")) {\n        this.markDirtyBounds();\n\n        this._addPercentageSizeChildren();\n\n        var parent_2 = this.parent;\n\n        if (parent_2) {\n          if (this.isDirty(\"width\") && this.get(\"width\") instanceof Percent || this.isDirty(\"height\") && this.get(\"height\") instanceof Percent) {\n            parent_2.markDirty();\n            parent_2._prevWidth = 0;\n          }\n        }\n\n        this._sizeDirty = true;\n      }\n\n      if (this.isDirty(\"maxWidth\") || this.isDirty(\"maxHeight\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"minWidth\") || this.isDirty(\"minHeight\") || this.isPrivateDirty(\"maxWidth\") || this.isPrivateDirty(\"maxHeight\") || this.isPrivateDirty(\"minWidth\") || this.isPrivateDirty(\"minHeight\")) {\n        this.markDirtyBounds();\n        this._sizeDirty = true;\n      }\n\n      if (this._sizeDirty) {\n        this._updateSize();\n      }\n\n      if (this.isDirty(\"wheelable\")) {\n        var wheelable = this.get(\"wheelable\");\n\n        if (wheelable) {\n          this.set(\"interactive\", true);\n        }\n\n        display.wheelable = wheelable ? true : false;\n      } // Accessibility\n\n\n      if (this.isDirty(\"tabindexOrder\") || this.isDirty(\"focusableGroup\")) {\n        if (this.get(\"focusable\")) {\n          this._root._registerTabindexOrder(this);\n        } else {\n          this._root._unregisterTabindexOrder(this);\n        }\n      }\n\n      if (this.isDirty(\"filter\")) {\n        //this.markDirtyBounds();\n        display.filter = this.get(\"filter\");\n      }\n\n      if (this.isDirty(\"cursorOverStyle\")) {\n        display.cursorOverStyle = this.get(\"cursorOverStyle\");\n      }\n\n      if (this.isDirty(\"hoverOnFocus\")) {\n        if (this.get(\"hoverOnFocus\")) {\n          this._focusDp = new MultiDisposer([events.on(\"focus\", function () {\n            // TODO: proper hover, not just tooltip\n            _this.showTooltip();\n          }), events.on(\"blur\", function () {\n            // TODO: proper hover, not just tooltip\n            _this.hideTooltip();\n          })]);\n        } else {\n          if (this._focusDp) {\n            this._focusDp.dispose();\n\n            this._focusDp = undefined;\n          }\n        }\n      }\n\n      if (this.isDirty(\"focusable\")) {\n        if (this.get(\"focusable\")) {\n          this._root._registerTabindexOrder(this);\n        } else {\n          this._root._unregisterTabindexOrder(this);\n        }\n\n        this.markDirtyAccessibility();\n      }\n\n      if (this.isDirty(\"role\") || this.isDirty(\"ariaLive\") || this.isDirty(\"ariaChecked\") || this.isDirty(\"ariaHidden\") || this.isDirty(\"ariaOrientation\") || this.isDirty(\"ariaValueNow\") || this.isDirty(\"ariaValueMin\") || this.isDirty(\"ariaValueMax\") || this.isDirty(\"ariaValueText\") || this.isDirty(\"ariaLabel\") || this.isDirty(\"ariaControls\")) {\n        // display.accessibility.ariaLabel = populateString(this, this.get(\"ariaLabel\", \"\"));\n        // @todo make sure ariaLabel gets populated in Root\n        this.markDirtyAccessibility();\n      }\n\n      if (this.isDirty(\"exportable\")) {\n        display.exportable = this.get(\"exportable\");\n      }\n\n      if (this.isDirty(\"interactive\")) {\n        var events_1 = this.events;\n\n        if (this.get(\"interactive\")) {\n          this._hoverDp = new MultiDisposer([events_1.on(\"click\", function (ev) {\n            if ($utils.isTouchEvent(ev.originalEvent)) {\n              if (!_this.getPrivate(\"touchHovering\")) {\n                _this.setTimeout(function () {\n                  _this._handleOver();\n\n                  if (_this.get(\"tooltipText\") || _this.get(\"tooltipHTML\")) {\n                    _this.showTooltip();\n                  }\n\n                  _this.setPrivateRaw(\"touchHovering\", true);\n\n                  _this.events.dispatch(\"pointerover\", {\n                    type: \"pointerover\",\n                    target: ev.target,\n                    originalEvent: ev.originalEvent,\n                    point: ev.point,\n                    simulated: ev.simulated\n                  });\n                }, 10);\n              }\n            }\n          }), events_1.on(\"globalpointerup\", function (ev) {\n            if ($utils.isTouchEvent(ev.originalEvent)) {\n              if (_this.getPrivate(\"touchHovering\")) {\n                _this._handleOut();\n\n                if (_this.get(\"tooltipText\") || _this.get(\"tooltipHTML\")) {\n                  _this.hideTooltip();\n                }\n              }\n\n              _this.setPrivateRaw(\"touchHovering\", false);\n\n              _this.events.dispatch(\"pointerout\", {\n                type: \"pointerout\",\n                target: ev.target,\n                originalEvent: ev.originalEvent,\n                point: ev.point,\n                simulated: ev.simulated\n              });\n            }\n\n            if (_this._isDown) {\n              _this._handleUp(ev);\n            } //this._isDown = false;\n\n          }), events_1.on(\"pointerover\", function () {\n            _this._handleOver();\n          }), events_1.on(\"pointerout\", function () {\n            _this._handleOut();\n          }), events_1.on(\"pointerdown\", function (e) {\n            _this._handleDown(e);\n          })]);\n        } else {\n          this._display.interactive = false;\n\n          if (this._hoverDp) {\n            this._hoverDp.dispose();\n\n            this._hoverDp = undefined;\n          }\n        }\n      }\n\n      if (this.isDirty(\"forceInactive\")) {\n        this._display.inactive = this.get(\"forceInactive\", false);\n      }\n\n      if (this.get(\"showTooltipOn\") == \"always\" && this._display.visible) {\n        this.showTooltip();\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   * @todo should this be user-accessible?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"dragStart\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (e) {\n      this._dragEvent = e;\n      this.events.stopParentDispatch();\n    }\n  });\n  /**\r\n   * @ignore\r\n   * @todo should this be user-accessible?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"dragStop\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (e) {\n      this._dragEvent = undefined;\n      this._dragPoint = undefined;\n      this.events.stopParentDispatch();\n\n      if (this._isDragging) {\n        this._isDragging = false;\n        var type = \"dragstop\";\n\n        if (this.events.isEnabled(type)) {\n          this.events.dispatch(type, {\n            type: type,\n            target: this,\n            originalEvent: e.originalEvent,\n            point: e.point,\n            simulated: e.simulated\n          });\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_handleOver\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this.isHidden()) {\n        if (this.get(\"active\") && this.states.lookup(\"hoverActive\")) {\n          this.states.applyAnimate(\"hoverActive\");\n        } else if (this.get(\"disabled\") && this.states.lookup(\"hoverDisabled\")) {\n          this.states.applyAnimate(\"hoverDisabled\");\n        } else {\n          this.states.applyAnimate(\"hover\");\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_handleOut\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this.isHidden()) {\n        if (this.get(\"active\") && this.states.lookup(\"active\")) {\n          this.states.applyAnimate(\"active\");\n        } else if (this.get(\"disabled\") && this.states.lookup(\"disabled\")) {\n          this.states.applyAnimate(\"disabled\");\n        } else {\n          if (this.states.lookup(\"hover\") || this.states.lookup(\"hoverActive\")) {\n            this.states.applyAnimate(\"default\");\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_handleUp\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (e) {\n      if (!this.isHidden()) {\n        if (this.get(\"active\") && this.states.lookup(\"active\")) {\n          this.states.applyAnimate(\"active\");\n        } else if (this.get(\"disabled\") && this.states.lookup(\"disabled\")) {\n          this.states.applyAnimate(\"disabled\");\n        } else if (this.states.lookup(\"down\")) {\n          if (this.isHover()) {\n            this.states.applyAnimate(\"hover\");\n          } else {\n            this.states.applyAnimate(\"default\");\n          }\n        } // @todo remove this once migrated to _downPoints\n\n\n        this._downPoint = undefined;\n        var pointerId = $utils.getPointerId(e.originalEvent);\n        delete this._downPoints[pointerId];\n\n        if ($object.keys(this._downPoints).length == 0) {\n          this._isDown = false;\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_hasMoved\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (e) {\n      // @todo remove this once migrated to _downPoints\n      // if (this._downPoint) {\n      // \tconst x = Math.abs(this._downPoint.x - e.point.x);\n      // \tconst y = Math.abs(this._downPoint.y - e.point.y);\n      // \treturn (x > 5) || (y > 5);\n      // }\n      var pointerId = $utils.getPointerId(e.originalEvent);\n      var downPoint = this._downPoints[pointerId];\n\n      if (downPoint) {\n        var x = Math.abs(downPoint.x - e.point.x);\n        var y = Math.abs(downPoint.y - e.point.y);\n        return x > 5 || y > 5;\n      }\n\n      return false;\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_hasDown\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return $object.keys(this._downPoints).length > 0;\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_handleDown\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (e) {\n      var parent = this.parent;\n\n      if (parent && !this.get(\"draggable\")) {\n        parent._handleDown(e);\n      }\n\n      if (this.get(\"interactive\") && !this.isHidden()) {\n        if (this.states.lookup(\"down\")) {\n          this.states.applyAnimate(\"down\");\n        }\n\n        this._downPoint = {\n          x: e.point.x,\n          y: e.point.y\n        }; // @todo remove this once migrated to _downPoints\n\n        this._isDown = true;\n        var pointerId = $utils.getPointerId(e.originalEvent);\n        this._downPoints[pointerId] = {\n          x: e.point.x,\n          y: e.point.y\n        };\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   * @todo should this be user-accessible?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"dragMove\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (e) {\n      var dragEvent = this._dragEvent;\n\n      if (dragEvent) {\n        if (dragEvent.simulated && !e.simulated) {\n          return true;\n        }\n\n        var angle = 0;\n        var parent_3 = this.parent;\n\n        while (parent_3 != null) {\n          angle += parent_3.get(\"rotation\", 0);\n          parent_3 = parent_3.parent;\n        }\n\n        var x = e.point.x - dragEvent.point.x;\n        var y = e.point.y - dragEvent.point.y;\n        var events = this.events;\n\n        if (dragEvent.simulated && !this._isDragging) {\n          this._isDragging = true;\n          this._dragEvent = e;\n          this._dragPoint = {\n            x: this.x(),\n            y: this.y()\n          };\n          var type = \"dragstart\";\n\n          if (events.isEnabled(type)) {\n            events.dispatch(type, {\n              type: type,\n              target: this,\n              originalEvent: e.originalEvent,\n              point: e.point,\n              simulated: e.simulated\n            });\n          }\n        }\n\n        if (this._isDragging) {\n          var dragPoint = this._dragPoint;\n          this.set(\"x\", dragPoint.x + x * $math.cos(angle) + y * $math.sin(angle));\n          this.set(\"y\", dragPoint.y + y * $math.cos(angle) - x * $math.sin(angle));\n          var type = \"dragged\";\n\n          if (events.isEnabled(type)) {\n            events.dispatch(type, {\n              type: type,\n              target: this,\n              originalEvent: e.originalEvent,\n              point: e.point,\n              simulated: e.simulated\n            });\n          }\n        } else {\n          if (Math.hypot(x, y) > 5) {\n            this._isDragging = true;\n            this._dragEvent = e;\n            this._dragPoint = {\n              x: this.x(),\n              y: this.y()\n            };\n            var type = \"dragstart\";\n\n            if (events.isEnabled(type)) {\n              events.dispatch(type, {\n                type: type,\n                target: this,\n                originalEvent: e.originalEvent,\n                point: e.point,\n                simulated: e.simulated\n              });\n            }\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_updateSize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {}\n  });\n  Object.defineProperty(Sprite.prototype, \"_getBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._localBounds = this._display.getLocalBounds();\n    }\n  });\n  /**\r\n   * Returns depth (how deep in the hierachy of the content tree) of this\r\n   * element.\r\n   *\r\n   * @return Depth\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"depth\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var self = this.parent;\n      var depth = 0;\n\n      while (true) {\n        if (self) {\n          ++depth;\n          self = self.parent;\n        } else {\n          return depth;\n        }\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"markDirtySize\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._sizeDirty = true;\n      this.markDirty();\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"markDirtyBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var display = this._display;\n\n      if (this.get(\"isMeasured\")) {\n        this._root._addDirtyBounds(this);\n\n        display.isMeasured = true;\n        display.invalidateBounds();\n        var parent_4 = this.parent;\n\n        if (parent_4 && this.get(\"position\") != \"absolute\") {\n          if (parent_4.get(\"width\") == null || parent_4.get(\"height\") == null || parent_4.get(\"layout\")) {\n            parent_4.markDirtyBounds();\n          }\n        }\n\n        if (this.get(\"focusable\") && this.isFocus()) {\n          this.markDirtyAccessibility();\n        }\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"markDirtyAccessibility\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      //if (this._root.focused(this)) {\n      this._root._invalidateAccessibility(this); //}\n\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"markDirtyLayer\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      //this._display.markDirtyLayer(this.isDirty(\"opacity\") || this.isDirty(\"visible\")); https://codepen.io/team/amcharts/pen/gOWZPmP <- problems\n      this._display.markDirtyLayer(true);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"markDirty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype.markDirty.call(this);\n\n      this.markDirtyLayer();\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_updateBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var oldBounds = this._adjustedLocalBounds;\n      var newBounds; // if display.visible == false, it still returns bounds\n\n      if (!this.get(\"visible\") || !this.getPrivate(\"visible\") || this.get(\"forceHidden\")) {\n        newBounds = {\n          left: 0,\n          right: 0,\n          top: 0,\n          bottom: 0\n        };\n        this._localBounds = newBounds;\n        this._adjustedLocalBounds = newBounds;\n      } else {\n        this._getBounds();\n\n        this._fixMinBounds(this._localBounds);\n\n        this.updatePivotPoint();\n        this._adjustedLocalBounds = this._display.getAdjustedBounds(this._localBounds);\n        newBounds = this._adjustedLocalBounds;\n      }\n\n      if (!oldBounds || oldBounds.left !== newBounds.left || oldBounds.top !== newBounds.top || oldBounds.right !== newBounds.right || oldBounds.bottom !== newBounds.bottom) {\n        var eventType = \"boundschanged\";\n\n        if (this.events.isEnabled(eventType)) {\n          this.events.dispatch(eventType, {\n            type: eventType,\n            target: this\n          });\n        }\n\n        if (this.parent) {\n          this.parent.markDirty();\n          this.parent.markDirtyBounds();\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_fixMinBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (bounds) {\n      var minWidth = this.get(\"minWidth\", this.getPrivate(\"minWidth\"));\n      var minHeight = this.get(\"minHeight\", this.getPrivate(\"minHeight\"));\n\n      if ($type.isNumber(minWidth)) {\n        if (bounds.right - bounds.left < minWidth) {\n          bounds.right = bounds.left + minWidth;\n        }\n      }\n\n      if ($type.isNumber(minHeight)) {\n        if (bounds.bottom - bounds.top < minHeight) {\n          bounds.bottom = bounds.top + minHeight;\n        }\n      }\n\n      var privateWidth = this.getPrivate(\"width\");\n      var privateHeight = this.getPrivate(\"height\");\n\n      if ($type.isNumber(privateWidth)) {\n        bounds.right = bounds.left + privateWidth;\n      }\n\n      if ($type.isNumber(privateHeight)) {\n        bounds.bottom = bounds.top + privateHeight;\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_removeParent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parent) {\n      if (parent) {\n        parent.children.removeValue(this);\n        $array.removeFirst(parent._percentageSizeChildren, this);\n        $array.removeFirst(parent._percentagePositionChildren, this);\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_clearDirty\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._clearDirty.call(this);\n\n      this._sizeDirty = false;\n      this._statesHandled = false;\n    }\n  });\n  /**\r\n   * Simulate hover over element.\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"hover\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.showTooltip();\n\n      this._handleOver();\n    }\n  });\n  /**\r\n   * Simulate unhover over element.\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"unhover\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.hideTooltip();\n\n      this._handleOut();\n    }\n  });\n  /**\r\n   * Shows element's [[Tooltip]].\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"showTooltip\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      var tooltip = this.getTooltip();\n      var tooltipText = this.get(\"tooltipText\");\n      var tooltipHTML = this.get(\"tooltipHTML\");\n\n      if ((tooltipText || tooltipHTML) && tooltip) {\n        var tooltipPosition = this.get(\"tooltipPosition\");\n        var tooltipTarget = this.getPrivate(\"tooltipTarget\", this);\n\n        if (tooltipPosition == \"fixed\" || !point) {\n          this._display._setMatrix();\n\n          point = this.toGlobal(tooltipTarget._getTooltipPoint());\n        }\n\n        tooltip.set(\"pointTo\", point);\n        tooltip.set(\"tooltipTarget\", tooltipTarget);\n\n        if (!tooltip.get(\"x\")) {\n          tooltip.set(\"x\", point.x);\n        }\n\n        if (!tooltip.get(\"y\")) {\n          tooltip.set(\"y\", point.y);\n        }\n\n        if (tooltipText) {\n          tooltip.label.set(\"text\", tooltipText);\n        }\n\n        if (tooltipHTML) {\n          tooltip.label.set(\"html\", tooltipHTML);\n        }\n\n        var dataItem = this.dataItem;\n\n        if (dataItem) {\n          tooltip.label._setDataItem(dataItem);\n        }\n\n        if (this.get(\"showTooltipOn\") == \"always\" && (point.x < 0 || point.x > this._root.width() || point.y < 0 || point.y > this._root.height())) {\n          this.hideTooltip();\n          return;\n        }\n\n        tooltip.label.text.markDirtyText();\n        var promise = tooltip.show();\n        this.setPrivateRaw(\"showingTooltip\", true);\n        return promise;\n      }\n    }\n  });\n  /**\r\n   * Hides element's [[Tooltip]].\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"hideTooltip\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var tooltip = this.getTooltip();\n\n      if (tooltip) {\n        if (tooltip.get(\"tooltipTarget\") == this.getPrivate(\"tooltipTarget\", this)) {\n          var timeout = tooltip.get(\"keepTargetHover\") && tooltip.get(\"stateAnimationDuration\", 0) == 0 ? 400 : undefined;\n          var promise = tooltip.hide(timeout);\n          this.setPrivateRaw(\"showingTooltip\", false);\n          return promise;\n        }\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_getTooltipPoint\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var bounds = this._localBounds;\n\n      if (bounds) {\n        var x = 0;\n        var y = 0;\n\n        if (!this.get(\"isMeasured\")) {\n          x = $utils.relativeToValue(this.get(\"tooltipX\", 0), this.width());\n          y = $utils.relativeToValue(this.get(\"tooltipY\", 0), this.height());\n        } else {\n          x = bounds.left + $utils.relativeToValue(this.get(\"tooltipX\", 0), bounds.right - bounds.left);\n          y = bounds.top + $utils.relativeToValue(this.get(\"tooltipY\", 0), bounds.bottom - bounds.top);\n        }\n\n        return {\n          x: x,\n          y: y\n        };\n      }\n\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n  });\n  /**\r\n   * Returns [[Tooltip]] used for this element.\r\n   *\r\n   * @return Tooltip\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"getTooltip\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var tooltip = this.get(\"tooltip\");\n\n      if (!tooltip) {\n        var parent_5 = this.parent;\n\n        if (parent_5) {\n          return parent_5.getTooltip();\n        }\n      } else {\n        return tooltip;\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_updatePosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var parent = this.parent;\n      var dx = this.get(\"dx\", 0);\n      var dy = this.get(\"dy\", 0);\n      var x = this.get(\"x\");\n\n      var _x = this.getPrivate(\"x\");\n\n      var xx = 0;\n      var yy = 0;\n      var position = this.get(\"position\");\n\n      if (x instanceof Percent) {\n        if (parent) {\n          x = parent.innerWidth() * x.value + parent.get(\"paddingLeft\", 0);\n        } else {\n          x = 0;\n        }\n      }\n\n      if ($type.isNumber(x)) {\n        xx = x + dx;\n      } else {\n        if (_x != null) {\n          xx = _x;\n        } else if (parent) {\n          if (position == \"relative\") {\n            xx = parent.get(\"paddingLeft\", 0) + dx;\n          }\n        }\n      }\n\n      var y = this.get(\"y\");\n\n      var _y = this.getPrivate(\"y\");\n\n      if (y instanceof Percent) {\n        if (parent) {\n          y = parent.innerHeight() * y.value + parent.get(\"paddingTop\", 0);\n        } else {\n          y = 0;\n        }\n      }\n\n      if ($type.isNumber(y)) {\n        yy = y + dy;\n      } else {\n        if (_y != null) {\n          yy = _y;\n        } else if (parent) {\n          if (position == \"relative\") {\n            yy = parent.get(\"paddingTop\", 0) + dy;\n          }\n        }\n      }\n\n      var display = this._display;\n\n      if (display.x != xx || display.y != yy) {\n        display.invalidateBounds();\n        display.x = xx;\n        display.y = yy;\n        var eventType = \"positionchanged\";\n\n        if (this.events.isEnabled(eventType)) {\n          this.events.dispatch(eventType, {\n            type: eventType,\n            target: this\n          });\n        }\n      } // Update tooltip position together with the Sprite\n\n\n      if (this.getPrivate(\"showingTooltip\")) {\n        this.showTooltip();\n      }\n    }\n  });\n  /**\r\n   * Returns element's actual X position in pixels.\r\n   *\r\n   * @return X (px)\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"x\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var x = this.get(\"x\");\n\n      var _x = this.getPrivate(\"x\");\n\n      var parent = this.parent;\n\n      if (parent) {\n        if (x instanceof Percent) {\n          return $utils.relativeToValue(x, parent.innerWidth()) + parent.get(\"paddingLeft\", 0);\n        } else {\n          if (!$type.isNumber(x)) {\n            if (_x != null) {\n              return _x;\n            } else {\n              return parent.get(\"paddingLeft\", this._display.x);\n            }\n          } else {\n            return x;\n          }\n        }\n      }\n\n      return this._display.x;\n    }\n  });\n  /**\r\n   * Returns element's actual Y position in pixels.\r\n   *\r\n   * @return Y (px)\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"y\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _y = this.getPrivate(\"y\");\n\n      if (_y != null) {\n        return _y;\n      }\n\n      var y = this.get(\"y\");\n      var parent = this.parent;\n\n      if (parent) {\n        if (y instanceof Percent) {\n          return $utils.relativeToValue(y, parent.innerHeight()) + parent.get(\"paddingTop\", 0);\n        } else {\n          if (!$type.isNumber(y)) {\n            if (_y != null) {\n              return _y;\n            } else {\n              return parent.get(\"paddingTop\", this._display.y);\n            }\n          } else {\n            return y;\n          }\n        }\n      }\n\n      return this._display.y;\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._dispose.call(this);\n\n      this._display.dispose();\n\n      this._removeTemplateField();\n\n      this._removeParent(this.parent);\n\n      this._root._removeFocusElement(this);\n\n      var tooltip = this.get(\"tooltip\");\n\n      if (tooltip) {\n        tooltip.dispose();\n      }\n\n      this.markDirty();\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"adjustedLocalBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._fixMinBounds(this._adjustedLocalBounds);\n\n      return this._adjustedLocalBounds;\n    }\n  });\n  /**\r\n   * Returns local coordinates of the element's bounds.\r\n   *\r\n   * @ignore\r\n   * @return Global bounds\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"localBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._localBounds;\n    }\n  });\n  /**\r\n   * Returns adjusted local coordinates of the element's bounds.\r\n   *\r\n   * @ignore\r\n   * @return Global bounds\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"bounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var bounds = this._adjustedLocalBounds;\n      var x = this.x();\n      var y = this.y();\n      return {\n        left: bounds.left + x,\n        right: bounds.right + x,\n        top: bounds.top + y,\n        bottom: bounds.bottom + y\n      };\n    }\n  });\n  /**\r\n   * Returns global coordinates of the element's bounds.\r\n   *\r\n   * @ignore\r\n   * @return Global bounds\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"globalBounds\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var bounds = this.localBounds();\n      var p0 = this.toGlobal({\n        x: bounds.left,\n        y: bounds.top\n      });\n      var p1 = this.toGlobal({\n        x: bounds.right,\n        y: bounds.top\n      });\n      var p2 = this.toGlobal({\n        x: bounds.right,\n        y: bounds.bottom\n      });\n      var p3 = this.toGlobal({\n        x: bounds.left,\n        y: bounds.bottom\n      });\n      return {\n        left: Math.min(p0.x, p1.x, p2.x, p3.x),\n        top: Math.min(p0.y, p1.y, p2.y, p3.y),\n        right: Math.max(p0.x, p1.x, p2.x, p3.x),\n        bottom: Math.max(p0.y, p1.y, p2.y, p3.y)\n      };\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_onShow\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_duration) {}\n  });\n  Object.defineProperty(Sprite.prototype, \"_onHide\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_duration) {}\n  });\n  /**\r\n   * Plays initial reveal animation regardless if element is currently hidden\r\n   * or visible.\r\n   *\r\n   * @param   duration  Duration of the animation in milliseconds\r\n   * @param   delay     Delay showing of the element by X milliseconds\r\n   * @return            Promise\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"appear\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (duration, delay) {\n      return __awaiter(this, void 0, void 0, function () {\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4\n              /*yield*/\n              , this.hide(0)];\n\n            case 1:\n              _a.sent();\n\n              if (delay) {\n                return [2\n                /*return*/\n                , new Promise(function (success, _error) {\n                  _this.setTimeout(function () {\n                    success(_this.show(duration));\n                  }, delay);\n                })];\n              } else {\n                return [2\n                /*return*/\n                , this.show(duration)];\n              }\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n  });\n  /**\r\n   * Shows currently hidden element and returns a `Promise` which completes\r\n   * when all showing animations are finished.\r\n   *\r\n   * ```TypeScript\r\n   * series.show().then(function(ev) {\r\n   *   console.log(\"Series is now fully visible\");\r\n   * })\r\n   * ```\r\n   * ```JavaScript\r\n   * series.show().then(function(ev) {\r\n   *   console.log(\"Series is now fully visible\");\r\n   * })\r\n   * ```\r\n   *\r\n   * @return Promise\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"show\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (duration) {\n      return __awaiter(this, void 0, void 0, function () {\n        var animations;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!!this._isShowing) return [3\n              /*break*/\n              , 2];\n              this._isHidden = false;\n              this._isShowing = true;\n              this._isHiding = false;\n\n              if (this.states.lookup(\"default\").get(\"visible\")) {\n                this.set(\"visible\", true);\n              }\n\n              this._onShow(duration);\n\n              animations = this.states.applyAnimate(\"default\", duration);\n              return [4\n              /*yield*/\n              , waitForAnimations(animations)];\n\n            case 1:\n              _a.sent();\n\n              this._isShowing = false;\n              _a.label = 2;\n\n            case 2:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n  });\n  /**\r\n   * Hides the element and returns a `Promise` which completes when all hiding\r\n   * animations are finished.\r\n   *\r\n   * ```TypeScript\r\n   * series.hide().then(function(ev) {\r\n   *   console.log(\"Series finished hiding\");\r\n   * })\r\n   * ```\r\n   * ```JavaScript\r\n   * series.hide().then(function(ev) {\r\n   *   console.log(\"Series finished hiding\");\r\n   * })\r\n   * ```\r\n   *\r\n   * @return Promise\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"hide\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (duration) {\n      return __awaiter(this, void 0, void 0, function () {\n        var state, animations;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              if (!(!this._isHiding && !this._isHidden)) return [3\n              /*break*/\n              , 2];\n              this._isHiding = true;\n              this._isShowing = false;\n              state = this.states.lookup(\"hidden\");\n\n              if (!state) {\n                state = this.states.create(\"hidden\", {\n                  \"opacity\": 0,\n                  \"visible\": false\n                });\n              }\n\n              this._isHidden = true;\n\n              this._onHide(duration);\n\n              animations = this.states.applyAnimate(\"hidden\", duration);\n              return [4\n              /*yield*/\n              , waitForAnimations(animations)];\n\n            case 1:\n              _a.sent();\n\n              this._isHiding = false;\n              _a.label = 2;\n\n            case 2:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }\n  });\n  /**\r\n   * Returns `true` if this element is currently hidden.\r\n   *\r\n   * @return Is hidden?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"isHidden\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._isHidden;\n    }\n  });\n  /**\r\n   * Returns `true` if this element is currently animating to a default state.\r\n   *\r\n   * @return Is showing?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"isShowing\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._isShowing;\n    }\n  });\n  /**\r\n   * Returns `true` if this element is currently animating to a hidden state.\r\n   *\r\n   * @return Is hiding?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"isHiding\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._isHiding;\n    }\n  });\n  /**\r\n   * Returns `true` if this element is currently hovered by a pointer.\r\n   *\r\n   * @return Is hovered?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"isHover\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._display.hovering();\n    }\n  });\n  /**\r\n   * Returns `true` if this element does currently have focus.\r\n   *\r\n   * @return Is focused?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"isFocus\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._root.focused(this);\n    }\n  });\n  /**\r\n   * Returns `true` if this element is currently being dragged.\r\n   *\r\n   * @return Is dragged?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"isDragging\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._isDragging;\n    }\n  });\n  /**\r\n   * Returns `false` if if either public or private setting `visible` is set\r\n   * to `false`, or `forceHidden` is set to `true`.\r\n   *\r\n   * @return Visible?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"isVisible\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this.get(\"visible\") && this.getPrivate(\"visible\") && !this.get(\"forceHidden\")) {\n        return true;\n      }\n\n      return false;\n    }\n  });\n  /**\r\n   * Same as `isVisible()`, except it checks all ascendants, too.\r\n   *\r\n   * @since 5.2.7\r\n   * @return Visible?\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"isVisibleDeep\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._parent ? this._parent.isVisibleDeep() && this.isVisible() : this.isVisible();\n    }\n  });\n  /**\r\n   * Returns an actual opacity of the element, taking into account all parents.\r\n   *\r\n   * @return Opacity\r\n   * @since 5.2.11\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"compositeOpacity\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var opacity = this.get(\"opacity\", 1);\n      return this._parent ? this._parent.compositeOpacity() * opacity : opacity;\n    }\n  });\n  /**\r\n   * Returns width of this element in pixels.\r\n   *\r\n   * @return Width (px)\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"width\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var width = this.get(\"width\");\n      var maxWidth = this.get(\"maxWidth\", this.getPrivate(\"maxWidth\"));\n      var minWidth = this.get(\"minWidth\", this.getPrivate(\"minWidth\"));\n      var privateWidth = this.getPrivate(\"width\");\n      var w = 0;\n\n      if ($type.isNumber(privateWidth)) {\n        w = privateWidth;\n      } else {\n        if (width == null) {\n          if (this._adjustedLocalBounds) {\n            w = this._adjustedLocalBounds.right - this._adjustedLocalBounds.left;\n          }\n        } else {\n          if (width instanceof Percent) {\n            var parent_6 = this.parent;\n\n            if (parent_6) {\n              w = parent_6.innerWidth() * width.value;\n            } else {\n              w = this._root.width() * width.value;\n            }\n          } else if ($type.isNumber(width)) {\n            w = width;\n          }\n        }\n      }\n\n      if ($type.isNumber(minWidth)) {\n        w = Math.max(minWidth, w);\n      }\n\n      if ($type.isNumber(maxWidth)) {\n        w = Math.min(maxWidth, w);\n      }\n\n      return w;\n    }\n  });\n  /**\r\n   * Returns maximum allowed width of this element in pixels.\r\n   *\r\n   * @return Maximum width (px)\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"maxWidth\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var maxWidth = this.get(\"maxWidth\", this.getPrivate(\"maxWidth\"));\n\n      if ($type.isNumber(maxWidth)) {\n        return maxWidth;\n      } else {\n        var width = this.get(\"width\");\n\n        if ($type.isNumber(width)) {\n          return width;\n        }\n      }\n\n      var parent = this.parent;\n\n      if (parent) {\n        return parent.innerWidth();\n      }\n\n      return this._root.width();\n    }\n  });\n  /**\r\n   * Returns maximum allowed height of this element in pixels.\r\n   *\r\n   * @return Maximum height (px)\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"maxHeight\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var maxHeight = this.get(\"maxHeight\", this.getPrivate(\"maxHeight\"));\n\n      if ($type.isNumber(maxHeight)) {\n        return maxHeight;\n      } else {\n        var height = this.get(\"height\");\n\n        if ($type.isNumber(height)) {\n          return height;\n        }\n      }\n\n      var parent = this.parent;\n\n      if (parent) {\n        return parent.innerHeight();\n      }\n\n      return this._root.height();\n    }\n  });\n  /**\r\n   * Returns height of this element in pixels.\r\n   *\r\n   * @return Height (px)\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"height\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var height = this.get(\"height\");\n      var maxHeight = this.get(\"maxHeight\", this.getPrivate(\"maxHeight\"));\n      var minHeight = this.get(\"minHeight\", this.getPrivate(\"minHeight\"));\n      var privateHeight = this.getPrivate(\"height\");\n      var h = 0;\n\n      if ($type.isNumber(privateHeight)) {\n        h = privateHeight;\n      } else {\n        if (height == null) {\n          if (this._adjustedLocalBounds) {\n            h = this._adjustedLocalBounds.bottom - this._adjustedLocalBounds.top;\n          }\n        } else {\n          if (height instanceof Percent) {\n            var parent_7 = this.parent;\n\n            if (parent_7) {\n              h = parent_7.innerHeight() * height.value;\n            } else {\n              h = this._root.height() * height.value;\n            }\n          } else if ($type.isNumber(height)) {\n            h = height;\n          }\n        }\n      }\n\n      if ($type.isNumber(minHeight)) {\n        h = Math.max(minHeight, h);\n      }\n\n      if ($type.isNumber(maxHeight)) {\n        h = Math.min(maxHeight, h);\n      }\n\n      return h;\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_findStaticTemplate\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (f) {\n      // templateField overrides template\n      if (this._templateField && f(this._templateField)) {\n        return this._templateField;\n      }\n\n      return _super.prototype._findStaticTemplate.call(this, f);\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_walkParents\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (f) {\n      if (this._parent) {\n        this._walkParent(f);\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_walkParent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (f) {\n      if (this._parent) {\n        this._parent._walkParent(f);\n      }\n\n      f(this);\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"parent\", {\n    /**\r\n     * Parent [[Container]] of this element.\r\n     *\r\n     * @return Parent container\r\n     */\n    get: function () {\n      return this._parent;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Sprite.prototype, \"_setParent\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (parent, updateChildren) {\n      if (updateChildren === void 0) {\n        updateChildren = false;\n      }\n\n      var prevParent = this._parent;\n\n      if (parent !== prevParent) {\n        this.markDirtyBounds();\n        parent.markDirty();\n        this._parent = parent;\n\n        if (updateChildren) {\n          this._removeParent(prevParent);\n\n          if (parent) {\n            this._addPercentageSizeChildren();\n\n            this._addPercentagePositionChildren();\n          }\n        }\n\n        this.markDirtyPosition();\n\n        this._applyThemes();\n      }\n    }\n  });\n  /**\r\n   * Returns an instance of [[NumberFormatter]] used in this element.\r\n   *\r\n   * If this element does not have it set, global one form [[Root]] is used.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info\r\n   * @return NumberFormatter instace\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"getNumberFormatter\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this.get(\"numberFormatter\", this._root.numberFormatter);\n    }\n  });\n  /**\r\n   * Returns an instance of [[DateFormatter]] used in this element.\r\n   *\r\n   * If this element does not have it set, global one form [[Root]] is used.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info\r\n   * @return DateFormatter instace\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"getDateFormatter\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this.get(\"dateFormatter\", this._root.dateFormatter);\n    }\n  });\n  /**\r\n   * Returns an instance of [[DurationFormatter]] used in this element.\r\n   *\r\n   * If this element does not have it set, global one form [[Root]] is used.\r\n   *\r\n   * @see {@link https://www.amcharts.com/docs/v5/concepts/using-formatters/} for more info\r\n   * @return DurationFormatter instace\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"getDurationFormatter\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this.get(\"durationFormatter\", this._root.durationFormatter);\n    }\n  });\n  /**\r\n   * Converts X/Y coordinate within this element to a global coordinate.\r\n   *\r\n   * @param  point  Local coordinate\r\n   * @return        Global coordinate\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"toGlobal\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      return this._display.toGlobal(point);\n    }\n  });\n  /**\r\n   * Converts global X/Y coordinate to a coordinate within this element.\r\n   *\r\n   * @param  point  Global coordinate\r\n   * @return        Local coordinate\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"toLocal\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (point) {\n      return this._display.toLocal(point);\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_getDownPoint\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var id = this._getDownPointId();\n\n      if (id) {\n        return this._downPoints[id];\n      }\n    }\n  });\n  Object.defineProperty(Sprite.prototype, \"_getDownPointId\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this._downPoints) {\n        return $object.keysOrdered(this._downPoints, function (a, b) {\n          if (a > b) {\n            return 1;\n          }\n\n          if (a < b) {\n            return -1;\n          }\n\n          return 0;\n        })[0];\n      }\n    }\n  });\n  /**\r\n   * Moves sprite to the end of the parent's children array.\r\n   *\r\n   * Depending on `layout` setting of the parten container, it may effect the\r\n   * positioning or overlapping order of the elements.\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"toFront\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var parent = this.parent;\n\n      if (parent) {\n        parent.children.moveValue(this, parent.children.length - 1);\n      }\n    }\n  });\n  /**\r\n   * Moves sprite to the beginning of the parent's children array.\r\n   *\r\n   * Depending on `layout` setting of the parten container, it may effect the\r\n   * positioning or overlapping order of the elements.\r\n   */\n\n  Object.defineProperty(Sprite.prototype, \"toBack\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var parent = this.parent;\n\n      if (parent) {\n        parent.children.moveValue(this, 0);\n      }\n    }\n  });\n  Object.defineProperty(Sprite, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"Sprite\"\n  });\n  Object.defineProperty(Sprite, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Entity.classNames.concat([Sprite.className])\n  });\n  return Sprite;\n}(Entity);\n\nexport { Sprite }; //# sourceMappingURL=Sprite.js.map","map":null,"metadata":{},"sourceType":"module"}