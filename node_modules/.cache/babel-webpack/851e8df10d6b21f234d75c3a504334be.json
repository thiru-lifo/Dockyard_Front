{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { XYSeries } from \"./XYSeries\";\nimport { Graphics } from \"../../../core/render/Graphics\";\nimport { line, area } from \"d3-shape\";\nimport { Template } from \"../../../core/util/Template\";\nimport { ListTemplate } from \"../../../core/util/List\";\nimport { color } from \"../../../core/util/Color\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { Rectangle } from \"../../../core/render/Rectangle\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * Used to plot line and/or area series.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/series/line-series/} for more info\r\n * @important\r\n */\n\nvar LineSeries =\n/** @class */\nfunction (_super) {\n  __extends(LineSeries, _super);\n\n  function LineSeries() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_endIndex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_strokeGenerator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: line()\n    });\n    Object.defineProperty(_this, \"_fillGenerator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: area()\n    });\n    Object.defineProperty(_this, \"_legendStroke\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_legendFill\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /**\r\n     * A [[TemplateList]] of all line segments in series.\r\n     *\r\n     * `strokes.template` can be used to set default settings for all line\r\n     * segments, or to change on existing ones.\r\n     *\r\n     * @default new ListTemplate<Graphics>\r\n     */\n\n    Object.defineProperty(_this, \"strokes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), function () {\n        return Graphics._new(_this._root, {\n          themeTags: $utils.mergeTags(_this.strokes.template.get(\"themeTags\", []), [\"line\", \"series\", \"stroke\"])\n        }, [_this.strokes.template]);\n      })\n    });\n    /**\r\n     * A [[TemplateList]] of all segment fills in series.\r\n     *\r\n     * `fills.template` can be used to set default settings for all segment\r\n     * fills, or to change on existing ones.\r\n     *\r\n     * @default new ListTemplate<Graphics>\r\n     */\n\n    Object.defineProperty(_this, \"fills\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new ListTemplate(Template.new({}), function () {\n        return Graphics._new(_this._root, {\n          themeTags: $utils.mergeTags(_this.strokes.template.get(\"themeTags\", []), [\"line\", \"series\", \"fill\"])\n        }, [_this.fills.template]);\n      })\n    }); // custom set from data\n\n    Object.defineProperty(_this, \"_fillTemplate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_strokeTemplate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_previousPoint\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [0, 0, 0, 0]\n    });\n    Object.defineProperty(_this, \"_dindex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_sindex\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    return _this;\n  }\n\n  Object.defineProperty(LineSeries.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._fillGenerator.y0(function (p) {\n        return p[3];\n      });\n\n      this._fillGenerator.x0(function (p) {\n        return p[2];\n      });\n\n      this._fillGenerator.y1(function (p) {\n        return p[1];\n      });\n\n      this._fillGenerator.x1(function (p) {\n        return p[0];\n      });\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(LineSeries.prototype, \"makeStroke\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (strokes) {\n      var stroke = this.mainContainer.children.push(strokes.make());\n      strokes.push(stroke);\n      return stroke;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(LineSeries.prototype, \"makeFill\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (fills) {\n      var fill = this.mainContainer.children.push(fills.make());\n      fills.push(fill);\n      return fill;\n    }\n  });\n  Object.defineProperty(LineSeries.prototype, \"_updateChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._strokeTemplate = undefined;\n      this._fillTemplate = undefined;\n      var xAxis = this.get(\"xAxis\");\n      var yAxis = this.get(\"yAxis\");\n\n      if (this.isDirty(\"stroke\")) {\n        var stroke = this.get(\"stroke\");\n        this.strokes.template.set(\"stroke\", stroke);\n        var legendStroke = this._legendStroke;\n\n        if (legendStroke) {\n          legendStroke.states.lookup(\"default\").set(\"stroke\", stroke);\n        }\n      }\n\n      if (this.isDirty(\"fill\")) {\n        var fill = this.get(\"fill\");\n        this.fills.template.set(\"fill\", fill);\n        var legendFill = this._legendFill;\n\n        if (legendFill) {\n          legendFill.states.lookup(\"default\").set(\"fill\", fill);\n        }\n      }\n\n      if (this.isDirty(\"curveFactory\")) {\n        var curveFactory = this.get(\"curveFactory\");\n\n        if (curveFactory) {\n          this._strokeGenerator.curve(curveFactory);\n\n          this._fillGenerator.curve(curveFactory);\n        }\n      }\n\n      if (xAxis.inited && yAxis.inited) {\n        if (this._axesDirty || this._valuesDirty || this._stackDirty || this.isDirty(\"vcx\") || this.isDirty(\"vcy\") || this._sizeDirty || this.isDirty(\"connect\") || this.isDirty(\"curveFactory\")) {\n          this.fills.each(function (fill) {\n            fill.setPrivate(\"visible\", false);\n          });\n          this.strokes.each(function (fill) {\n            fill.setPrivate(\"visible\", false);\n          });\n          this.axisRanges.each(function (axisRange) {\n            var fills = axisRange.fills;\n\n            if (fills) {\n              fills.each(function (fill) {\n                fill.setPrivate(\"visible\", false);\n              });\n            }\n\n            var strokes = axisRange.strokes;\n\n            if (strokes) {\n              strokes.each(function (stroke) {\n                stroke.setPrivate(\"visible\", false);\n              });\n            }\n          });\n          var startIndex = this.startIndex();\n          var strokeTemplateField = this.strokes.template.get(\"templateField\");\n          var fillTemplateField = this.fills.template.get(\"templateField\");\n          var strokeTemplateFound = true;\n          var fillTemplateFound = true;\n\n          if (strokeTemplateField) {\n            strokeTemplateFound = false;\n          }\n\n          if (fillTemplateField) {\n            fillTemplateFound = false;\n          }\n\n          var _loop_1 = function (i) {\n            var dataItem = this_1.dataItems[i];\n            var hasValues = true;\n            var dataContext = dataItem.dataContext;\n\n            if (strokeTemplateField) {\n              if (dataContext[strokeTemplateField]) {\n                strokeTemplateFound = true;\n              }\n            }\n\n            if (fillTemplateField) {\n              if (dataContext[fillTemplateField]) {\n                fillTemplateFound = true;\n              }\n            }\n\n            $array.each(this_1._valueFields, function (field) {\n              if (!$type.isNumber(dataItem.get(field))) {\n                hasValues = false;\n              }\n            });\n\n            if (hasValues && strokeTemplateFound && fillTemplateFound) {\n              startIndex = i;\n              return \"break\";\n            }\n          };\n\n          var this_1 = this;\n\n          for (var i = startIndex - 1; i >= 0; i--) {\n            var state_1 = _loop_1(i);\n\n            if (state_1 === \"break\") break;\n          }\n\n          var len = this.dataItems.length;\n          var endIndex = this.endIndex();\n\n          if (endIndex < len) {\n            endIndex++;\n\n            var _loop_2 = function (i) {\n              var dataItem = this_2.dataItems[i];\n              var hasValues = true;\n              $array.each(this_2._valueFields, function (field) {\n                if (!$type.isNumber(dataItem.get(field))) {\n                  hasValues = false;\n                }\n              });\n\n              if (hasValues) {\n                endIndex = i + 1;\n                return \"break\";\n              }\n            };\n\n            var this_2 = this;\n\n            for (var i = endIndex; i < len; i++) {\n              var state_2 = _loop_2(i);\n\n              if (state_2 === \"break\") break;\n            }\n          }\n\n          if (startIndex > 0) {\n            startIndex--;\n          }\n\n          this._endIndex = endIndex;\n\n          this._clearGraphics();\n\n          this._sindex = 0;\n          this._dindex = startIndex;\n\n          if (this.dataItems.length == 1) {\n            this._startSegment(0);\n          } else {\n            // this is done to avoid recursion with a lot of segments \n            while (this._dindex < endIndex - 1) {\n              this._startSegment(this._dindex);\n\n              this._sindex++;\n            }\n          }\n        }\n      } else {\n        this._skipped = true;\n      }\n\n      _super.prototype._updateChildren.call(this);\n    }\n  });\n  Object.defineProperty(LineSeries.prototype, \"_clearGraphics\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this.strokes.clear();\n      this.fills.clear();\n    }\n  });\n  Object.defineProperty(LineSeries.prototype, \"_startSegment\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItemIndex) {\n      var _this = this;\n\n      var endIndex = this._endIndex;\n      var currentEndIndex = endIndex;\n      var autoGapCount = this.get(\"autoGapCount\");\n      var connect = this.get(\"connect\");\n      var fill = this.makeFill(this.fills);\n      var fillTemplate = this._fillTemplate;\n      var originalTemplate = this.fills.template;\n\n      if (fillTemplate && fillTemplate != originalTemplate) {\n        fill.template = fillTemplate;\n      }\n\n      fill.setPrivate(\"visible\", true);\n      var stroke = this.makeStroke(this.strokes);\n      var strokeTemplate = this._strokeTemplate;\n\n      if (strokeTemplate && strokeTemplate != this.strokes.template) {\n        stroke.template = strokeTemplate;\n      }\n\n      stroke.setPrivate(\"visible\", true);\n      var xAxis = this.get(\"xAxis\");\n      var yAxis = this.get(\"yAxis\");\n      var baseAxis = this.get(\"baseAxis\");\n      var vcx = this.get(\"vcx\", 1);\n      var vcy = this.get(\"vcy\", 1);\n      var xField = this._xField;\n      var yField = this._yField;\n      var xOpenField = this._xOpenField;\n      var yOpenField = this._yOpenField;\n      var xOpenFieldValue = this.get(\"openValueXField\");\n      var yOpenFieldValue = this.get(\"openValueYField\");\n\n      if (!xOpenFieldValue) {\n        xOpenField = this._xField;\n      }\n\n      if (!yOpenFieldValue) {\n        yOpenField = this._yField;\n      }\n\n      var stacked = this.get(\"stacked\");\n      var basePosX = xAxis.basePosition();\n      var basePosY = yAxis.basePosition();\n      var baseField;\n\n      if (baseAxis === yAxis) {\n        baseField = this._yField;\n      } else {\n        baseField = this._xField;\n      }\n\n      var segments = [];\n      var points = [];\n      segments.push(points);\n      var strokeTemplateField = this.strokes.template.get(\"templateField\");\n      var fillTemplateField = this.fills.template.get(\"templateField\");\n      var locationX = this.get(\"locationX\", 0.5);\n      var locationY = this.get(\"locationY\", 0.5);\n      var openLocationX = this.get(\"openLocationX\", locationX);\n      var openLocationY = this.get(\"openLocationY\", locationY);\n      var minDistance = this.get(\"minDistance\", 0);\n      var i;\n      var fillVisible = this.fills.template.get(\"visible\");\n\n      if (this.axisRanges.length > 0) {\n        fillVisible = true;\n      }\n\n      var getOpen = false;\n\n      if (stacked || xOpenFieldValue || yOpenFieldValue) {\n        getOpen = true;\n      }\n\n      var o = {\n        points: points,\n        segments: segments,\n        stacked: stacked,\n        getOpen: getOpen,\n        basePosX: basePosX,\n        basePosY: basePosY,\n        fillVisible: fillVisible,\n        xField: xField,\n        yField: yField,\n        xOpenField: xOpenField,\n        yOpenField: yOpenField,\n        vcx: vcx,\n        vcy: vcy,\n        baseAxis: baseAxis,\n        xAxis: xAxis,\n        yAxis: yAxis,\n        locationX: locationX,\n        locationY: locationY,\n        openLocationX: openLocationX,\n        openLocationY: openLocationY,\n        minDistance: minDistance\n      };\n\n      for (i = dataItemIndex; i < currentEndIndex; i++) {\n        this._dindex = i;\n        var dataItem = this._dataItems[i];\n        var valueX = dataItem.get(xField);\n        var valueY = dataItem.get(yField);\n\n        if (valueX == null || valueY == null) {\n          if (!connect) {\n            points = [];\n            segments.push(points);\n            o.points = points;\n          }\n        } else {\n          this._getPoints(dataItem, o);\n        }\n\n        if (strokeTemplateField) {\n          var strokeTemplate_1 = dataItem.dataContext[strokeTemplateField];\n\n          if (strokeTemplate_1) {\n            if (!(strokeTemplate_1 instanceof Template)) {\n              strokeTemplate_1 = Template.new(strokeTemplate_1);\n            }\n\n            this._strokeTemplate = strokeTemplate_1;\n\n            if (i > dataItemIndex) {\n              currentEndIndex = i;\n              break;\n            } else {\n              stroke.template = strokeTemplate_1;\n            }\n          }\n        }\n\n        if (fillTemplateField) {\n          var fillTemplate_1 = dataItem.dataContext[fillTemplateField];\n\n          if (fillTemplate_1) {\n            if (!(fillTemplate_1 instanceof Template)) {\n              fillTemplate_1 = Template.new(fillTemplate_1);\n            }\n\n            this._fillTemplate = fillTemplate_1;\n\n            if (i > dataItemIndex) {\n              currentEndIndex = i;\n              break;\n            } else {\n              fill.template = fillTemplate_1;\n            }\n          }\n        }\n\n        if (!connect) {\n          var nextItem = this.dataItems[i + 1];\n\n          if (nextItem) {\n            if (baseAxis.shouldGap(dataItem, nextItem, autoGapCount, baseField)) {\n              points = [];\n              segments.push(points);\n              o.points = points;\n            }\n          }\n        }\n      }\n\n      fill.setRaw(\"userData\", [dataItemIndex, i]);\n      stroke.setRaw(\"userData\", [dataItemIndex, i]);\n\n      if (i === endIndex) {\n        this._endLine(points, segments[0][0]);\n      }\n\n      if (stroke) {\n        this._drawStroke(stroke, segments);\n      }\n\n      if (fill) {\n        this._drawFill(fill, segments);\n      }\n\n      this.axisRanges.each(function (axisRange) {\n        var container = axisRange.container;\n        var fills = axisRange.fills;\n\n        var fill = _this.makeFill(fills);\n\n        if (container) {\n          container.children.push(fill);\n        }\n\n        fill.setPrivate(\"visible\", true);\n\n        _this._drawFill(fill, segments);\n\n        var strokes = axisRange.strokes;\n\n        var stroke = _this.makeStroke(strokes);\n\n        if (container) {\n          container.children.push(stroke);\n        }\n\n        stroke.setPrivate(\"visible\", true);\n\n        _this._drawStroke(stroke, segments);\n\n        fill.setRaw(\"userData\", [dataItemIndex, i]);\n        stroke.setRaw(\"userData\", [dataItemIndex, i]);\n      });\n    }\n  });\n  Object.defineProperty(LineSeries.prototype, \"_getPoints\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, o) {\n      var points = o.points;\n      var itemLocationX = dataItem.get(\"locationX\", o.locationX);\n      var itemLocationY = dataItem.get(\"locationY\", o.locationY);\n      var xPos = o.xAxis.getDataItemPositionX(dataItem, o.xField, itemLocationX, o.vcx);\n      var yPos = o.yAxis.getDataItemPositionY(dataItem, o.yField, itemLocationY, o.vcy);\n\n      if (this._shouldInclude(xPos)) {\n        var iPoint = this.getPoint(xPos, yPos);\n        var point = [iPoint.x, iPoint.y];\n        iPoint.x += this._x;\n        iPoint.y += this._y;\n        dataItem.set(\"point\", iPoint);\n\n        if (o.fillVisible) {\n          var xPos0 = xPos;\n          var yPos0 = yPos;\n\n          if (o.baseAxis === o.xAxis) {\n            yPos0 = o.basePosY;\n          } else if (o.baseAxis === o.yAxis) {\n            xPos0 = o.basePosX;\n          }\n\n          if (o.getOpen) {\n            var valueX = dataItem.get(o.xOpenField);\n            var valueY = dataItem.get(o.yOpenField);\n\n            if (valueX != null && valueY != null) {\n              var itemLocationX_1 = dataItem.get(\"openLocationX\", o.openLocationX);\n              var itemLocationY_1 = dataItem.get(\"openLocationY\", o.openLocationY);\n\n              if (o.stacked) {\n                var stackToItemX = dataItem.get(\"stackToItemX\");\n                var stackToItemY = dataItem.get(\"stackToItemY\");\n\n                if (stackToItemX) {\n                  xPos0 = o.xAxis.getDataItemPositionX(stackToItemX, o.xField, itemLocationX_1, stackToItemX.component.get(\"vcx\"));\n\n                  if ($type.isNaN(xPos0)) {\n                    xPos0 = o.basePosX;\n                  }\n                } else {\n                  if (o.yAxis === o.baseAxis) {\n                    xPos0 = o.basePosX;\n                  } else {\n                    xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX_1, o.vcx);\n                  }\n                }\n\n                if (stackToItemY) {\n                  yPos0 = o.yAxis.getDataItemPositionY(stackToItemY, o.yField, itemLocationY_1, stackToItemY.component.get(\"vcy\"));\n\n                  if ($type.isNaN(yPos0)) {\n                    yPos0 = o.basePosY;\n                  }\n                } else {\n                  if (o.xAxis === o.baseAxis) {\n                    yPos0 = o.basePosY;\n                  } else {\n                    yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY_1, o.vcy);\n                  }\n                }\n              } else {\n                xPos0 = o.xAxis.getDataItemPositionX(dataItem, o.xOpenField, itemLocationX_1, o.vcx);\n                yPos0 = o.yAxis.getDataItemPositionY(dataItem, o.yOpenField, itemLocationY_1, o.vcy);\n              }\n            }\n          }\n\n          var closeIPoint = this.getPoint(xPos0, yPos0);\n          point[2] = closeIPoint.x;\n          point[3] = closeIPoint.y;\n        }\n\n        if (o.minDistance > 0) {\n          var p0 = point[0];\n          var p1 = point[1];\n          var p2 = point[2];\n          var p3 = point[3];\n          var prev = this._previousPoint;\n          var pp0 = prev[0];\n          var pp1 = prev[1];\n          var pp2 = prev[2];\n          var pp3 = prev[3];\n\n          if (Math.hypot(p0 - pp0, p1 - pp1) > o.minDistance || p2 && p3 && Math.hypot(p2 - pp2, p3 - pp3) > o.minDistance) {\n            points.push(point);\n            this._previousPoint = point;\n          }\n        } else {\n          points.push(point);\n        }\n      }\n    }\n  });\n  Object.defineProperty(LineSeries.prototype, \"_endLine\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_points, _firstPoint) {}\n  });\n  Object.defineProperty(LineSeries.prototype, \"_drawStroke\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (graphics, segments) {\n      var _this = this;\n\n      if (graphics.get(\"visible\")) {\n        graphics.set(\"draw\", function (display) {\n          $array.each(segments, function (segment) {\n            _this._strokeGenerator.context(display);\n\n            _this._strokeGenerator(segment);\n          });\n        });\n      }\n    }\n  });\n  Object.defineProperty(LineSeries.prototype, \"_drawFill\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (graphics, segments) {\n      var _this = this;\n\n      if (graphics.get(\"visible\")) {\n        graphics.set(\"draw\", function (display) {\n          $array.each(segments, function (segment) {\n            _this._fillGenerator.context(display);\n\n            _this._fillGenerator(segment);\n          });\n        });\n      }\n    }\n  });\n  Object.defineProperty(LineSeries.prototype, \"_processAxisRange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (axisRange) {\n      var _this = this;\n\n      _super.prototype._processAxisRange.call(this, axisRange);\n\n      axisRange.fills = new ListTemplate(Template.new({}), function () {\n        return Graphics._new(_this._root, {\n          themeTags: $utils.mergeTags(axisRange.fills.template.get(\"themeTags\", []), [\"line\", \"series\", \"fill\"])\n        }, [_this.fills.template, axisRange.fills.template]);\n      });\n      axisRange.strokes = new ListTemplate(Template.new({}), function () {\n        return Graphics._new(_this._root, {\n          themeTags: $utils.mergeTags(axisRange.strokes.template.get(\"themeTags\", []), [\"line\", \"series\", \"stroke\"])\n        }, [_this.strokes.template, axisRange.strokes.template]);\n      });\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(LineSeries.prototype, \"createLegendMarker\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_dataItem) {\n      var legendDataItem = this.get(\"legendDataItem\");\n\n      if (legendDataItem) {\n        var marker = legendDataItem.get(\"marker\");\n        var markerRectangle = legendDataItem.get(\"markerRectangle\");\n\n        if (markerRectangle) {\n          markerRectangle.setPrivate(\"visible\", false);\n        }\n\n        marker.set(\"background\", Rectangle.new(marker._root, {\n          fillOpacity: 0,\n          fill: color(0x000000)\n        }));\n        var legendStroke = marker.children.push(Graphics._new(marker._root, {\n          themeTags: [\"line\", \"series\", \"legend\", \"marker\", \"stroke\"],\n          interactive: false\n        }, [this.strokes.template]));\n        this._legendStroke = legendStroke;\n        var legendFill = marker.children.push(Graphics._new(marker._root, {\n          themeTags: [\"line\", \"series\", \"legend\", \"marker\", \"fill\"]\n        }, [this.fills.template]));\n        this._legendFill = legendFill;\n\n        var disabledColor = this._root.interfaceColors.get(\"disabled\");\n\n        legendStroke.states.create(\"disabled\", {\n          fill: disabledColor,\n          stroke: disabledColor\n        });\n        legendFill.states.create(\"disabled\", {\n          fill: disabledColor,\n          stroke: disabledColor\n        });\n\n        if (this.bullets.length > 0) {\n          var bulletFunction = this.bullets.getIndex(0);\n\n          if (bulletFunction) {\n            var bullet = bulletFunction(marker._root, this, new DataItem(this, {}, {}));\n\n            if (bullet) {\n              var sprite = bullet.get(\"sprite\");\n\n              if (sprite instanceof Graphics) {\n                sprite.states.create(\"disabled\", {\n                  fill: disabledColor,\n                  stroke: disabledColor\n                });\n              }\n\n              if (sprite) {\n                sprite.set(\"tooltipText\", undefined);\n                sprite.set(\"tooltipHTML\", undefined);\n                marker.children.push(sprite);\n                sprite.setAll({\n                  x: marker.width() / 2,\n                  y: marker.height() / 2\n                });\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(LineSeries, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"LineSeries\"\n  });\n  Object.defineProperty(LineSeries, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: XYSeries.classNames.concat([LineSeries.className])\n  });\n  return LineSeries;\n}(XYSeries);\n\nexport { LineSeries }; //# sourceMappingURL=LineSeries.js.map","map":null,"metadata":{},"sourceType":"module"}