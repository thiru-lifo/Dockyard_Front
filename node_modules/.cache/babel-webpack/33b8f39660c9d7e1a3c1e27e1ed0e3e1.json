{"ast":null,"code":"import { Injectable, EventEmitter, NgZone, Optional, Inject, PLATFORM_ID, NgModule } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\nimport { Subscription, fromEvent, merge } from 'rxjs';\nimport { filter, throttleTime } from 'rxjs/operators';\n/*\n * Represents a base class for types that provide expiry detection for the Idle service.\n */\n\nimport * as ɵngcc0 from '@angular/core';\n\nclass IdleExpiry {\n  constructor() {\n    this.idValue = new Date();\n    this.idlingValue = false;\n  }\n  /*\n   * Gets or sets a unique ID for the window\n   * @param id - The id.\n   * @return The current id.\n   */\n\n\n  id(value) {\n    if (value !== void 0) {\n      if (!value) {\n        throw new Error('A value must be specified for the ID.');\n      }\n\n      this.idValue = value;\n    }\n\n    return this.idValue;\n  }\n  /*\n   * Gets or sets the idling value.\n   * @param value - The value to set.\n   * @return The idling value.\n   */\n\n\n  idling(value) {\n    if (value !== void 0) {\n      this.idlingValue = value;\n    }\n\n    return this.idlingValue;\n  }\n  /*\n   * Returns the current Date.\n   * @return The current Date.\n   */\n\n\n  now() {\n    /* istanbul ignore next */\n    return new Date();\n  }\n  /*\n   * Returns whether or not it is expired.\n   * @return True if expired; otherwise, false.\n   */\n\n\n  isExpired() {\n    const expiry = this.last();\n    return expiry != null && expiry <= this.now();\n  }\n\n}\n/*\n * A class for managing an interrupt from an interrupt source.\n */\n\n\nclass Interrupt {\n  constructor(source, options) {\n    this.source = source;\n\n    if (source.initialize) {\n      source.initialize(options);\n    }\n  }\n  /*\n   * Subscribes to the interrupt using the specified function.\n   * @param fn - The subscription function.\n   */\n\n\n  subscribe(fn) {\n    this.sub = this.source.onInterrupt.subscribe(fn);\n  }\n  /*\n   * Unsubscribes the interrupt.\n   */\n\n\n  unsubscribe() {\n    this.sub.unsubscribe();\n    this.sub = null;\n  }\n  /*\n   * Keeps the subscription but resumes interrupt events.\n   */\n\n\n  resume() {\n    this.source.attach();\n  }\n  /*\n   * Keeps the subscription but pauses interrupt events.\n   */\n\n\n  pause() {\n    this.source.detach();\n  }\n\n}\n\nclass KeepaliveSvc {}\n/*\n * Represents an alternative storage for browser that doesn't support localstorage. (i.e. Safari in\n * private mode)\n * @implements Storage\n */\n\n\nclass AlternativeStorage {\n  constructor() {\n    this.storageMap = {};\n  }\n  /*\n   * Returns an integer representing the number of data items stored in the storageMap object.\n   */\n\n\n  get length() {\n    return Object.keys(this.storageMap).length;\n  }\n  /*\n   * Remove all keys out of the storage.\n   */\n\n\n  clear() {\n    this.storageMap = {};\n  }\n  /*\n   * Return the key's value\n   *\n   * @param key - name of the key to retrieve the value of.\n   * @return The key's value\n   */\n\n\n  getItem(key) {\n    if (typeof this.storageMap[key] !== 'undefined') {\n      return this.storageMap[key];\n    }\n\n    return null;\n  }\n  /*\n   * Return the nth key in the storage\n   *\n   * @param index - the number of the key you want to get the name of.\n   * @return The name of the key.\n   */\n\n\n  key(index) {\n    return Object.keys(this.storageMap)[index] || null;\n  }\n  /*\n   * Remove a key from the storage.\n   *\n   * @param key - the name of the key you want to remove.\n   */\n\n\n  removeItem(key) {\n    this.storageMap[key] = undefined;\n  }\n  /*\n   * Add a key to the storage, or update a key's value if it already exists.\n   *\n   * @param key - the name of the key.\n   * @param value - the value you want to give to the key.\n   */\n\n\n  setItem(key, value) {\n    this.storageMap[key] = value;\n  }\n\n}\n/*\n * Represents a localStorage store.\n */\n\n\nlet LocalStorage = /*#__PURE__*/(() => {\n  class LocalStorage {\n    constructor() {\n      this.storage = this.getStorage();\n    }\n    /*\n     * Safari, in Private Browsing Mode, looks like it supports localStorage but all calls to setItem\n     * throw QuotaExceededError. We're going to detect this and just silently drop any calls to\n     * setItem\n     * to avoid the entire page breaking, without having to do a check at each usage of Storage.\n     */\n\n\n    getStorage() {\n      try {\n        const storage = localStorage;\n        storage.setItem('ng2IdleStorage', '');\n        storage.removeItem('ng2IdleStorage');\n        return storage;\n      } catch (err) {\n        return new AlternativeStorage();\n      }\n    }\n    /*\n     * Gets an item in the storage.\n     *\n     * @param value - The value to get.\n     * @return The current value.\n     */\n\n\n    getItem(key) {\n      return this.storage.getItem('ng2Idle.' + key);\n    }\n    /*\n     * Removes an item in the storage.\n     *\n     * @param value - The value to remove.\n     */\n\n\n    removeItem(key) {\n      this.storage.removeItem('ng2Idle.' + key);\n    }\n    /*\n     * Sets an item in the storage.\n     *\n     * @param key - The key to set the value.\n     * @param value - The value to set to the key.\n     */\n\n\n    setItem(key, data) {\n      this.storage.setItem('ng2Idle.' + key, data);\n    }\n    /*\n     * Represents the storage, commonly use for testing purposes.\n     *\n     * @param key - The key to set the value.\n     * @param value - The value to set to the key.\n     */\n\n\n    _wrapped() {\n      return this.storage;\n    }\n\n  }\n\n  LocalStorage.ɵfac = function LocalStorage_Factory(t) {\n    return new (t || LocalStorage)();\n  };\n\n  LocalStorage.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LocalStorage,\n    factory: LocalStorage.ɵfac\n  });\n  return LocalStorage;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Represents a localStorage store of expiry values.\n * @extends IdleExpiry\n */\n\n\nlet LocalStorageExpiry = /*#__PURE__*/(() => {\n  class LocalStorageExpiry extends IdleExpiry {\n    constructor(localStorage) {\n      super();\n      this.localStorage = localStorage;\n      this.idleName = 'main';\n    }\n    /*\n     * Gets or sets the last expiry date in localStorage.\n     * If localStorage doesn't work correctly (i.e. Safari in private mode), we store the expiry value in memory.\n     * @param value - The expiry value to set; omit to only return the value.\n     * @return The current expiry value.\n     */\n\n\n    last(value) {\n      if (value !== void 0) {\n        this.setExpiry(value);\n      }\n\n      return this.getExpiry();\n    }\n\n    idling(value) {\n      if (value !== void 0) {\n        this.setIdling(value);\n      }\n\n      return this.getIdling();\n    }\n    /*\n     * Gets the idle name.\n     * @return The name of the idle.\n     */\n\n\n    getIdleName() {\n      return this.idleName;\n    }\n    /*\n     * Sets the idle name.\n     * @param The name of the idle.\n     */\n\n\n    setIdleName(key) {\n      if (key) {\n        this.idleName = key;\n      }\n    }\n\n    getExpiry() {\n      const expiry = this.localStorage.getItem(this.idleName + '.expiry');\n\n      if (expiry) {\n        return new Date(parseInt(expiry, 10));\n      } else {\n        return null;\n      }\n    }\n\n    setExpiry(value) {\n      if (value) {\n        this.localStorage.setItem(this.idleName + '.expiry', value.getTime().toString());\n      } else {\n        this.localStorage.removeItem(this.idleName + '.expiry');\n      }\n    }\n\n    getIdling() {\n      const idling = this.localStorage.getItem(this.idleName + '.idling');\n\n      if (idling) {\n        return idling === 'true';\n      } else {\n        return false;\n      }\n    }\n\n    setIdling(value) {\n      if (value) {\n        this.localStorage.setItem(this.idleName + '.idling', value.toString());\n      } else {\n        this.localStorage.setItem(this.idleName + '.idling', 'false');\n      }\n    }\n\n  }\n\n  LocalStorageExpiry.ɵfac = function LocalStorageExpiry_Factory(t) {\n    return new (t || LocalStorageExpiry)(ɵngcc0.ɵɵinject(LocalStorage));\n  };\n\n  LocalStorageExpiry.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LocalStorageExpiry,\n    factory: LocalStorageExpiry.ɵfac\n  });\n  return LocalStorageExpiry;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * Indicates the desired auto resume behavior.\n */\n\n\nvar AutoResume = /*#__PURE__*/(() => {\n  (function (AutoResume) {\n    /*\n     * Auto resume functionality will be disabled.\n     */\n    AutoResume[AutoResume[\"disabled\"] = 0] = \"disabled\";\n    /*\n     * Can resume automatically even if they are idle.\n     */\n\n    AutoResume[AutoResume[\"idle\"] = 1] = \"idle\";\n    /*\n     * Can only resume automatically if they are not yet idle.\n     */\n\n    AutoResume[AutoResume[\"notIdle\"] = 2] = \"notIdle\";\n  })(AutoResume || (AutoResume = {}));\n\n  return AutoResume;\n})();\n\n/**\n * A service for detecting and responding to user idleness.\n */\nlet Idle = /*#__PURE__*/(() => {\n  class Idle {\n    constructor(expiry, zone, keepaliveSvc, // tslint:disable-next-line: ban-types platform id injection will fail with any other type\n    platformId) {\n      this.expiry = expiry;\n      this.zone = zone;\n      this.platformId = platformId;\n      this.idle = 20 * 60; // in seconds\n\n      this.timeoutVal = 30; // in seconds\n\n      this.autoResume = AutoResume.idle;\n      this.interrupts = new Array();\n      this.running = false;\n      this.keepaliveEnabled = false;\n      this.onIdleStart = new EventEmitter();\n      this.onIdleEnd = new EventEmitter();\n      this.onTimeoutWarning = new EventEmitter();\n      this.onTimeout = new EventEmitter();\n      this.onInterrupt = new EventEmitter();\n\n      if (keepaliveSvc) {\n        this.keepaliveSvc = keepaliveSvc;\n        this.keepaliveEnabled = true;\n      }\n\n      this.setIdling(false);\n    }\n    /*\n     * Sets the idle name for localStorage.\n     * Important to set if multiple instances of Idle with LocalStorageExpiry\n     * @param The name of the idle.\n     */\n\n\n    setIdleName(key) {\n      if (this.expiry instanceof LocalStorageExpiry) {\n        this.expiry.setIdleName(key);\n      } else {\n        throw new Error('Cannot set expiry key name because no LocalStorageExpiry has been provided.');\n      }\n    }\n    /*\n     * Returns whether or not keepalive integration is enabled.\n     * @return True if integration is enabled; otherwise, false.\n     */\n\n\n    getKeepaliveEnabled() {\n      return this.keepaliveEnabled;\n    }\n    /*\n     * Sets and returns whether or not keepalive integration is enabled.\n     * @param True if the integration is enabled; otherwise, false.\n     * @return The current value.\n     */\n\n\n    setKeepaliveEnabled(value) {\n      if (!this.keepaliveSvc) {\n        throw new Error('Cannot enable keepalive integration because no KeepaliveSvc has been provided.');\n      }\n\n      return this.keepaliveEnabled = value;\n    }\n    /*\n     * Returns the current timeout value.\n     * @return The timeout value in seconds.\n     */\n\n\n    getTimeout() {\n      return this.timeoutVal;\n    }\n    /*\n     * Sets the timeout value.\n     * @param seconds - The timeout value in seconds. 0 or false to disable timeout feature.\n     * @return The current value. If disabled, the value will be 0.\n     */\n\n\n    setTimeout(seconds) {\n      if (seconds === false) {\n        this.timeoutVal = 0;\n      } else if (typeof seconds === 'number' && seconds >= 0) {\n        this.timeoutVal = seconds;\n      } else {\n        throw new Error(\"'seconds' can only be 'false' or a positive number.\");\n      }\n\n      return this.timeoutVal;\n    }\n    /*\n     * Returns the current idle value.\n     * @return The idle value in seconds.\n     */\n\n\n    getIdle() {\n      return this.idle;\n    }\n    /*\n     * Sets the idle value.\n     * @param seconds - The idle value in seconds.\n     * @return The idle value in seconds.\n     */\n\n\n    setIdle(seconds) {\n      if (seconds <= 0) {\n        throw new Error(\"'seconds' must be greater zero\");\n      }\n\n      return this.idle = seconds;\n    }\n    /*\n     * Returns the current autoresume value.\n     * @return The current value.\n     */\n\n\n    getAutoResume() {\n      return this.autoResume;\n    }\n\n    setAutoResume(value) {\n      return this.autoResume = value;\n    }\n    /*\n     * Sets interrupts from the specified sources.\n     * @param sources - Interrupt sources.\n     * @return The resulting interrupts.\n     */\n\n\n    setInterrupts(sources) {\n      this.clearInterrupts();\n      const self = this;\n\n      for (const source of sources) {\n        const options = {\n          platformId: this.platformId\n        };\n        const sub = new Interrupt(source, options);\n        sub.subscribe(args => {\n          self.interrupt(args.force, args.innerArgs);\n        });\n        this.interrupts.push(sub);\n      }\n\n      return this.interrupts;\n    }\n    /*\n     * Returns the current interrupts.\n     * @return The current interrupts.\n     */\n\n\n    getInterrupts() {\n      return this.interrupts;\n    }\n    /*\n     * Pauses, unsubscribes, and clears the current interrupt subscriptions.\n     */\n\n\n    clearInterrupts() {\n      for (const sub of this.interrupts) {\n        sub.pause();\n        sub.unsubscribe();\n      }\n\n      this.interrupts.length = 0;\n    }\n    /*\n     * Returns whether or not the service is running i.e. watching for idleness.\n     * @return True if service is watching; otherwise, false.\n     */\n\n\n    isRunning() {\n      return this.running;\n    }\n    /*\n     * Returns whether or not the user is considered idle.\n     * @return True if the user is in the idle state; otherwise, false.\n     */\n\n\n    isIdling() {\n      return this.idling;\n    }\n    /*\n     * Starts watching for inactivity.\n     */\n\n\n    watch(skipExpiry) {\n      this.safeClearInterval('idleHandle');\n      this.safeClearInterval('timeoutHandle');\n      const timeout = !this.timeoutVal ? 0 : this.timeoutVal;\n\n      if (!skipExpiry) {\n        const value = new Date(this.expiry.now().getTime() + (this.idle + timeout) * 1000);\n        this.expiry.last(value);\n      }\n\n      if (this.idling) {\n        this.toggleState();\n      }\n\n      if (!this.running) {\n        this.startKeepalive();\n        this.toggleInterrupts(true);\n      }\n\n      this.running = true;\n\n      const watchFn = () => {\n        this.zone.run(() => {\n          const diff = this.getExpiryDiff(timeout);\n\n          if (diff > 0) {\n            this.safeClearInterval('idleHandle');\n            this.setIdleIntervalOutsideOfZone(watchFn, diff);\n          } else {\n            this.toggleState();\n          }\n        });\n      };\n\n      this.setIdleIntervalOutsideOfZone(watchFn, this.idle * 1000);\n    }\n    /*\n     * Allows protractor tests to call waitForAngular without hanging\n     */\n\n\n    setIdleIntervalOutsideOfZone(watchFn, frequency) {\n      this.zone.runOutsideAngular(() => {\n        this.idleHandle = setInterval(watchFn, frequency);\n      });\n    }\n    /*\n     * Stops watching for inactivity.\n     */\n\n\n    stop() {\n      this.stopKeepalive();\n      this.toggleInterrupts(false);\n      this.safeClearInterval('idleHandle');\n      this.safeClearInterval('timeoutHandle');\n      this.setIdling(false);\n      this.running = false;\n      this.expiry.last(null);\n    }\n    /*\n     * Forces a timeout event and state.\n     */\n\n\n    timeout() {\n      this.stopKeepalive();\n      this.toggleInterrupts(false);\n      this.safeClearInterval('idleHandle');\n      this.safeClearInterval('timeoutHandle');\n      this.setIdling(true);\n      this.running = false;\n      this.countdown = 0;\n      this.onTimeout.emit(null);\n    }\n    /*\n     * Signals that user activity has occurred.\n     * @param force - Forces watch to be called, unless they are timed out.\n     * @param eventArgs - Optional source event arguments.\n     */\n\n\n    interrupt(force, eventArgs) {\n      if (!this.running) {\n        return;\n      }\n\n      if (this.timeoutVal && this.expiry.isExpired()) {\n        this.timeout();\n        return;\n      }\n\n      this.onInterrupt.emit(eventArgs);\n\n      if (force === true || this.autoResume === AutoResume.idle || this.autoResume === AutoResume.notIdle && !this.expiry.idling()) {\n        this.watch(force);\n      }\n    }\n\n    setIdling(value) {\n      this.idling = value;\n      this.expiry.idling(value);\n    }\n\n    toggleState() {\n      this.setIdling(!this.idling);\n\n      if (this.idling) {\n        this.onIdleStart.emit(null);\n        this.stopKeepalive();\n\n        if (this.timeoutVal > 0) {\n          this.countdown = this.timeoutVal;\n          this.doCountdown();\n          this.setTimoutIntervalOutsideZone(() => {\n            this.doCountdownInZone();\n          }, 1000);\n        }\n      } else {\n        this.toggleInterrupts(true);\n        this.onIdleEnd.emit(null);\n        this.startKeepalive();\n      }\n\n      this.safeClearInterval('idleHandle');\n    }\n\n    setTimoutIntervalOutsideZone(intervalFn, frequency) {\n      this.zone.runOutsideAngular(() => {\n        this.timeoutHandle = setInterval(() => {\n          intervalFn();\n        }, frequency);\n      });\n    }\n\n    toggleInterrupts(resume) {\n      for (const interrupt of this.interrupts) {\n        if (resume) {\n          interrupt.resume();\n        } else {\n          interrupt.pause();\n        }\n      }\n    }\n\n    getExpiryDiff(timeout) {\n      const now = this.expiry.now();\n      const last = this.expiry.last() || now;\n      return last.getTime() - now.getTime() - timeout * 1000;\n    }\n\n    doCountdownInZone() {\n      this.zone.run(() => {\n        this.doCountdown();\n      });\n    }\n\n    doCountdown() {\n      const diff = this.getExpiryDiff(this.timeoutVal);\n\n      if (diff > 0) {\n        this.safeClearInterval('timeoutHandle');\n        this.interrupt(true);\n        return;\n      }\n\n      if (!this.idling) {\n        return;\n      }\n\n      if (this.countdown <= 0) {\n        this.timeout();\n        return;\n      }\n\n      this.onTimeoutWarning.emit(this.countdown);\n      this.countdown--;\n    }\n\n    safeClearInterval(handleName) {\n      const handle = this[handleName];\n\n      if (handle !== null && typeof handle !== 'undefined') {\n        clearInterval(this[handleName]);\n        this[handleName] = null;\n      }\n    }\n\n    startKeepalive() {\n      if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n        return;\n      }\n\n      if (this.running) {\n        this.keepaliveSvc.ping();\n      }\n\n      this.keepaliveSvc.start();\n    }\n\n    stopKeepalive() {\n      if (!this.keepaliveSvc || !this.keepaliveEnabled) {\n        return;\n      }\n\n      this.keepaliveSvc.stop();\n    }\n    /*\n     * Called by Angular when destroying the instance.\n     */\n\n\n    ngOnDestroy() {\n      this.stop();\n      this.clearInterrupts();\n    }\n\n  }\n\n  Idle.ɵfac = function Idle_Factory(t) {\n    return new (t || Idle)(ɵngcc0.ɵɵinject(IdleExpiry), ɵngcc0.ɵɵinject(ɵngcc0.NgZone), ɵngcc0.ɵɵinject(KeepaliveSvc, 8), ɵngcc0.ɵɵinject(PLATFORM_ID, 8));\n  };\n\n  Idle.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: Idle,\n    factory: Idle.ɵfac\n  });\n  return Idle;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\n * A class for expressing arguments to interrupt events.\n */\n\n\nclass InterruptArgs {\n  constructor(source, innerArgs, force = false) {\n    this.source = source;\n    this.innerArgs = innerArgs;\n    this.force = force;\n  }\n\n}\n/*\n * A base for classes that act as a source for interrupts.\n */\n\n\nclass InterruptSource {\n  constructor(attachFn, detachFn) {\n    this.attachFn = attachFn;\n    this.detachFn = detachFn;\n    this.isAttached = false;\n    this.onInterrupt = new EventEmitter();\n  }\n  /*\n   * Attaches to the specified events on the specified source.\n   */\n\n\n  attach() {\n    // If the current zone is the 'angular' zone (a.k.a. NgZone) then re-enter this method in its parent zone\n    // The parent zone is usually the '<root>' zone but it can also be 'long-stack-trace-zone' in debug mode\n    // In tests, the current zone is typically a 'ProxyZone' created by async/fakeAsync (from @angular/core/testing)\n    if (Zone.current.get('isAngularZone') === true) {\n      Zone.current.parent.run(() => this.attach());\n      return;\n    }\n\n    if (!this.isAttached && this.attachFn) {\n      this.attachFn(this);\n    }\n\n    this.isAttached = true;\n  }\n  /*\n   * Detaches from the specified events on the specified source.\n   */\n\n\n  detach() {\n    if (this.isAttached && this.detachFn) {\n      this.detachFn(this);\n    }\n\n    this.isAttached = false;\n  }\n\n}\n\nconst defaultThrottleDelay = 500;\n/*\n * An interrupt source on an EventTarget object, such as a Window or HTMLElement.\n */\n\nclass EventTargetInterruptSource extends InterruptSource {\n  constructor(target, events, opts) {\n    super(null, null);\n    this.target = target;\n    this.events = events;\n    this.opts = opts;\n    this.eventSubscription = new Subscription();\n\n    if (typeof this.opts === 'number') {\n      this.opts = {\n        throttleDelay: this.opts,\n        passive: false\n      };\n    }\n\n    this.opts = this.opts || {\n      passive: false,\n      throttleDelay: defaultThrottleDelay\n    };\n\n    if (this.opts.throttleDelay === undefined || this.opts.throttleDelay === null) {\n      this.opts.throttleDelay = defaultThrottleDelay;\n    }\n\n    this.throttleDelay = this.opts.throttleDelay;\n    this.passive = !!this.opts.passive;\n  }\n\n  initialize(options) {\n    if ((options === null || options === void 0 ? void 0 : options.platformId) && isPlatformServer(options.platformId)) {\n      return;\n    }\n\n    const eventTarget = typeof this.target === 'function' ? this.target() : this.target;\n    const opts = this.passive ? {\n      passive: true\n    } : null;\n    const fromEvents = this.events.split(' ').map(eventName => fromEvent(eventTarget, eventName, opts));\n    this.eventSrc = merge(...fromEvents);\n    this.eventSrc = this.eventSrc.pipe(filter(innerArgs => !this.filterEvent(innerArgs)));\n\n    if (this.throttleDelay > 0) {\n      this.eventSrc = this.eventSrc.pipe(throttleTime(this.throttleDelay));\n    }\n\n    const handler = innerArgs => this.onInterrupt.emit(new InterruptArgs(this, innerArgs));\n\n    this.attachFn = () => this.eventSubscription = this.eventSrc.subscribe(handler);\n\n    this.detachFn = () => this.eventSubscription.unsubscribe();\n  }\n  /*\n   * Checks to see if the event should be filtered. Always returns false unless overriden.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n\n\n  filterEvent(event) {\n    return false;\n  }\n  /**\n   * Returns the current options being used.\n   * @return The current option values.\n   */\n\n\n  get options() {\n    return {\n      passive: this.passive,\n      throttleDelay: this.throttleDelay\n    };\n  }\n\n}\n/*\n * An interrupt source that uses events on the document element (html tag).\n */\n\n\nclass DocumentInterruptSource extends EventTargetInterruptSource {\n  constructor(events, options) {\n    super(() => document.documentElement, events, options);\n  }\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n\n\n  filterEvent(event) {\n    // some browser bad input hacks\n    if (event.type === 'mousemove' && ( // fix for Chrome destop notifications\n    event.originalEvent && event.originalEvent.movementX === 0 && event.originalEvent.movementY === 0 || // fix for webkit fake mousemove\n    event.movementX !== void 0 && !event.movementX || !event.movementY)) {\n      return true;\n    }\n\n    return false;\n  }\n\n}\n/*\n * An interrupt source on the Window object.\n */\n\n\nclass WindowInterruptSource extends EventTargetInterruptSource {\n  constructor(events, options) {\n    super(() => window, events, options);\n  }\n\n}\n/*\n * An interrupt source on the storage event of Window.\n */\n\n\nclass StorageInterruptSource extends WindowInterruptSource {\n  constructor(options = 500) {\n    super('storage', options);\n  }\n  /*\n   * Checks to see if the event should be filtered.\n   * @param event - The original event object.\n   * @return True if the event should be filtered (don't cause an interrupt); otherwise, false.\n   */\n\n\n  filterEvent(event) {\n    if (event.key && event.key.indexOf('ng2Idle.') >= 0 && event.key.indexOf('.expiry') >= 0) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n/*\n * Represents a simple in-memory store of expiry values.\n * @extends IdleExpiry\n */\n\n\nclass SimpleExpiry extends IdleExpiry {\n  constructor() {\n    super();\n    this.lastValue = null;\n  }\n  /*\n   * Gets or sets the last expiry date.\n   * @param value - The expiry value to set; omit to only return the value.\n   * @return The current expiry value.\n   */\n\n\n  last(value) {\n    if (value !== void 0) {\n      this.lastValue = value;\n    }\n\n    return this.lastValue;\n  }\n\n}\n\nlet NgIdleModule = /*#__PURE__*/(() => {\n  class NgIdleModule {\n    static forRoot() {\n      return {\n        ngModule: NgIdleModule,\n        providers: [LocalStorageExpiry, {\n          provide: IdleExpiry,\n          useExisting: LocalStorageExpiry\n        }, Idle]\n      };\n    }\n\n  }\n\n  NgIdleModule.ɵfac = function NgIdleModule_Factory(t) {\n    return new (t || NgIdleModule)();\n  };\n\n  NgIdleModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgIdleModule\n  });\n  NgIdleModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [LocalStorage]\n  });\n  return NgIdleModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nfunction createDefaultInterruptSources(options) {\n  return [new DocumentInterruptSource('mousemove keydown DOMMouseScroll mousewheel mousedown touchstart touchmove scroll', options), new StorageInterruptSource(options)];\n}\n\nconst DEFAULT_INTERRUPTSOURCES = createDefaultInterruptSources();\n/*\n * Public API Surface of core\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AutoResume, DEFAULT_INTERRUPTSOURCES, DocumentInterruptSource, EventTargetInterruptSource, Idle, IdleExpiry, InterruptArgs, InterruptSource, KeepaliveSvc, LocalStorage, LocalStorageExpiry, NgIdleModule, SimpleExpiry, StorageInterruptSource, WindowInterruptSource, createDefaultInterruptSources }; //# sourceMappingURL=ng-idle-core.js.map","map":null,"metadata":{},"sourceType":"module"}