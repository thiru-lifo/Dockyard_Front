{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { Pattern } from \"./Pattern\";\nimport * as $math from \"../../util/Math\";\n/**\r\n * Circle pattern.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\r\n */\n\nvar CirclePattern =\n/** @class */\nfunction (_super) {\n  __extends(CirclePattern, _super);\n\n  function CirclePattern() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Object.defineProperty(CirclePattern.prototype, \"_beforeChanged\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._beforeChanged.call(this);\n\n      if (this.isDirty(\"gap\")) {\n        this._clear = true;\n      }\n    }\n  });\n  Object.defineProperty(CirclePattern.prototype, \"_draw\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      _super.prototype._draw.call(this);\n\n      var checkered = this.get(\"checkered\", false);\n      var centered = this.get(\"centered\", true);\n      var gap = this.get(\"gap\", 0);\n      var rotation = this.get(\"rotation\", 0);\n      var w = this.get(\"width\", 100);\n      var h = this.get(\"height\", 100);\n      var radius = this.get(\"radius\", 3);\n      var cellW = radius * 2 + gap;\n      var cellH = radius * 2 + gap;\n      var cols = Math.round(w / cellW);\n      var rows = Math.round(h / cellH);\n      cellW = w / cols;\n      cellH = h / rows;\n\n      if (rotation != 0) {\n        // @todo this is probably not right\n        this._display.x = cellW * $math.cos(rotation);\n        this._display.y = cellH * $math.sin(rotation);\n      }\n\n      var color = this.get(\"color\");\n      var colorOpacity = this.get(\"colorOpacity\");\n\n      if (color || colorOpacity) {\n        this._display.beginFill(color, colorOpacity);\n      }\n\n      for (var r = rotation == 0 ? 0 : -rows * 2; r < rows * 2; r++) {\n        for (var c = rotation == 0 ? 0 : -cols * 2; c < cols * 2; c++) {\n          if (!checkered || (r & 1) != 1 && (c & 1) != 1 || (r & 1) == 1 && (c & 1) == 1) {\n            var x = c * cellW;\n            var y = r * cellH;\n\n            if (centered) {\n              x += cellW + gap / 2;\n              y += cellH + gap / 2;\n            }\n\n            this._display.drawCircle(x - radius, y - radius, radius);\n          }\n        }\n      }\n\n      if (checkered) {\n        w = w / 2 - gap * 2;\n        h = h / 2 - gap * 2;\n      } else {\n        w -= gap;\n        h -= gap;\n      }\n\n      if (color || colorOpacity) {\n        this._display.endFill();\n      }\n    }\n  });\n  Object.defineProperty(CirclePattern, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"CirclePattern\"\n  });\n  Object.defineProperty(CirclePattern, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Pattern.classNames.concat([CirclePattern.className])\n  });\n  return CirclePattern;\n}(Pattern);\n\nexport { CirclePattern }; //# sourceMappingURL=CirclePattern.js.map","map":null,"metadata":{},"sourceType":"module"}