{"ast":null,"code":"/**\r\n * Event Dispatcher module is used for registering listeners and dispatching\r\n * events across amCharts system.\r\n */\nimport { __extends } from \"tslib\";\n/**\r\n * ============================================================================\r\n * IMPORTS\r\n * ============================================================================\r\n * @hidden\r\n */\n\nimport { Disposer, MultiDisposer } from \"./Disposer\";\nimport * as $array from \"./Array\";\nimport * as $type from \"./Type\";\n/**\r\n * Universal Event Dispatcher.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/events/} for more info\r\n */\n\nvar EventDispatcher =\n/** @class */\nfunction () {\n  /**\r\n   * Constructor\r\n   */\n  function EventDispatcher() {\n    Object.defineProperty(this, \"_listeners\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_killed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_iterating\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_enabled\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_disposed\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this._listeners = [];\n    this._killed = [];\n    this._disabled = {};\n    this._iterating = 0;\n    this._enabled = true;\n    this._disposed = false;\n  }\n  /**\r\n   * Returns if this object has been already disposed.\r\n   *\r\n   * @return Disposed?\r\n   */\n\n\n  Object.defineProperty(EventDispatcher.prototype, \"isDisposed\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._disposed;\n    }\n  });\n  /**\r\n   * Dispose (destroy) this object.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"dispose\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (!this._disposed) {\n        this._disposed = true;\n        var a = this._listeners;\n        this._iterating = 1;\n        this._listeners = null;\n        this._disabled = null;\n\n        try {\n          $array.each(a, function (x) {\n            x.disposer.dispose();\n          });\n        } finally {\n          this._killed = null;\n          this._iterating = null;\n        }\n      }\n    }\n  });\n  /**\r\n   * Checks if this particular event dispatcher has any listeners set.\r\n   *\r\n   * @return Has listeners?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"hasListeners\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this._listeners.length !== 0;\n    }\n  });\n  /**\r\n   * Checks if this particular event dispatcher has any particular listeners set.\r\n   *\r\n   * @return Has particular event listeners?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"hasListenersByType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      return $array.any(this._listeners, function (x) {\n        return (x.type === null || x.type === type) && !x.killed;\n      });\n    }\n  });\n  /**\r\n   * Enable dispatching of events if they were previously disabled by\r\n   * `disable()`.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"enable\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._enabled = true;\n    }\n  });\n  /**\r\n   * Disable dispatching of events until re-enabled by `enable()`.\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"disable\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._enabled = false;\n    }\n  });\n  /**\r\n   * Enable dispatching particular event, if it was disabled before by\r\n   * `disableType()`.\r\n   *\r\n   * @param type Event type\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"enableType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      delete this._disabled[type];\n    }\n  });\n  /**\r\n   * Disable dispatching of events for a certain event type.\r\n   *\r\n   * Optionally, can set how many dispatches to skip before automatically\r\n   * re-enabling the dispatching.\r\n   *\r\n   * @param type    Event type\r\n   * @param amount  Number of event dispatches to skip\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"disableType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, amount) {\n      if (amount === void 0) {\n        amount = Infinity;\n      }\n\n      this._disabled[type] = amount;\n    }\n  });\n  /**\r\n   * Removes listener from dispatcher.\r\n   *\r\n   * Will throw an exception if such listener does not exists.\r\n   *\r\n   * @param listener Listener to remove\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_removeListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (listener) {\n      if (this._iterating === 0) {\n        var index = this._listeners.indexOf(listener);\n\n        if (index === -1) {\n          throw new Error(\"Invalid state: could not remove listener\");\n        }\n\n        this._listeners.splice(index, 1);\n      } else {\n        this._killed.push(listener);\n      }\n    }\n  });\n  /**\r\n   * Removes existing listener by certain parameters.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_removeExistingListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (once, type, callback, context) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._eachListener(function (info) {\n        if (info.once === once && // TODO is this correct ?\n        info.type === type && (callback === undefined || info.callback === callback) && info.context === context) {\n          info.disposer.dispose();\n        }\n      });\n    }\n  });\n  /**\r\n   * Checks if dispatching for particular event type is enabled.\r\n   *\r\n   * @param type  Event type\r\n   * @return Enabled?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"isEnabled\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      } // TODO is this check correct ?\n\n\n      return this._enabled && this._listeners.length > 0 && this.hasListenersByType(type) && this._disabled[type] === undefined;\n    }\n  });\n  /**\r\n   * Removes all listeners of a particular event type\r\n   *\r\n   * @param type  Listener's type\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"removeType\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._eachListener(function (info) {\n        if (info.type === type) {\n          info.disposer.dispose();\n        }\n      });\n    }\n  });\n  /**\r\n   * Checks if there's already a listener with specific parameters.\r\n   *\r\n   * @param type      Listener's type\r\n   * @param callback  Callback function\r\n   * @param context   Callback context\r\n   * @return Has listener?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"has\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context) {\n      var index = $array.findIndex(this._listeners, function (info) {\n        return info.once !== true && // Ignoring \"once\" listeners\n        info.type === type && (callback === undefined || info.callback === callback) && info.context === context;\n      });\n      return index !== -1;\n    }\n  });\n  /**\r\n   * Checks whether event of the particular type should be dispatched.\r\n   *\r\n   * @param type  Event type\r\n   * @return Dispatch?\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_shouldDispatch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type) {\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      var count = this._disabled[type];\n\n      if (!$type.isNumber(count)) {\n        return this._enabled;\n      } else {\n        if (count <= 1) {\n          delete this._disabled[type];\n        } else {\n          --this._disabled[type];\n        }\n\n        return false;\n      }\n    }\n  });\n  /**\r\n   * [_eachListener description]\r\n   *\r\n   * All of this extra code is needed when a listener is removed while iterating\r\n   *\r\n   * @todo Description\r\n   * @param fn [description]\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_eachListener\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (fn) {\n      var _this = this;\n\n      ++this._iterating;\n\n      try {\n        $array.each(this._listeners, fn);\n      } finally {\n        --this._iterating; // TODO should this be inside or outside the finally ?\n\n        if (this._iterating === 0 && this._killed.length !== 0) {\n          // Remove killed listeners\n          $array.each(this._killed, function (killed) {\n            _this._removeListener(killed);\n          });\n          this._killed.length = 0;\n        }\n      }\n    }\n  });\n  /**\r\n   * Dispatches an event immediately without waiting for next cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"dispatch\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, event) {\n      if (this._shouldDispatch(type)) {\n        // TODO check if it's faster to use an object of listeners rather than a single big array\n        // TODO if the function throws, maybe it should keep going ?\n        this._eachListener(function (listener) {\n          if (!listener.killed && (listener.type === null || listener.type === type)) {\n            listener.dispatch(type, event);\n          }\n        });\n      }\n    }\n  });\n  /**\r\n   * Shelves the event to be dispatched within next update cycle.\r\n   *\r\n   * @param type   Event type\r\n   * @param event  Event object\r\n   * @todo automatically add in type and target properties if they are missing\r\n   */\n\n  /*public dispatchLater<Key extends keyof T>(type: Key, event: T[Key]): void {\r\n      if (this._shouldDispatch(type)) {\r\n          this._eachListener((listener) => {\r\n              // TODO check if it's faster to use an object of listeners rather than a single big array\r\n              if (!listener.killed && (listener.type === null || listener.type === type)) {\r\n                  // TODO if the function throws, maybe it should keep going ?\r\n                  // TODO dispatch during the update cycle, rather than using whenIdle\r\n                  $async.whenIdle(() => {\r\n                      if (!listener.killed) {\r\n                          listener.dispatch(type, event);\r\n                      }\r\n                  });\r\n              }\r\n          });\r\n      }\r\n  }*/\n\n  /**\r\n   * Creates, catalogs and returns an [[EventListener]].\r\n   *\r\n   * Event listener can be disposed.\r\n   *\r\n   * @param once         Listener's once setting\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @param dispatch\r\n   * @returns An event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"_on\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (once, type, callback, context, shouldClone, dispatch) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      this._removeExistingListener(once, type, callback, context);\n\n      var info = {\n        type: type,\n        callback: callback,\n        context: context,\n        shouldClone: shouldClone,\n        dispatch: dispatch,\n        killed: false,\n        once: once,\n        disposer: new Disposer(function () {\n          info.killed = true;\n\n          _this._removeListener(info);\n        })\n      };\n\n      this._listeners.push(info);\n\n      return info;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on **any** event.\r\n   *\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"onAll\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      return this._on(false, null, callback, context, shouldClone, function (_type, event) {\n        return callback.call(context, event);\n      }).disposer;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on a specific event type.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler whenever series we put\r\n   * event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"on\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      return this._on(false, type, callback, context, shouldClone, function (_type, event) {\n        return callback.call(context, event);\n      }).disposer;\n    }\n  });\n  /**\r\n   * Creates an event listener to be invoked on a specific event type once.\r\n   *\r\n   * Once the event listener is invoked, it is automatically disposed.\r\n   *\r\n   * ```TypeScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   * ```JavaScript\r\n   * button.events.once(\"click\", (ev) => {\r\n   *   console.log(\"Button clicked\");\r\n   * }, this);\r\n   * ```\r\n   *\r\n   * The above will invoke our custom event handler the first time series we\r\n   * put event on is hidden.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   * @param shouldClone  Whether the listener should be copied when the EventDispatcher is copied\r\n   * @returns A disposable event listener\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"once\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context, shouldClone) {\n      if (shouldClone === void 0) {\n        shouldClone = true;\n      }\n\n      var x = this._on(true, type, callback, context, shouldClone, function (_type, event) {\n        x.disposer.dispose();\n        callback.call(context, event);\n      }); // TODO maybe this should return a different Disposer ?\n\n\n      return x.disposer;\n    }\n  });\n  /**\r\n   * Removes the event listener with specific parameters.\r\n   *\r\n   * @param type         Listener's type\r\n   * @param callback     Callback function\r\n   * @param context      Callback context\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"off\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (type, callback, context) {\n      this._removeExistingListener(false, type, callback, context);\n    }\n  });\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(EventDispatcher.prototype, \"copyFrom\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (source) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      if (source === this) {\n        throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n      }\n\n      var disposers = [];\n      $array.each(source._listeners, function (x) {\n        // TODO is this correct ?\n        if (!x.killed && x.shouldClone) {\n          if (x.type === null) {\n            disposers.push(_this.onAll(x.callback, x.context));\n          } else if (x.once) {\n            disposers.push(_this.once(x.type, x.callback, x.context));\n          } else {\n            disposers.push(_this.on(x.type, x.callback, x.context));\n          }\n        }\n      });\n      return new MultiDisposer(disposers);\n    }\n  });\n  return EventDispatcher;\n}();\n\nexport { EventDispatcher };\n/**\r\n * A version of the [[EventDispatcher]] that dispatches events for a specific\r\n * target object.\r\n *\r\n * @ignore\r\n */\n\nvar TargetedEventDispatcher =\n/** @class */\nfunction (_super) {\n  __extends(TargetedEventDispatcher, _super);\n  /**\r\n   * Constructor\r\n   *\r\n   * @param target Event dispatcher target\r\n   */\n\n\n  function TargetedEventDispatcher(target) {\n    var _this = _super.call(this) || this;\n    /**\r\n     * A target object which is originating events using this dispatcher.\r\n     */\n\n\n    Object.defineProperty(_this, \"target\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    _this.target = target;\n    return _this;\n  }\n  /**\r\n   * Copies all dispatcher parameters, including listeners, from another event\r\n   * dispatcher.\r\n   *\r\n   * @param source Source event dispatcher\r\n   * @ignore\r\n   */\n\n\n  Object.defineProperty(TargetedEventDispatcher.prototype, \"copyFrom\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (source) {\n      var _this = this;\n\n      if (this._disposed) {\n        throw new Error(\"EventDispatcher is disposed\");\n      }\n\n      if (source === this) {\n        throw new Error(\"Cannot copyFrom the same TargetedEventDispatcher\");\n      }\n\n      var disposers = [];\n      $array.each(source._listeners, function (x) {\n        // TODO very hacky\n        if (x.context === source.target) {\n          return;\n        } // TODO is this correct ?\n\n\n        if (!x.killed && x.shouldClone) {\n          if (x.type === null) {\n            disposers.push(_this.onAll(x.callback, x.context));\n          } else if (x.once) {\n            disposers.push(_this.once(x.type, x.callback, x.context));\n          } else {\n            disposers.push(_this.on(x.type, x.callback, x.context));\n          }\n        }\n      });\n      return new MultiDisposer(disposers);\n    }\n  });\n  return TargetedEventDispatcher;\n}(EventDispatcher);\n\nexport { TargetedEventDispatcher }; //# sourceMappingURL=EventDispatcher.js.map","map":null,"metadata":{},"sourceType":"module"}