{"ast":null,"code":"import { __extends, __read } from \"tslib\";\nimport { DataItem } from \"../../../core/render/Component\";\nimport { Axis } from \"./Axis\";\nimport { MultiDisposer } from \"../../../core/util/Disposer\";\nimport * as $type from \"../../../core/util/Type\";\nimport * as $array from \"../../../core/util/Array\";\nimport * as $math from \"../../../core/util/Math\";\nimport * as $utils from \"../../../core/util/Utils\";\n/**\r\n * Creates a value axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/value-axis/} for more info\r\n * @important\r\n */\n\nvar ValueAxis =\n/** @class */\nfunction (_super) {\n  __extends(ValueAxis, _super);\n\n  function ValueAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_dirtyExtremes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_dirtySelectionExtremes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_deltaMinMax\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    Object.defineProperty(_this, \"_minReal\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_maxReal\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_baseValue\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 0\n    });\n    Object.defineProperty(_this, \"_syncDp\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(_this, \"_minLogAdjusted\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    return _this;\n  }\n  /**\r\n   * @ignore\r\n   */\n\n\n  Object.defineProperty(ValueAxis.prototype, \"markDirtyExtremes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._dirtyExtremes = true;\n      this.markDirty();\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"markDirtySelectionExtremes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._dirtySelectionExtremes = true;\n      this.markDirty();\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n      this.setPrivateRaw(\"name\", \"value\");\n      this.addTag(\"value\");\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_prepareChildren\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      _super.prototype._prepareChildren.call(this);\n\n      if (this.isDirty(\"syncWithAxis\")) {\n        var previousValue = this._prevSettings.syncWithAxis;\n\n        if (previousValue) {\n          if (this._syncDp) {\n            this._syncDp.dispose();\n          }\n        }\n\n        var syncWithAxis = this.get(\"syncWithAxis\");\n\n        if (syncWithAxis) {\n          this._syncDp = new MultiDisposer([syncWithAxis.onPrivate(\"selectionMinFinal\", function () {\n            _this._dirtySelectionExtremes = true;\n          }), syncWithAxis.onPrivate(\"selectionMaxFinal\", function () {\n            _this._dirtySelectionExtremes = true;\n          })]);\n        }\n      } //if (this._dirtyExtremes || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"maxPrecision\")) {\n\n\n      if (this._sizeDirty || this._dirtyExtremes || this._valuesDirty || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"min\") || this.isDirty(\"max\") || this.isDirty(\"extraMin\") || this.isDirty(\"extraMax\") || this.isDirty(\"logarithmic\") || this.isDirty(\"treatZeroAs\") || this.isDirty(\"baseValue\") || this.isDirty(\"strictMinMax\") || this.isDirty(\"strictMinMaxSelection\") || this.isDirty(\"maxPrecision\") || this.isDirty(\"numberFormat\")) {\n        this._getMinMax();\n\n        this.ghostLabel.set(\"text\", \"\");\n        this._dirtyExtremes = false;\n      }\n\n      if (this._dirtySelectionExtremes && !this._isPanning && this.get(\"autoZoom\", true)) {\n        this._getSelectionMinMax();\n\n        this._dirtySelectionExtremes = false;\n      }\n\n      this._groupData();\n\n      if (this._sizeDirty || this._valuesDirty || this.isDirty(\"start\") || this.isDirty(\"end\") || this.isPrivateDirty(\"min\") || this.isPrivateDirty(\"selectionMax\") || this.isPrivateDirty(\"selectionMin\") || this.isPrivateDirty(\"max\") || this.isPrivateDirty(\"step\") || this.isPrivateDirty(\"width\") || this.isPrivateDirty(\"height\") || this.isDirty(\"logarithmic\")) {\n        this._handleRangeChange();\n\n        this._prepareAxisItems();\n\n        this._updateAxisRanges();\n      }\n\n      this._baseValue = this.baseValue();\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_groupData\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {}\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_formatText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var numberFormat = this.get(\"numberFormat\");\n      var formatter = this.getNumberFormatter();\n      var text = \"\";\n\n      if (numberFormat) {\n        text = formatter.format(value, numberFormat);\n      } else {\n        text = formatter.format(value, undefined, this.getPrivate(\"stepDecimalPlaces\"));\n      }\n\n      return text;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_prepareAxisItems\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        var logarithmic = this.get(\"logarithmic\");\n        var step = this.getPrivate(\"step\");\n        var selectionMin = this.getPrivate(\"selectionMin\");\n        var selectionMax = this.getPrivate(\"selectionMax\") + step;\n        var value = selectionMin - step;\n        var i = 0;\n        var differencePower = 1;\n        var minLog = min;\n\n        if (logarithmic) {\n          value = this._minLogAdjusted;\n\n          if (value < selectionMin) {\n            while (value < selectionMin) {\n              value += step;\n            }\n          }\n\n          minLog = value;\n\n          if (minLog <= 0) {\n            minLog = 1;\n\n            if (step < 1) {\n              minLog = step;\n            }\n          }\n\n          differencePower = Math.log(selectionMax - step) * Math.LOG10E - Math.log(minLog) * Math.LOG10E;\n\n          if (differencePower > 2) {\n            value = Math.pow(10, Math.log(minLog) * Math.LOG10E - 5);\n          }\n        }\n\n        var previous = -Infinity;\n\n        while (value < selectionMax) {\n          var dataItem = void 0;\n\n          if (this.dataItems.length < i + 1) {\n            dataItem = new DataItem(this, undefined, {});\n\n            this._dataItems.push(dataItem);\n\n            this.processDataItem(dataItem);\n          } else {\n            dataItem = this.dataItems[i];\n          }\n\n          this._createAssets(dataItem, []);\n\n          if (dataItem.isHidden()) {\n            dataItem.show();\n          }\n\n          dataItem.setRaw(\"value\", value);\n          var label = dataItem.get(\"label\");\n\n          if (label) {\n            label.set(\"text\", this._formatText(value));\n          }\n\n          this._prepareDataItem(dataItem);\n\n          if (!logarithmic) {\n            value += step;\n          } else {\n            if (differencePower > 2) {\n              value = Math.pow(10, Math.log(minLog) * Math.LOG10E + i - 5);\n            } else {\n              value += step;\n            }\n          }\n\n          if (previous == value) {\n            break;\n          }\n\n          var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E));\n\n          if (stepPower < 1) {\n            // exponent is less then 1 too. Count decimals of exponent\n            var decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 2; // round value to avoid floating point issues\n\n            value = $math.round(value, decCount);\n          }\n\n          i++;\n          previous = value;\n        }\n\n        for (var j = i; j < this.dataItems.length; j++) {\n          this.dataItems[j].hide();\n        }\n\n        $array.each(this.series, function (series) {\n          if (series.inited) {\n            series._markDirtyAxes();\n          }\n        });\n\n        this._updateGhost();\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_prepareDataItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, count) {\n      var renderer = this.get(\"renderer\");\n      var value = dataItem.get(\"value\");\n      var endValue = dataItem.get(\"endValue\");\n      var position = this.valueToPosition(value);\n      var endPosition = position;\n      var fillEndPosition = this.valueToPosition(value + this.getPrivate(\"step\"));\n\n      if ($type.isNumber(endValue)) {\n        endPosition = this.valueToPosition(endValue);\n        fillEndPosition = endPosition;\n      }\n\n      if (dataItem.get(\"isRange\")) {\n        if (endValue == null) {\n          fillEndPosition = position;\n        }\n      }\n\n      renderer.updateLabel(dataItem.get(\"label\"), position, endPosition, count);\n      var grid = dataItem.get(\"grid\");\n      renderer.updateGrid(grid, position, endPosition);\n\n      if (grid) {\n        if (value == this.get(\"baseValue\", 0)) {\n          grid.addTag(\"base\");\n\n          grid._applyThemes();\n        } else if (grid.hasTag(\"base\")) {\n          grid.removeTag(\"base\");\n\n          grid._applyThemes();\n        }\n      }\n\n      renderer.updateTick(dataItem.get(\"tick\"), position, endPosition, count);\n      renderer.updateFill(dataItem.get(\"axisFill\"), position, fillEndPosition);\n\n      this._processBullet(dataItem);\n\n      renderer.updateBullet(dataItem.get(\"bullet\"), position, endPosition);\n\n      if (!dataItem.get(\"isRange\")) {\n        var fillRule = this.get(\"fillRule\");\n\n        if (fillRule) {\n          fillRule(dataItem);\n        }\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_handleRangeChange\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var selectionMin = this.positionToValue(this.get(\"start\", 0));\n      var selectionMax = this.positionToValue(this.get(\"end\", 1));\n      var gridCount = this.get(\"renderer\").gridCount();\n\n      var minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n\n      var stepDecimalPlaces = $utils.decimalPlaces(minMaxStep.step);\n      this.setPrivateRaw(\"stepDecimalPlaces\", stepDecimalPlaces);\n      selectionMin = $math.round(selectionMin, stepDecimalPlaces);\n      selectionMax = $math.round(selectionMax, stepDecimalPlaces);\n      minMaxStep = this._adjustMinMax(selectionMin, selectionMax, gridCount, true);\n      var step = minMaxStep.step;\n      selectionMin = minMaxStep.min;\n      selectionMax = minMaxStep.max;\n\n      if (this.getPrivate(\"selectionMin\") !== selectionMin || this.getPrivate(\"selectionMax\") !== selectionMax || this.getPrivate(\"step\") !== step) {\n        // do not change to setPrivate, will cause SO\n        this.setPrivateRaw(\"selectionMin\", selectionMin);\n        this.setPrivateRaw(\"selectionMax\", selectionMax);\n        this.setPrivateRaw(\"step\", step);\n      }\n    }\n  });\n  /**\r\n   * Converts a relative position to a corresponding numeric value from axis\r\n   * scale.\r\n   *\r\n   * @param   position  Relative position\r\n   * @return            Value\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"positionToValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if (!this.get(\"logarithmic\")) {\n        return position * (max - min) + min;\n      } else {\n        return Math.pow(Math.E, (position * (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E) + Math.log(min) * Math.LOG10E) / Math.LOG10E);\n      }\n    }\n  });\n  /**\r\n   * Convers value to a relative position on axis.\r\n   *\r\n   * @param   value  Value\r\n   * @return         Relative position\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"valueToPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var min = this.getPrivate(\"min\");\n      var max = this.getPrivate(\"max\");\n\n      if (!this.get(\"logarithmic\")) {\n        return (value - min) / (max - min);\n      } else {\n        if (value <= 0) {\n          var treatZeroAs = this.get(\"treatZeroAs\");\n\n          if ($type.isNumber(treatZeroAs)) {\n            value = treatZeroAs;\n          }\n        }\n\n        return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E);\n      }\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"valueToFinalPosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var min = this.getPrivate(\"minFinal\");\n      var max = this.getPrivate(\"maxFinal\");\n\n      if (!this.get(\"logarithmic\")) {\n        return (value - min) / (max - min);\n      } else {\n        if (value <= 0) {\n          var treatZeroAs = this.get(\"treatZeroAs\");\n\n          if ($type.isNumber(treatZeroAs)) {\n            value = treatZeroAs;\n          }\n        }\n\n        return (Math.log(value) * Math.LOG10E - Math.log(min) * Math.LOG10E) / (Math.log(max) * Math.LOG10E - Math.log(min) * Math.LOG10E);\n      }\n    }\n  });\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific value.\r\n   *\r\n   * @param   value     Numeric value\r\n   * @param   location  Location\r\n   * @param   baseValue Base value\r\n   * @return            X coordinate\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"getX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, location, baseValue) {\n      value = baseValue + (value - baseValue) * location;\n      var position = this.valueToPosition(value);\n      return this._settings.renderer.positionToCoordinate(position);\n    }\n  });\n  /**\r\n   * Returns X coordinate in pixels corresponding to specific value.\r\n   *\r\n   * @param   value     Numeric value\r\n   * @param   location  Location\r\n   * @param   baseValue Base value\r\n   * @return            X coordinate\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"getY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value, location, baseValue) {\n      value = baseValue + (value - baseValue) * location;\n      var position = this.valueToPosition(value);\n      return this._settings.renderer.positionToCoordinate(position);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"getDataItemCoordinateX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, _cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionX(dataItem, field, _cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"getDataItemPositionX\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, _cellLocation, axisLocation) {\n      var value = dataItem.get(field);\n      var stackToItem = dataItem.get(\"stackToItemX\");\n\n      if (stackToItem) {\n        var series = dataItem.component;\n        value = value * axisLocation + series.getStackedXValueWorking(dataItem, field);\n      } else {\n        value = this._baseValue + (value - this._baseValue) * axisLocation;\n      }\n\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"getDataItemCoordinateY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, _cellLocation, axisLocation) {\n      return this._settings.renderer.positionToCoordinate(this.getDataItemPositionY(dataItem, field, _cellLocation, axisLocation));\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"getDataItemPositionY\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (dataItem, field, _cellLocation, axisLocation) {\n      var value = dataItem.get(field);\n      var stackToItem = dataItem.get(\"stackToItemY\");\n\n      if (stackToItem) {\n        var series = dataItem.component;\n        value = value * axisLocation + series.getStackedYValueWorking(dataItem, field);\n      } else {\n        value = this._baseValue + (value - this._baseValue) * axisLocation;\n      }\n\n      return this.valueToPosition(value);\n    }\n  });\n  /**\r\n   * Returns relative position of axis' `baseValue`.\r\n   *\r\n   * @return  Base value position\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"basePosition\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      return this.valueToPosition(this.baseValue());\n    }\n  });\n  /**\r\n   * Base value of the [[ValueAxis]], which determines positive and negative\r\n   * values.\r\n   *\r\n   * @return Base value\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"baseValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var min = Math.min(this.getPrivate(\"minFinal\", -Infinity), this.getPrivate(\"selectionMin\", -Infinity));\n      var max = Math.max(this.getPrivate(\"maxFinal\", Infinity), this.getPrivate(\"selectionMax\", Infinity));\n      var baseValue = this.get(\"baseValue\", 0);\n\n      if (baseValue < min) {\n        baseValue = min;\n      }\n\n      if (baseValue > max) {\n        baseValue = max;\n      }\n\n      return baseValue;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"cellEndValue\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      return value;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"fixSmallStep\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (step) {\n      // happens because of floating point error\n      if (1 + step === 1) {\n        step *= 2;\n        return this.fixSmallStep(step);\n      }\n\n      return step;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_fixMin\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min) {\n      return min;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_fixMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (max) {\n      return max;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_calculateTotals\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      if (this.get(\"calculateTotals\")) {\n        var series = this.series[0];\n\n        if (series) {\n          var startIndex = series.startIndex();\n\n          if (series.dataItems.length > 0) {\n            if (startIndex > 0) {\n              startIndex--;\n            }\n\n            var endIndex = series.endIndex();\n\n            if (endIndex < series.dataItems.length) {\n              endIndex++;\n            }\n\n            var field_1;\n            var vc_1;\n\n            if (series.get(\"yAxis\") == this) {\n              field_1 = \"valueY\";\n              vc_1 = \"vcy\";\n            } else if (series.get(\"xAxis\") == this) {\n              field_1 = \"valueX\";\n              vc_1 = \"vcx\";\n            }\n\n            var fieldWorking_1 = field_1 + \"Working\";\n\n            if (field_1) {\n              var _loop_1 = function (i) {\n                var sum = 0;\n                var total = 0;\n                $array.each(this_1.series, function (series) {\n                  if (!series.get(\"excludeFromTotal\")) {\n                    var dataItem = series.dataItems[i];\n\n                    if (dataItem) {\n                      var value = dataItem.get(fieldWorking_1) * series.get(vc_1);\n\n                      if (!$type.isNaN(value)) {\n                        sum += value;\n                        total += Math.abs(value);\n                      }\n                    }\n                  }\n                });\n                $array.each(this_1.series, function (series) {\n                  if (!series.get(\"excludeFromTotal\")) {\n                    var dataItem = series.dataItems[i];\n\n                    if (dataItem) {\n                      var value = dataItem.get(fieldWorking_1) * series.get(vc_1);\n\n                      if (!$type.isNaN(value)) {\n                        dataItem.set(field_1 + \"Total\", total);\n                        dataItem.set(field_1 + \"Sum\", sum);\n                        dataItem.set(field_1 + \"TotalPercent\", value / total * 100);\n                      }\n                    }\n                  }\n                });\n              };\n\n              var this_1 = this;\n\n              for (var i = startIndex; i < endIndex; i++) {\n                _loop_1(i);\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_getSelectionMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _a;\n\n      var _this = this;\n\n      var min = this.getPrivate(\"minFinal\");\n      var max = this.getPrivate(\"maxFinal\");\n      var minDefined = this.get(\"min\");\n      var maxDefined = this.get(\"max\");\n      var extraMin = this.get(\"extraMin\", 0);\n      var extraMax = this.get(\"extraMax\", 0);\n\n      if (this.get(\"logarithmic\")) {\n        if (this.get(\"extraMin\") == null) {\n          extraMin = 0.1;\n        }\n\n        if (this.get(\"extraMax\") == null) {\n          extraMax = 0.2;\n        }\n      }\n\n      var gridCount = this.get(\"renderer\").gridCount();\n      var selectionStrictMinMax = this.get(\"strictMinMaxSelection\");\n      var strictMinMax = this.get(\"strictMinMax\");\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        var selectionMin_1 = max;\n        var selectionMax_1 = min;\n        $array.each(this.series, function (series) {\n          if (!series.get(\"ignoreMinMax\")) {\n            var seriesMin = void 0;\n            var seriesMax = void 0;\n            var outOfSelection = series.getPrivate(\"outOfSelection\");\n\n            if (series.get(\"xAxis\") === _this) {\n              if (!outOfSelection) {\n                seriesMin = series.getPrivate(\"selectionMinX\", series.getPrivate(\"minX\"));\n                seriesMax = series.getPrivate(\"selectionMaxX\", series.getPrivate(\"maxX\"));\n              }\n            } else if (series.get(\"yAxis\") === _this) {\n              if (!outOfSelection) {\n                seriesMin = series.getPrivate(\"selectionMinY\", series.getPrivate(\"minY\"));\n                seriesMax = series.getPrivate(\"selectionMaxY\", series.getPrivate(\"maxY\"));\n              }\n            }\n\n            if (!series.isHidden() && !series.isShowing()) {\n              if ($type.isNumber(seriesMin)) {\n                selectionMin_1 = Math.min(selectionMin_1, seriesMin);\n              }\n\n              if ($type.isNumber(seriesMax)) {\n                selectionMax_1 = Math.max(selectionMax_1, seriesMax);\n              }\n            }\n          }\n        });\n        this.axisRanges.each(function (range) {\n          if (range.get(\"affectsMinMax\")) {\n            var value = range.get(\"value\");\n\n            if (value != null) {\n              selectionMin_1 = Math.min(selectionMin_1, value);\n              selectionMax_1 = Math.max(selectionMax_1, value);\n            }\n\n            value = range.get(\"endValue\");\n\n            if (value != null) {\n              selectionMin_1 = Math.min(selectionMin_1, value);\n              selectionMax_1 = Math.max(selectionMax_1, value);\n            }\n          }\n        });\n\n        if (selectionMin_1 > selectionMax_1) {\n          _a = __read([selectionMax_1, selectionMin_1], 2), selectionMin_1 = _a[0], selectionMax_1 = _a[1];\n        }\n\n        if ($type.isNumber(minDefined)) {\n          if (strictMinMax) {\n            selectionMin_1 = minDefined;\n          } else {\n            selectionMin_1 = min;\n          }\n        } else if (strictMinMax) {\n          if ($type.isNumber(this._minReal)) {\n            selectionMin_1 = this._minReal;\n          }\n        }\n\n        if ($type.isNumber(maxDefined)) {\n          if (strictMinMax) {\n            selectionMax_1 = maxDefined;\n          } else {\n            selectionMax_1 = max;\n          }\n        } else if (strictMinMax) {\n          if ($type.isNumber(this._maxReal)) {\n            selectionMax_1 = this._maxReal;\n          }\n        }\n\n        if (selectionMin_1 === selectionMax_1) {\n          selectionMin_1 -= this._deltaMinMax;\n          selectionMax_1 += this._deltaMinMax;\n\n          var minMaxStep2 = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount, strictMinMax);\n\n          selectionMin_1 = minMaxStep2.min;\n          selectionMax_1 = minMaxStep2.max;\n        }\n\n        var selectionMinReal = selectionMin_1;\n        var selectionMaxReal = selectionMax_1;\n        selectionMin_1 -= (selectionMax_1 - selectionMin_1) * extraMin;\n        selectionMax_1 += (selectionMax_1 - selectionMin_1) * extraMax;\n\n        var minMaxStep = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount);\n\n        selectionMin_1 = minMaxStep.min;\n        selectionMax_1 = minMaxStep.max;\n        selectionMin_1 = $math.fitToRange(selectionMin_1, min, max);\n        selectionMax_1 = $math.fitToRange(selectionMax_1, min, max); // do it for the second time !important\t\t\t\n\n        minMaxStep = this._adjustMinMax(selectionMin_1, selectionMax_1, gridCount, true);\n\n        if (!strictMinMax) {\n          selectionMin_1 = minMaxStep.min;\n          selectionMax_1 = minMaxStep.max;\n        }\n\n        var syncWithAxis = this.get(\"syncWithAxis\");\n\n        if (syncWithAxis) {\n          minMaxStep = this._syncAxes(selectionMin_1, selectionMax_1, minMaxStep.step, syncWithAxis.getPrivate(\"selectionMinFinal\", syncWithAxis.getPrivate(\"minFinal\", 0)), syncWithAxis.getPrivate(\"selectionMaxFinal\", syncWithAxis.getPrivate(\"maxFinal\", 1)), syncWithAxis.getPrivate(\"selectionStepFinal\", syncWithAxis.getPrivate(\"step\", 1)));\n          selectionMin_1 = minMaxStep.min;\n          selectionMax_1 = minMaxStep.max;\n        }\n\n        if (strictMinMax) {\n          if ($type.isNumber(minDefined)) {\n            selectionMin_1 = Math.max(selectionMin_1, minDefined);\n          }\n\n          if ($type.isNumber(maxDefined)) {\n            selectionMax_1 = Math.min(selectionMax_1, maxDefined);\n          }\n        }\n\n        if (selectionStrictMinMax) {\n          selectionMin_1 = selectionMinReal - (selectionMax_1 - selectionMin_1) * extraMin;\n          selectionMax_1 = selectionMaxReal + (selectionMax_1 - selectionMin_1) * extraMax;\n        }\n\n        if (this.get(\"logarithmic\")) {\n          if (selectionMin_1 <= 0) {\n            selectionMin_1 = selectionMinReal * (1 - Math.min(extraMin, 0.99));\n          }\n\n          if (selectionMin_1 < min) {\n            selectionMin_1 = min;\n          }\n\n          if (selectionMax_1 > max) {\n            selectionMax_1 = max;\n          }\n        }\n\n        var len = Math.min(20, Math.ceil(Math.log(this.getPrivate(\"maxZoomFactor\", 100) + 1) / Math.LN10) + 2);\n        var start = $math.round(this.valueToFinalPosition(selectionMin_1), len);\n        var end = $math.round(this.valueToFinalPosition(selectionMax_1), len);\n        this.setPrivateRaw(\"selectionMinFinal\", selectionMin_1);\n        this.setPrivateRaw(\"selectionMaxFinal\", selectionMax_1);\n        this.setPrivateRaw(\"selectionStepFinal\", minMaxStep.step);\n        this.zoom(start, end);\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_getMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      var _this = this;\n\n      var minDefined = this.get(\"min\");\n      var maxDefined = this.get(\"max\");\n      var min = Infinity;\n      var max = -Infinity;\n      var extraMin = this.get(\"extraMin\", 0);\n      var extraMax = this.get(\"extraMax\", 0);\n\n      if (this.get(\"logarithmic\")) {\n        if (this.get(\"extraMin\") == null) {\n          extraMin = 0.1;\n        }\n\n        if (this.get(\"extraMax\") == null) {\n          extraMax = 0.2;\n        }\n      }\n\n      var minDiff = Infinity;\n      $array.each(this.series, function (series) {\n        if (!series.get(\"ignoreMinMax\")) {\n          var seriesMin = void 0;\n          var seriesMax = void 0;\n\n          if (series.get(\"xAxis\") === _this) {\n            seriesMin = series.getPrivate(\"minX\");\n            seriesMax = series.getPrivate(\"maxX\");\n          } else if (series.get(\"yAxis\") === _this) {\n            seriesMin = series.getPrivate(\"minY\");\n            seriesMax = series.getPrivate(\"maxY\");\n          }\n\n          if ($type.isNumber(seriesMin) && $type.isNumber(seriesMax)) {\n            min = Math.min(min, seriesMin);\n            max = Math.max(max, seriesMax);\n            var diff = seriesMax - seriesMin;\n\n            if (diff <= 0) {\n              diff = Math.abs(seriesMax / 100);\n            }\n\n            if (diff < minDiff) {\n              minDiff = diff;\n            }\n          }\n        }\n      });\n      this.axisRanges.each(function (range) {\n        if (range.get(\"affectsMinMax\")) {\n          var value = range.get(\"value\");\n\n          if (value != null) {\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n          }\n\n          value = range.get(\"endValue\");\n\n          if (value != null) {\n            min = Math.min(min, value);\n            max = Math.max(max, value);\n          }\n        }\n      });\n\n      if (this.get(\"logarithmic\")) {\n        var treatZeroAs = this.get(\"treatZeroAs\");\n\n        if ($type.isNumber(treatZeroAs)) {\n          if (min <= 0) {\n            min = treatZeroAs;\n          }\n        }\n\n        if (min <= 0) {\n          new Error(\"Logarithmic value axis can not have values <= 0.\");\n        }\n      }\n\n      if (min === 0 && max === 0) {\n        max = 0.9;\n        min = -0.9;\n      }\n\n      if ($type.isNumber(minDefined)) {\n        min = minDefined;\n      }\n\n      if ($type.isNumber(maxDefined)) {\n        max = maxDefined;\n      } // meaning no min/max found on series/ranges and no min/max was defined\n\n\n      if (min === Infinity || max === -Infinity) {\n        return;\n      }\n\n      var initialMin = min;\n      var initialMax = max; // adapter\n\n      var minAdapted = this.adapters.fold(\"min\", min);\n      var maxAdapted = this.adapters.fold(\"max\", max);\n\n      if ($type.isNumber(minAdapted)) {\n        min = minAdapted;\n      }\n\n      if ($type.isNumber(maxAdapted)) {\n        max = maxAdapted;\n      } // DateAxis does some magic here\n\n\n      min = this._fixMin(min);\n      max = this._fixMax(max); // this happens if starLocation and endLocation are 0.5 and DateAxis has only one date\t\t\n\n      if (max - min <= 1 / Math.pow(10, 15)) {\n        if (max - min !== 0) {\n          this._deltaMinMax = (max - min) / 2;\n        } else {\n          this._getDelta(max);\n        }\n\n        min -= this._deltaMinMax;\n        max += this._deltaMinMax;\n      } // add extras\n\n\n      min -= (max - min) * extraMin;\n      max += (max - min) * extraMax;\n\n      if (this.get(\"logarithmic\")) {\n        // don't let min go below 0 if real min is >= 0\n        if (min < 0 && initialMin >= 0) {\n          min = 0;\n        } // don't let max go above 0 if real max is <= 0\n\n\n        if (max > 0 && initialMax <= 0) {\n          max = 0;\n        }\n      }\n\n      this._minReal = min;\n      this._maxReal = max;\n      var strictMinMax = this.get(\"strictMinMax\");\n      var strictMinMaxSelection = this.get(\"strictMinMaxSelection\", false);\n\n      if (strictMinMaxSelection) {\n        strictMinMax = strictMinMaxSelection;\n      }\n\n      var strict = strictMinMax;\n\n      if ($type.isNumber(maxDefined)) {\n        strict = true;\n      }\n\n      var gridCount = this.get(\"renderer\").gridCount();\n\n      var minMaxStep = this._adjustMinMax(min, max, gridCount, strict);\n\n      min = minMaxStep.min;\n      max = minMaxStep.max; // do it for the second time with strict true (importat!)\n\n      minMaxStep = this._adjustMinMax(min, max, gridCount, true);\n      min = minMaxStep.min;\n      max = minMaxStep.max; // return min max if strict\n\n      if (strictMinMax) {\n        if ($type.isNumber(minDefined)) {\n          min = minDefined;\n        } else {\n          min = this._minReal;\n        }\n\n        if ($type.isNumber(maxDefined)) {\n          max = maxDefined;\n        } else {\n          max = this._maxReal;\n        }\n\n        if (max - min <= 0.00000001) {\n          min -= this._deltaMinMax;\n          max += this._deltaMinMax;\n        }\n\n        min -= (max - min) * extraMin;\n        max += (max - min) * extraMax;\n      }\n\n      minAdapted = this.adapters.fold(\"min\", min);\n      maxAdapted = this.adapters.fold(\"max\", max);\n\n      if ($type.isNumber(minAdapted)) {\n        min = minAdapted;\n      }\n\n      if ($type.isNumber(maxAdapted)) {\n        max = maxAdapted;\n      }\n\n      if (minDiff == Infinity) {\n        minDiff = max - min;\n      } // this is to avoid floating point number error\n\n\n      var decCount = Math.round(Math.abs(Math.log(Math.abs(max - min)) * Math.LOG10E)) + 5;\n      min = $math.round(min, decCount);\n      max = $math.round(max, decCount);\n      var syncWithAxis = this.get(\"syncWithAxis\");\n\n      if (syncWithAxis) {\n        minMaxStep = this._syncAxes(min, max, minMaxStep.step, syncWithAxis.getPrivate(\"minFinal\", syncWithAxis.getPrivate(\"min\", 0)), syncWithAxis.getPrivate(\"maxFinal\", syncWithAxis.getPrivate(\"max\", 1)), syncWithAxis.getPrivate(\"step\", 1));\n        min = minMaxStep.min;\n        max = minMaxStep.max;\n      }\n\n      this.setPrivateRaw(\"maxZoomFactor\", Math.max(1, Math.ceil((max - min) / minDiff * this.get(\"maxZoomFactor\", 100))));\n\n      this._fixZoomFactor();\n\n      if (this.get(\"logarithmic\")) {\n        this._minLogAdjusted = min;\n        min = this._minReal;\n        max = this._maxReal;\n\n        if (min <= 0) {\n          min = initialMin * (1 - Math.min(extraMin, 0.99));\n        }\n      }\n\n      if ($type.isNumber(min) && $type.isNumber(max)) {\n        if (this.getPrivate(\"minFinal\") !== min || this.getPrivate(\"maxFinal\") !== max) {\n          this.setPrivate(\"minFinal\", min);\n          this.setPrivate(\"maxFinal\", max);\n\n          this._saveMinMax(min, max);\n\n          var duration = this.get(\"interpolationDuration\", 0);\n          var easing = this.get(\"interpolationEasing\");\n          this.animatePrivate({\n            key: \"min\",\n            to: min,\n            duration: duration,\n            easing: easing\n          });\n          this.animatePrivate({\n            key: \"max\",\n            to: max,\n            duration: duration,\n            easing: easing\n          });\n        }\n      }\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_fixZoomFactor\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {}\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_getDelta\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (max) {\n      // the number by which we need to raise 10 to get difference\n      var exponent = Math.log(Math.abs(max)) * Math.LOG10E; // here we find a number which is power of 10 and has the same count of numbers as difference has\n\n      var power = Math.pow(10, Math.floor(exponent)); // reduce this number by 10 times\n\n      power = power / 10;\n      this._deltaMinMax = power;\n    }\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_saveMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (_min, _max) {}\n  });\n  Object.defineProperty(ValueAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, strictMode) {\n      // will fail if 0\n      if (gridCount <= 1) {\n        gridCount = 1;\n      }\n\n      gridCount = Math.round(gridCount);\n      var initialMin = min;\n      var initialMax = max;\n      var difference = max - min; // in case min and max is the same, use max\n\n      if (difference === 0) {\n        difference = Math.abs(max);\n      } // the number by which we need to raise 10 to get difference\n\n\n      var exponent = Math.log(Math.abs(difference)) * Math.LOG10E; // here we find a number which is power of 10 and has the same count of numbers as difference has\n\n      var power = Math.pow(10, Math.floor(exponent)); // reduce this number by 10 times\n\n      power = power / 10;\n      var extra = power;\n\n      if (strictMode) {\n        extra = 0;\n      } // round down min\n\n\n      if (strictMode) {\n        min = Math.floor(min / power) * power; // round up max\n\n        max = Math.ceil(max / power) * power;\n      } else {\n        min = Math.ceil(min / power) * power - extra; // round up max\n\n        max = Math.floor(max / power) * power + extra;\n      } // don't let min go below 0 if real min is >= 0\n\n\n      if (min < 0 && initialMin >= 0) {\n        min = 0;\n      } // don't let max go above 0 if real max is <= 0\n\n\n      if (max > 0 && initialMax <= 0) {\n        max = 0;\n      }\n\n      exponent = Math.log(Math.abs(difference)) * Math.LOG10E;\n      power = Math.pow(10, Math.floor(exponent));\n      power = power / 100; // used to be 10 in v4, but this caused issue that there could be limited number of grids with even very small minGridDistance\n      // approximate difference between two grid lines\n\n      var step = Math.ceil(difference / gridCount / power) * power;\n      var stepPower = Math.pow(10, Math.floor(Math.log(Math.abs(step)) * Math.LOG10E)); // the step should divide by  2, 5, and 10.\n\n      var stepDivisor = Math.ceil(step / stepPower); // number 0 - 10\n\n      if (stepDivisor > 5) {\n        stepDivisor = 10;\n      } else if (stepDivisor <= 5 && stepDivisor > 2) {\n        stepDivisor = 5;\n      } // now get real step\n\n\n      step = Math.ceil(step / (stepPower * stepDivisor)) * stepPower * stepDivisor;\n      var maxPrecision = this.get(\"maxPrecision\");\n\n      if ($type.isNumber(maxPrecision)) {\n        var ceiledStep = $math.ceil(step, maxPrecision);\n\n        if (maxPrecision < Number.MAX_VALUE && step !== ceiledStep) {\n          step = ceiledStep;\n        }\n      }\n\n      var decCount = 0; // in case numbers are smaller than 1\n\n      if (stepPower < 1) {\n        // exponent is less then 1 too. Count decimals of exponent\n        decCount = Math.round(Math.abs(Math.log(Math.abs(stepPower)) * Math.LOG10E)) + 1; // round step\n\n        step = $math.round(step, decCount);\n      } // final min and max\n\n\n      var minCount = Math.floor(min / step);\n      min = $math.round(step * minCount, decCount);\n      var maxCount;\n\n      if (!strictMode) {\n        maxCount = Math.ceil(max / step);\n      } else {\n        maxCount = Math.floor(max / step);\n      }\n\n      if (maxCount === minCount) {\n        maxCount++;\n      }\n\n      max = $math.round(step * maxCount, decCount);\n\n      if (max < initialMax) {\n        max = max + step;\n      }\n\n      if (min > initialMin) {\n        min = min - step;\n      }\n\n      step = this.fixSmallStep(step);\n      return {\n        min: min,\n        max: max,\n        step: step\n      };\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var numberFormat = this.get(\"tooltipNumberFormat\", this.get(\"numberFormat\"));\n      var formatter = this.getNumberFormatter();\n      var extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n      var decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n      var value = $math.round(this.positionToValue(position), decimals);\n\n      if (numberFormat) {\n        return formatter.format(value, numberFormat);\n      } else {\n        return formatter.format(value, undefined, decimals); //label.set(\"text\", this.getNumberFormatter().format(value, undefined, this.getPrivate(\"stepDecimalPlaces\")));\n      } // //@todo number formatter + tag\n      // return $math.round(this.positionToValue(position), this.getPrivate(\"stepDecimalPlaces\")).toString();\n\n    }\n  });\n  /**\r\n   * Returns a data item from series that is closest to the `position`.\r\n   *\r\n   * @param   series    Series\r\n   * @param   position  Relative position\r\n   * @return            Data item\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"getSeriesItem\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (series, position) {\n      var fieldName = this.getPrivate(\"name\") + this.get(\"renderer\").getPrivate(\"letter\");\n      var value = this.positionToValue(position);\n      var index = undefined;\n      var oldDiff;\n      $array.each(series.dataItems, function (dataItem, i) {\n        var diff = Math.abs(dataItem.get(fieldName) - value);\n\n        if (index === undefined || diff < oldDiff) {\n          index = i;\n          oldDiff = diff;\n        }\n      });\n\n      if (index != null) {\n        return series.dataItems[index];\n      }\n    }\n  });\n  /**\r\n   * Zooms the axis to specific `start` and `end` values.\r\n   *\r\n   * Optional `duration` specifies duration of zoom animation in milliseconds.\r\n   *\r\n   * @param  start     Start value\r\n   * @param  end       End value\r\n   * @param  duration  Duration in milliseconds\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"zoomToValues\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (start, end, duration) {\n      var min = this.getPrivate(\"minFinal\", 0);\n      var max = this.getPrivate(\"maxFinal\", 0);\n\n      if (this.getPrivate(\"min\") != null && this.getPrivate(\"max\") != null) {\n        this.zoom((start - min) / (max - min), (end - min) / (max - min), duration);\n      }\n    }\n  });\n  /**\r\n   * Syncs with a target axis.\r\n   *\r\n   * @param  min  Min\r\n   * @param  max  Max\r\n   * @param  step Step\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"_syncAxes\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, step, syncMin, syncMax, syncStep) {\n      var axis = this.get(\"syncWithAxis\");\n\n      if (axis) {\n        var count = Math.round(syncMax - syncMin) / syncStep;\n        var currentCount = Math.round((max - min) / step);\n        var gridCount = this.get(\"renderer\").gridCount();\n\n        if ($type.isNumber(count) && $type.isNumber(currentCount)) {\n          var synced = false;\n          var c = 0;\n          var diff = (max - min) * 0.01;\n          var omin = min;\n          var omax = max;\n          var ostep = step;\n\n          while (synced != true) {\n            synced = this._checkSync(omin, omax, ostep, count);\n            c++;\n\n            if (c > 500) {\n              synced = true;\n            }\n\n            if (!synced) {\n              if (c / 3 == Math.round(c / 3)) {\n                omin = min - diff * c;\n\n                if (min >= 0 && omin < 0) {\n                  omin = 0;\n                }\n              } else {\n                omax = max + diff * c;\n\n                if (omax <= 0 && omax > 0) {\n                  omax = 0;\n                }\n              }\n\n              var minMaxStep = this._adjustMinMax(omin, omax, gridCount, true);\n\n              omin = minMaxStep.min;\n              omax = minMaxStep.max;\n              ostep = minMaxStep.step;\n            } else {\n              min = omin;\n              max = omax;\n              step = ostep;\n            }\n          }\n        }\n      }\n\n      return {\n        min: min,\n        max: max,\n        step: step\n      };\n    }\n  });\n  /**\r\n   * Returns `true` if axis needs to be resunced with some other axis.\r\n   */\n\n  Object.defineProperty(ValueAxis.prototype, \"_checkSync\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, step, count) {\n      var currentCount = (max - min) / step;\n\n      for (var i = 1; i < count; i++) {\n        if ($math.round(currentCount / i, 1) == count || currentCount * i == count) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  });\n  Object.defineProperty(ValueAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"ValueAxis\"\n  });\n  Object.defineProperty(ValueAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: Axis.classNames.concat([ValueAxis.className])\n  });\n  return ValueAxis;\n}(Axis);\n\nexport { ValueAxis }; //# sourceMappingURL=ValueAxis.js.map","map":null,"metadata":{},"sourceType":"module"}