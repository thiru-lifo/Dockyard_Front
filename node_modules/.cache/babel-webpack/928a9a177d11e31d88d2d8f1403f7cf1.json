{"ast":null,"code":"import * as $type from \"./Type\";\nimport * as $object from \"./Object\";\n/**\r\n * Tool to parse JSON string into structured data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\r\n * @important\r\n */\n\nvar JSONParser =\n/** @class */\nfunction () {\n  function JSONParser() {}\n  /**\r\n   * Parses JSON string.\r\n   *\r\n   * @param   input    JSON\r\n   * @param   options  Options\r\n   * @return           Data\r\n   */\n\n\n  Object.defineProperty(JSONParser, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (input, options) {\n      options = this._applyDefaults(options);\n\n      try {\n        if ($type.isString(input)) {\n          var data = JSON.parse(input);\n\n          if (options.reverse && $type.isArray(data)) {\n            data.reverse();\n          }\n\n          return data;\n        } else if ($type.isArray(input) || $type.isObject(input)) {\n          return input;\n        } else {\n          throw \"Unable to parse JSON data\";\n        }\n      } catch (e) {\n        return undefined;\n      }\n    }\n  });\n  Object.defineProperty(JSONParser, \"_applyDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (options) {\n      var normalized = {};\n      var defaults = {\n        reverse: false\n      };\n\n      if (!options) {\n        options = {};\n      }\n\n      $object.each(defaults, function (key, val) {\n        normalized[key] = options[key] || val;\n      });\n      return normalized;\n    }\n  });\n  return JSONParser;\n}();\n\nexport { JSONParser };\n/**\r\n * Tool to parse JSON string into structured data.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/concepts/data/#Parsing} for more info\r\n * @important\r\n */\n\nvar CSVParser =\n/** @class */\nfunction () {\n  function CSVParser() {}\n  /**\r\n   * Parses CSV string.\r\n   *\r\n   * @param   input    CSV\r\n   * @param   options  Options\r\n   * @return           Data\r\n   */\n\n\n  Object.defineProperty(CSVParser, \"parse\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (input, options) {\n      options = this._applyDefaults(options); // Get CSV data as array\n\n      var data = this.CSVToArray(input, options.delimiter); // Init resuling array\n\n      var res = [],\n          cols = [],\n          col,\n          i; // Skip rows\n\n      for (i = 0; i < options.skipRows; i++) {\n        data.shift();\n      } // First row holds column names?\n\n\n      if (options.useColumnNames) {\n        cols = data.shift(); // Normalize column names\n\n        for (var x = 0; x < cols.length; x++) {\n          // trim\n          col = cols[x] != null ? cols[x].replace(/^\\s+|\\s+$/gm, \"\") : \"\"; // Check for empty\n\n          if (\"\" === col) {\n            col = \"col\" + x;\n          }\n\n          cols[x] = col;\n        }\n      } // Iterate through the result set\n\n\n      var row;\n\n      while (true) {\n        row = options.reverse ? data.pop() : data.shift();\n\n        if (!row) {\n          break;\n        }\n\n        if (options.skipEmpty && row.length === 1 && row[0] === \"\") {\n          continue;\n        }\n\n        var dataPoint = {};\n\n        for (i = 0; i < row.length; i++) {\n          col = undefined === cols[i] ? \"col\" + i : cols[i];\n          dataPoint[col] = row[i];\n        }\n\n        res.push(dataPoint);\n      }\n\n      return res;\n    }\n  });\n  /**\r\n   * @ignore\r\n   */\n\n  Object.defineProperty(CSVParser, \"CSVToArray\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (data, delimiter) {\n      // Check to see if the delimiter is defined. If not,\n      // then default to comma.\n      delimiter = delimiter || ','; // Create a regular expression to parse the CSV values.\n\n      var objPattern = new RegExp( // Delimiters.\n      \"(\\\\\" + delimiter + \"|\\\\r?\\\\n|\\\\r|^)\" + // Quoted fields.\n      \"(?:\\\"([^\\\"]*(?:\\\"\\\"[^\\\"]*)*)\\\"|\" + // Standard fields.\n      \"([^\\\"\\\\\" + delimiter + \"\\\\r\\\\n]*))\", \"gi\"); // Create an array to hold our data. Give the array\n      // a default empty first row.\n\n      var arrData = [[]]; // Create an array to hold our individual pattern\n      // matching groups.\n\n      var arrMatches = null; // Keep looping over the regular expression matches\n      // until we can no longer find a match.\n\n      while (true) {\n        arrMatches = objPattern.exec(data);\n\n        if (!arrMatches) {\n          break;\n        } // Get the delimiter that was found.\n\n\n        var strMatchedDelimiter = arrMatches[1]; // Check to see if the given delimiter has a length\n        // (is not the start of string) and if it matches\n        // field delimiter. If id does not, then we know\n        // that this delimiter is a row delimiter.\n\n        if (strMatchedDelimiter.length && strMatchedDelimiter !== delimiter) {\n          // Since we have reached a new row of data,\n          // add an empty row to our data array.\n          arrData.push([]);\n        } // Now that we have our delimiter out of the way,\n        // let's check to see which kind of value we\n        // captured (quoted or unquoted).\n\n\n        var strMatchedValue = void 0;\n\n        if (arrMatches[2]) {\n          // We found a quoted value. When we capture\n          // this value, unescape any double quotes.\n          strMatchedValue = arrMatches[2].replace(new RegExp(\"\\\"\\\"\", \"g\"), \"\\\"\");\n        } else {\n          // We found a non-quoted value.\n          strMatchedValue = arrMatches[3];\n        } // Now that we have our value string, let's add\n        // it to the data array.\n\n\n        arrData[arrData.length - 1].push(strMatchedValue);\n      } // Return the parsed data.\n\n\n      return arrData;\n    }\n  });\n  Object.defineProperty(CSVParser, \"_applyDefaults\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (options) {\n      var normalized = {};\n      var defaults = {\n        delimiter: \",\",\n        reverse: false,\n        skipRows: 0,\n        skipEmpty: true,\n        useColumnNames: false\n      };\n\n      if (!options) {\n        options = {};\n      }\n\n      $object.each(defaults, function (key, val) {\n        normalized[key] = options[key] || val;\n      });\n      return normalized;\n    }\n  });\n  return CSVParser;\n}();\n\nexport { CSVParser }; //# sourceMappingURL=DataParser.js.map","map":null,"metadata":{},"sourceType":"module"}