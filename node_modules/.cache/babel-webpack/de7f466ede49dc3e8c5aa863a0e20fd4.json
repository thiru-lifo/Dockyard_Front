{"ast":null,"code":"import { __extends, __values } from \"tslib\";\nimport { ValueAxis } from \"./ValueAxis\";\nimport * as $utils from \"../../../core/util/Utils\";\nimport * as $math from \"../../../core/util/Math\";\n/**\r\n * Creates a duration axis.\r\n *\r\n * @see {@link https://www.amcharts.com/docs/v5/charts/xy-chart/axes/duration-axis/} for more info\r\n * @important\r\n */\n\nvar DurationAxis =\n/** @class */\nfunction (_super) {\n  __extends(DurationAxis, _super);\n\n  function DurationAxis() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    Object.defineProperty(_this, \"_dataGrouped\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_groupingCalculated\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(_this, \"_intervalDuration\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1\n    });\n    return _this;\n  }\n\n  Object.defineProperty(DurationAxis.prototype, \"_afterNew\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function () {\n      this._settings.themeTags = $utils.mergeTags(this._settings.themeTags, [\"axis\"]);\n\n      _super.prototype._afterNew.call(this);\n    }\n  });\n  Object.defineProperty(DurationAxis.prototype, \"_adjustMinMax\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (min, max, gridCount, strictMode) {\n      var e_1, _a;\n\n      var minMaxStep;\n      var durationFormatter = this.getDurationFormatter();\n      var baseUnit = this.get(\"baseUnit\"); // we don't allow to go to smaller units, setting so to avoid invalidation\n\n      this.setRaw(\"maxPrecision\", 0);\n\n      if (baseUnit == \"millisecond\" || baseUnit == \"second\" || baseUnit == \"minute\" || baseUnit == \"hour\") {\n        // will fail if 0\n        if (gridCount <= 1) {\n          gridCount = 1;\n        }\n\n        gridCount = Math.round(gridCount); //let initialMin: number = min;\n        //let initialMax: number = max;\n\n        var difference = max - min; // in case min and max is the same, use max\n\n        if (difference === 0) {\n          difference = Math.abs(max);\n        }\n\n        var step = difference / gridCount;\n        var divisors = [60, 30, 20, 15, 10, 2, 1];\n        var realDivisor = 1;\n\n        if (baseUnit == \"hour\") {\n          divisors = [24, 12, 6, 4, 2, 1];\n        }\n\n        try {\n          for (var divisors_1 = __values(divisors), divisors_1_1 = divisors_1.next(); !divisors_1_1.done; divisors_1_1 = divisors_1.next()) {\n            var divisor = divisors_1_1.value;\n\n            if (difference / divisor > gridCount) {\n              realDivisor = divisor;\n              break;\n            }\n          }\n        } catch (e_1_1) {\n          e_1 = {\n            error: e_1_1\n          };\n        } finally {\n          try {\n            if (divisors_1_1 && !divisors_1_1.done && (_a = divisors_1.return)) _a.call(divisors_1);\n          } finally {\n            if (e_1) throw e_1.error;\n          }\n        }\n\n        var count = Math.ceil((max - min) / realDivisor / gridCount);\n        var exponent = Math.log(Math.abs(count)) * Math.LOG10E;\n        var power = Math.pow(10, Math.floor(exponent)) / 10;\n        var reducedCount = count / power; // find closest to divisor\n\n        var closest = $math.closest(divisors, reducedCount);\n        count = closest * power;\n        step = realDivisor * count;\n        min = Math.floor(min / step) * step;\n        max = Math.ceil(max / step) * step;\n        /*\r\n        causese SO with seconds\r\n        if (strictMode) {\r\n            min -= step;\r\n            if (min < 0 && initialMin >= 0) {\r\n                min = 0;\r\n            }\r\n            max += step;\r\n                  if (max > 0 && initialMax <= 0) {\r\n                max = 0;\r\n            }\r\n        }*/\n\n        minMaxStep = {\n          min: min,\n          max: max,\n          step: step\n        };\n      } else {\n        minMaxStep = _super.prototype._adjustMinMax.call(this, min, max, gridCount, strictMode);\n      } // choose duration formatter based on step\n\n\n      this.setPrivateRaw(\"durationFormat\", durationFormatter.getFormat(minMaxStep.step, minMaxStep.max, baseUnit));\n      return minMaxStep;\n    }\n  });\n  Object.defineProperty(DurationAxis.prototype, \"_formatText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (value) {\n      var formatter = this.getDurationFormatter();\n      return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n    }\n  });\n  /**\r\n   * Returns text to be used in an axis tooltip for specific relative position.\r\n   *\r\n   * @param   position  Position\r\n   * @return            Tooltip text\r\n   */\n\n  Object.defineProperty(DurationAxis.prototype, \"getTooltipText\", {\n    enumerable: false,\n    configurable: true,\n    writable: true,\n    value: function (position) {\n      var formatter = this.getDurationFormatter();\n      var extraDecimals = this.get(\"extraTooltipPrecision\", 0);\n      var decimals = this.getPrivate(\"stepDecimalPlaces\", 0) + extraDecimals;\n      var value = $math.round(this.positionToValue(position), decimals);\n      return formatter.format(value, this.getPrivate(\"durationFormat\"), this.get(\"baseUnit\"));\n    }\n  });\n  Object.defineProperty(DurationAxis, \"className\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: \"DurationAxis\"\n  });\n  Object.defineProperty(DurationAxis, \"classNames\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: ValueAxis.classNames.concat([DurationAxis.className])\n  });\n  return DurationAxis;\n}(ValueAxis);\n\nexport { DurationAxis }; //# sourceMappingURL=DurationAxis.js.map","map":null,"metadata":{},"sourceType":"module"}