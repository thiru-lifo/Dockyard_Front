{"ast":null,"code":"/** @ignore */\n\n/** */\nimport * as $math from \"./Math\";\n/**\r\n * @ignore\r\n */\n\nexport function segmentedLine(display, segments) {\n  for (var s = 0, len = segments.length; s < len; s++) {\n    var groups = segments[s];\n\n    if (groups.length > 0) {\n      var firstGroup = groups[0];\n\n      if (firstGroup.length > 0) {\n        var firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n\n        for (var g = 0, len_1 = groups.length; g < len_1; g++) {\n          line(display, groups[g]);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function line(display, points) {\n  for (var p = 0, len = points.length; p < len; p++) {\n    var point = points[p];\n    display.lineTo(point.x, point.y);\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function moveTo(display, point) {\n  display.moveTo(point.x, point.y);\n}\n/**\r\n * @ignore\r\n */\n\nexport function clear(display) {\n  display.clear();\n}\n/**\r\n * @ignore\r\n */\n\nexport function smoothedSegmentedline(display, segments, tensionX, tensionY) {\n  for (var s = 0, len = segments.length; s < len; s++) {\n    var groups = segments[s];\n\n    if (groups.length > 0) {\n      var firstGroup = groups[0];\n\n      if (firstGroup.length > 0) {\n        var firstPoint = firstGroup[0];\n        display.moveTo(firstPoint.x, firstPoint.y);\n\n        for (var g = 0, len_2 = groups.length; g < len_2; g++) {\n          var points = groups[g];\n\n          if (points.length > 0) {\n            display.lineTo(points[0].x, points[0].y);\n          }\n\n          smoothedLine(display, points, tensionX, tensionY);\n        }\n      }\n    }\n  }\n}\n/**\r\n * @ignore\r\n */\n\nexport function smoothedLine(display, points, tensionX, tensionY) {\n  for (var i = points.length - 1; i > 0; i--) {\n    var p0 = points[i];\n    var p1 = points[i - 1];\n\n    if (Math.abs(p0.x - p1.x) < 0.1 && Math.abs(p0.y - p1.y) < 0.1) {\n      points.splice(i - 1, 1);\n    }\n  }\n\n  if (points.length < 3 || tensionX >= 1 && tensionY >= 1) {\n    line(display, points);\n    return;\n  }\n\n  tensionX = 1 - tensionX + 0.00001;\n  tensionY = 1 - tensionY + 0.00001;\n  var first = points[0];\n  var last = points[points.length - 1];\n  var closed = false;\n\n  if ($math.round(first.x, 3) == $math.round(last.x) && $math.round(first.y) == $math.round(last.y)) {\n    closed = true;\n  } // Can't moveTo here, as it wont be possible to have fill then.\n\n\n  var path = \"\";\n\n  for (var i = 0, len = points.length - 1; i < len; i++) {\n    var p0 = points[i - 1];\n    var p1 = points[i];\n    var p2 = points[i + 1];\n    var p3 = points[i + 2];\n\n    if (i === 0) {\n      if (closed) {\n        p0 = points[len - 2];\n      } else {\n        p0 = points[0];\n      }\n    } else if (i == len - 1) {\n      if (closed) {\n        p3 = points[1];\n      } else {\n        p3 = p2;\n      }\n    }\n\n    var controlPointA = $math.getCubicControlPointA(p0, p1, p2, tensionX, tensionY);\n    var controlPointB = $math.getCubicControlPointB(p1, p2, p3, tensionX, tensionY);\n    display.bezierCurveTo(controlPointA.x, controlPointA.y, controlPointB.x, controlPointB.y, p2.x, p2.y);\n  }\n\n  return path;\n} //# sourceMappingURL=Draw.js.map","map":null,"metadata":{},"sourceType":"module"}